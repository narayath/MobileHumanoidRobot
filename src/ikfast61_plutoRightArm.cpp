/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x1000004a generated on 2021-10-19 22:12:01.067943
/// Generated using solver transform6d
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x1000004a);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40;
x0=IKcos(j[0]);
x1=IKsin(j[0]);
x2=IKsin(j[2]);
x3=IKcos(j[2]);
x4=IKsin(j[1]);
x5=IKsin(j[4]);
x6=IKcos(j[4]);
x7=IKcos(j[3]);
x8=IKcos(j[1]);
x9=IKsin(j[3]);
x10=IKcos(j[5]);
x11=IKsin(j[5]);
x12=((1.0)*x7);
x13=((0.029)*x1);
x14=((1.0)*x5);
x15=((1.0)*x6);
x16=((0.1075)*x1);
x17=((0.029)*x9);
x18=((1.0)*x1);
x19=((1.0)*x2);
x20=((1.0)*x9);
x21=((1.0)*x0);
x22=(x0*x2);
x23=(x7*x8);
x24=((-1.0)*x9);
x25=(x3*x8);
x26=(x3*x4);
x27=(x8*x9);
x28=(x4*x9);
x29=(x0*x26);
x30=(x18*x26);
x31=(x18*x27);
x32=(((x22*x4))+(((-1.0)*x18*x3)));
x33=(((x0*x3))+((x1*x2*x4)));
x34=((((-1.0)*x19*x27))+((x12*x4)));
x35=(((x18*x2))+((x21*x26)));
x36=(x32*x9);
x37=((((-1.0)*x20*x32))+(((-1.0)*x0*x12*x8)));
x38=((((-1.0)*x20*x33))+(((-1.0)*x1*x12*x8)));
x39=((((-1.0)*x14*x25))+(((-1.0)*x15*x34)));
x40=(((x14*(((((-1.0)*x30))+((x0*x19))))))+(((-1.0)*x15*x38)));
eerot[0]=((((-1.0)*x35*x6))+((x37*x5)));
eerot[1]=(((x10*((((x0*x24*x8))+((x32*x7))))))+((x11*(((((-1.0)*x14*x35))+(((-1.0)*x15*x37)))))));
eerot[2]=((((-1.0)*x10*(((((1.0)*x35*x5))+(((1.0)*x6*(((((-1.0)*x0*x23))+((x24*x32))))))))))+((x11*(((((-1.0)*x12*x32))+((x0*x20*x8)))))));
IkReal x41=((1.0)*x2);
eetrans[0]=((((0.0775)*x1))+((x6*(((((-0.029)*x29))+(((-1.0)*x13*x41))))))+((x5*(((((-1.0)*x17*x32))+(((-0.029)*x0*x23))))))+(((-0.1075)*x29))+(((-1.0)*x16*x41)));
eerot[3]=(((x38*x5))+((x6*(((((-1.0)*x30))+x22)))));
eerot[4]=(((x10*(((((-1.0)*x31))+((x33*x7))))))+((x11*x40)));
eerot[5]=(((x10*x40))+((x11*(((((-1.0)*x12*x33))+x31)))));
IkReal x42=((1.0)*x13);
eetrans[1]=(((x5*(((((-1.0)*x23*x42))+(((-1.0)*x17*x33))))))+(((-0.0775)*x0))+(((-1.0)*x16*x26))+(((0.1075)*x22))+((x6*(((((0.029)*x22))+(((-1.0)*x26*x42)))))));
eerot[6]=((((-1.0)*x15*x25))+((x34*x5)));
eerot[7]=(((x10*((((x2*x23))+x28))))+((x11*x39)));
eerot[8]=(((x10*x39))+((x11*(((((-1.0)*x12*x2*x8))+(((-1.0)*x20*x4)))))));
eetrans[2]=((0.372)+((x5*(((((-1.0)*x17*x2*x8))+(((0.029)*x4*x7))))))+(((-0.1075)*x25))+(((-0.029)*x25*x6)));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API int* GetFreeParameters() { return NULL; }
IKFAST_API int GetNumJoints() { return 6; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=((-1.0)*r02);
new_r01=r01;
new_r02=r00;
new_px=((((-0.029)*r00))+px);
new_r10=((-1.0)*r12);
new_r11=r11;
new_r12=r10;
new_py=((((-0.029)*r10))+py);
new_r20=((-1.0)*r22);
new_r21=r21;
new_r22=r20;
new_pz=((-0.372)+(((-0.029)*r20))+pz);
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x43=((1.0)*px);
IkReal x44=((1.0)*pz);
IkReal x45=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x45))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x44)));
rxp0_2=((((-1.0)*r10*x43))+((py*r00)));
rxp1_0=((((-1.0)*r21*x45))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x44)));
rxp1_2=((((-1.0)*r11*x43))+((py*r01)));
rxp2_0=((((-1.0)*r22*x45))+((pz*r12)));
rxp2_1=((((-1.0)*r02*x44))+((px*r22)));
rxp2_2=((((-1.0)*r12*x43))+((py*r02)));
{
IkReal j0eval[2];
j0eval[0]=((px*px)+(py*py));
j0eval[1]=(pp+(((-1.0)*(pz*pz))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((px*px)+(py*py));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
IkReal x46=((0.1075)*r22);
IkReal x47=((1.0)*pz);
IkReal x48=(pz*r22);
IkReal x49=((0.215)*x48);
IkReal x50=((-0.0111)+(((-1.0)*x49)));
IkReal x51=((((-1.0)*x47))+x46);
IkReal x52=((-1.0)*pz);
IkReal x53=((-0.0111)+x49);
IkReal x54=((((-1.0)*x47))+(((-1.0)*x46)));
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=x48;
rxp0_0=(pz*r10);
rxp0_1=(r00*x52);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x52);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x52);
rxp2_2=0;
IkReal gconst0=x53;
IkReal gconst1=x50;
IkReal gconst2=x51;
IkReal gconst3=x54;
IkReal gconst4=x53;
IkReal gconst5=x50;
IkReal gconst6=x51;
IkReal gconst7=x54;
IkReal gconst8=x53;
IkReal gconst9=x50;
IkReal gconst10=x51;
IkReal gconst11=x54;
IkReal gconst12=x53;
IkReal gconst13=x50;
IkReal gconst14=x51;
IkReal gconst15=x54;
IkReal x55=pz*pz;
IkReal x56=r21*r21;
IkReal x57=r22*r22;
IkReal x58=pz*pz*pz*pz;
IkReal x59=r20*r20;
IkReal x60=(r20*r21);
IkReal x61=((0.7396)*x58);
IkReal x62=((0.00820956)*x55);
IkReal x63=(x55*x57);
IkReal x64=(x58*x59);
IkReal x65=(x55*x59);
IkReal x66=(x57*x58);
IkReal x67=(x60*x62);
IkReal x68=(((x60*x61))+(((2.2781529e-5)*x60)));
j5eval[0]=((IKabs(((((-1.0)*x56*x61))+((x57*x62))+((x56*x62))+(((-2.2781529e-5)*x56))+(((-2.2781529e-5)*x57))+(((-1.0)*x57*x61)))))+(IKabs((x67+(((-1.0)*x68)))))+(((0.5)*(IKabs(((((-5.69538225e-6)*x57))+(((-5.69538225e-6)*x59))+(((0.00205239)*x65))+(((0.00205239)*x63))+(((-0.1849)*x66))+(((-0.1849)*x64)))))))+(((0.5)*(IKabs(((((0.01641912)*x55*x56))+(((0.01231434)*x63))+(((-1.1094)*x66))+(((-4.5563058e-5)*x56))+(((-3.41722935e-5)*x57))+(((1.13907645e-5)*x59))+(((-0.00410478)*x65))+(((-1.4792)*x56*x58))+(((0.3698)*x64)))))))+(IKabs((x68+(((-1.0)*x67))))));
if( IKabs(j5eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j0, j4, j5]

} else
{
IkReal op[8+1], zeror[8];
int numroots;
IkReal x69=r20*r20;
IkReal x70=pz*pz;
IkReal x71=r21*r21;
IkReal x72=((0.09245)*gconst12);
IkReal x73=(gconst0*gconst11);
IkReal x74=(gconst5*gconst6);
IkReal x75=((1.0)*gconst12);
IkReal x76=(gconst13*gconst14);
IkReal x77=(gconst14*gconst5);
IkReal x78=(gconst1*pz);
IkReal x79=((1.0)*gconst2);
IkReal x80=(r20*r21);
IkReal x81=(gconst7*gconst8);
IkReal x82=(gconst4*pz);
IkReal x83=(gconst15*gconst3);
IkReal x84=(gconst13*gconst6);
IkReal x85=((1.0)*gconst4);
IkReal x86=(gconst1*gconst10);
IkReal x87=(gconst12*gconst7);
IkReal x88=((0.046225)*gconst4);
IkReal x89=(gconst15*gconst4);
IkReal x90=(gconst11*gconst8);
IkReal x91=((0.1849)*pz);
IkReal x92=((0.046225)*gconst12);
IkReal x93=(gconst9*pz);
IkReal x94=(gconst4*gconst7);
IkReal x95=(gconst2*gconst9);
IkReal x96=(gconst12*pz);
IkReal x97=(gconst10*gconst9);
IkReal x98=(gconst0*gconst3);
IkReal x99=((0.09245)*gconst4);
IkReal x100=(gconst1*gconst2);
IkReal x101=(gconst3*gconst8);
IkReal x102=(gconst12*gconst15);
IkReal x103=(gconst3*x69);
IkReal x104=(gconst14*x70);
IkReal x105=((0.3698)*x71);
IkReal x106=(gconst6*x69);
IkReal x107=(gconst6*x70);
IkReal x108=((0.7396)*x71);
IkReal x109=(gconst9*x69);
IkReal x110=((1.0)*x86);
IkReal x111=(gconst1*x69);
IkReal x112=(gconst11*x69);
IkReal x113=(gconst14*x69);
IkReal x114=(gconst11*x70);
IkReal x115=((0.1849)*gconst12*x71);
IkReal x116=((0.1849)*gconst4*x71);
IkReal x117=(x109*x92);
IkReal x118=((0.00820956)*x70*x80);
IkReal x119=(x109*x88);
IkReal x120=(x111*x92);
IkReal x121=(x111*x88);
IkReal x122=((0.09245)*x113*x93);
IkReal x123=(pz*x112*x72);
IkReal x124=((0.09245)*x112*x82);
IkReal x125=(pz*x103*x72);
IkReal x126=((0.09245)*x106*x93);
IkReal x127=((0.09245)*x113*x78);
IkReal x128=((0.09245)*x103*x82);
IkReal x129=((0.09245)*x106*x78);
IkReal x130=((0.1849)*x104*x112);
IkReal x131=((0.1849)*x103*x104);
IkReal x132=((0.1849)*x106*x114);
IkReal x133=((0.1849)*x103*x107);
IkReal x134=((((0.7396)*x80*(x70*x70)))+(((2.2781529e-5)*x80)));
IkReal x135=(x118+(((-1.0)*x134)));
IkReal x136=((((-1.0)*x118))+x134);
IkReal x137=(x133+x121);
IkReal x138=(x128+x129);
IkReal x139=(x122+x123);
IkReal x140=(x130+x117);
IkReal x141=(x126+x127+x124+x125);
IkReal x142=(x131+x132+x120+x119);
op[0]=((((-1.0)*x140))+(((-1.0)*gconst15*x75*x90))+((x102*x97))+x139+(((-1.0)*x76*x97))+((x76*x90)));
op[1]=x135;
op[2]=((((-1.0)*x142))+((x87*x97))+(((-1.0)*gconst14*x109*x91))+(((-1.0)*gconst9*x76*x79))+((x89*x97))+((x102*x86))+(((-1.0)*x84*x97))+((x102*x95))+(((-1.0)*gconst11*x75*x81))+((x101*x76))+x141+(((-1.0)*x77*x97))+(((-1.0)*gconst11*x104*x108))+(((-1.0)*gconst9*x115))+(((-1.0)*gconst8*x75*x83))+(((-1.0)*gconst12*x112*x91))+((x109*x72))+(((0.3698)*x104*x112))+(((-1.0)*gconst15*x73*x75))+((gconst14*x105*x93))+((x73*x76))+(((-1.0)*x110*x76))+((gconst11*x105*x96))+(((-1.0)*gconst15*x85*x90))+((x84*x90))+((x77*x90)));
op[3]=x135;
op[4]=((((-1.0)*x140))+(((-1.0)*gconst1*x76*x79))+((x87*x95))+((x111*x72))+(((-0.1849)*x112*x82))+((x89*x95))+(((-1.0)*gconst7*x73*x75))+(((-1.0)*gconst3*x75*x81))+((x101*x84))+(((-0.1849)*x113*x78))+(((-1.0)*gconst9*x79*x84))+((gconst14*x105*x78))+((x86*x89))+((x86*x87))+(((-1.0)*gconst15*x73*x85))+(((-1.0)*gconst1*x115))+((x101*x77))+x139+x138+((x74*x90))+((x73*x84))+(((-1.0)*x137))+(((-1.0)*gconst0*x75*x83))+(((-1.0)*gconst3*x104*x108))+(((-1.0)*gconst11*x81*x85))+(((-1.0)*x110*x84))+(((-1.0)*gconst12*x103*x91))+(((0.3698)*x106*x114))+(((0.3698)*x103*x104))+(((-1.0)*gconst9*x116))+((x76*x98))+(((-1.0)*x74*x97))+(((-1.0)*gconst9*x106*x91))+((x109*x99))+((x73*x77))+((gconst6*x105*x93))+(((-1.0)*gconst8*x83*x85))+(((-1.0)*x110*x77))+(((-1.0)*gconst11*x107*x108))+(((-1.0)*gconst9*x77*x79))+((x94*x97))+((gconst11*x105*x82))+((x100*x102))+((gconst3*x105*x96)));
op[5]=x136;
op[6]=((((-1.0)*gconst1*x79*x84))+(((-1.0)*x142))+((x100*x87))+((x100*x89))+(((-1.0)*gconst3*x81*x85))+(((-1.0)*gconst9*x74*x79))+((x86*x94))+(((-1.0)*gconst0*x83*x85))+(((-1.0)*gconst1*x116))+((x101*x74))+x141+(((-1.0)*gconst1*x77*x79))+(((-1.0)*gconst7*x73*x85))+(((-1.0)*gconst7*x75*x98))+(((0.3698)*x103*x107))+((x111*x99))+((gconst6*x105*x78))+((x73*x74))+(((-0.1849)*x103*x82))+(((-1.0)*gconst3*x107*x108))+(((-0.1849)*x106*x78))+(((-1.0)*x110*x74))+((gconst3*x105*x82))+((x94*x95))+((x84*x98))+((x77*x98)));
op[7]=x136;
op[8]=((((-1.0)*gconst7*x85*x98))+((x100*x94))+x138+((x74*x98))+(((-1.0)*gconst1*x74*x79))+(((-1.0)*x137)));
polyroots8(op,zeror,numroots);
IkReal j5array[8], cj5array[8], sj5array[8], tempj5array[1];
int numsolutions = 0;
for(int ij5 = 0; ij5 < numroots; ++ij5)
{
IkReal htj5 = zeror[ij5];
tempj5array[0]=((2.0)*(atan(htj5)));
for(int kj5 = 0; kj5 < 1; ++kj5)
{
j5array[numsolutions] = tempj5array[kj5];
if( j5array[numsolutions] > IKPI )
{
    j5array[numsolutions]-=IK2PI;
}
else if( j5array[numsolutions] < -IKPI )
{
    j5array[numsolutions]+=IK2PI;
}
sj5array[numsolutions] = IKsin(j5array[numsolutions]);
cj5array[numsolutions] = IKcos(j5array[numsolutions]);
numsolutions++;
}
}
bool j5valid[8]={true,true,true,true,true,true,true,true};
_nj5 = 8;
for(int ij5 = 0; ij5 < numsolutions; ++ij5)
    {
if( !j5valid[ij5] )
{
    continue;
}
    j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
htj5 = IKtan(j5/2);

_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < numsolutions; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
{
IkReal j4eval[2];
IkReal x143=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x143);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x143);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x143);
rxp2_2=0;
IkReal x144=(cj5*r20);
IkReal x145=(r21*sj5);
j4eval[0]=((r22*r22)+(((-2.0)*x144*x145))+(x145*x145)+(x144*x144));
j4eval[1]=((((9.30232558139535)*(IKabs(((((0.1075)*x145))+(((-0.1075)*x144)))))))+(IKabs(r22)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
IkReal x146=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x146);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x146);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x146);
rxp2_2=0;
IkReal x147=pz*pz;
IkReal x148=(cj5*r20);
IkReal x149=(r21*sj5);
j4eval[0]=((IKabs((((pz*x149))+(((-1.0)*pz*x148)))))+(IKabs((pz*r22))));
j4eval[1]=((((-2.0)*x147*x148*x149))+((x147*(x149*x149)))+((x147*(x148*x148)))+((x147*(r22*r22))));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
IkReal x150=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x150);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x150);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x150);
rxp2_2=0;
IkReal x151=cj5*cj5;
IkReal x152=sj5*sj5;
IkReal x153=((0.0775)*cj5);
IkReal x154=((0.0775)*sj5);
IkReal x155=((2.0)*cj5*sj5);
j0eval[0]=(((x151*(r11*r11)))+((x152*(r10*r10)))+((x152*(r00*r00)))+((r10*r11*x155))+((x151*(r01*r01)))+((r00*r01*x155)));
j0eval[1]=((IKabs((((r00*x154))+((r01*x153)))))+(IKabs(((((-1.0)*r10*x154))+(((-1.0)*r11*x153))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(pz);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j4eval[0]=((IKabs(r22))+(((9.30232558139535)*(IKabs(((((0.1075)*r21*sj5))+(((-0.1075)*cj5*r20))))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
IkReal x156=((0.0775)*cj5);
IkReal x157=((0.0775)*sj5);
j0eval[0]=((IKabs((((r00*x157))+((r01*x156)))))+(IKabs(((((-1.0)*r10*x157))+(((-1.0)*r11*x156))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x158=((0.0775)*cj5);
IkReal x159=((0.0775)*sj5);
CheckValue<IkReal> x161 = IKatan2WithCheck(IkReal(((((-1.0)*r10*x159))+(((-1.0)*r11*x158)))),IkReal((((r00*x159))+((r01*x158)))),IKFAST_ATAN2_MAGTHRESH);
if(!x161.valid){
continue;
}
IkReal x160=x161.value;
j0array[0]=((-1.0)*x160);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x160)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal j4eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j4eval[0]=(((r21*sj5))+(((-1.0)*cj5*r20)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j4eval[0]=(((r01*sj5))+(((-1.0)*cj5*r00)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j4eval[0]=((((-1.0)*cj5*r10))+((r11*sj5)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x162=((31.0)*cj0);
IkReal x163=(r02*sj0);
CheckValue<IkReal> x164=IKPowWithIntegerCheck(((((-43.0)*cj5*r10))+(((43.0)*r11*sj5))),-1);
if(!x164.valid){
continue;
}
if( IKabs(((x164.value)*(((((-1.0)*x162*(r12*r12)))+(((31.0)*r12*x163))+x162)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-0.720930232558139)*x163))+(((0.720930232558139)*cj0*r12)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x164.value)*(((((-1.0)*x162*(r12*r12)))+(((31.0)*r12*x163))+x162))))+IKsqr(((((-0.720930232558139)*x163))+(((0.720930232558139)*cj0*r12))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x164.value)*(((((-1.0)*x162*(r12*r12)))+(((31.0)*r12*x163))+x162))), ((((-0.720930232558139)*x163))+(((0.720930232558139)*cj0*r12))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x165=IKcos(j4);
IkReal x166=IKsin(j4);
IkReal x167=(cj5*r00);
IkReal x168=(r11*sj5);
IkReal x169=(r01*sj5);
IkReal x170=((0.0775)*cj0);
IkReal x171=(cj5*r10);
IkReal x172=((0.0775)*sj0);
IkReal x173=((0.1075)*x165);
IkReal x174=((0.1075)*x166);
evalcond[0]=(x173+(((-1.0)*r12*x170))+((r02*x172)));
evalcond[1]=(((r22*x173))+(((-1.0)*cj5*r20*x174))+((r21*sj5*x174)));
evalcond[2]=(((x169*x174))+x172+(((-1.0)*x167*x174))+((r02*x173)));
evalcond[3]=((((-1.0)*x170))+((x168*x174))+(((-1.0)*x171*x174))+((r12*x173)));
evalcond[4]=((((-1.0)*x174))+((x168*x170))+((x167*x172))+(((-1.0)*x170*x171))+(((-1.0)*x169*x172)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x946=(cj0*r12);
IkReal x947=((31.0)*sj0);
CheckValue<IkReal> x948=IKPowWithIntegerCheck(((((43.0)*r01*sj5))+(((-43.0)*cj5*r00))),-1);
if(!x948.valid){
continue;
}
if( IKabs(((x948.value)*(((((-31.0)*r02*x946))+(((-1.0)*x947))+((x947*(r02*r02))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-0.720930232558139)*r02*sj0))+(((0.720930232558139)*x946)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x948.value)*(((((-31.0)*r02*x946))+(((-1.0)*x947))+((x947*(r02*r02)))))))+IKsqr(((((-0.720930232558139)*r02*sj0))+(((0.720930232558139)*x946))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x948.value)*(((((-31.0)*r02*x946))+(((-1.0)*x947))+((x947*(r02*r02)))))), ((((-0.720930232558139)*r02*sj0))+(((0.720930232558139)*x946))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x949=IKcos(j4);
IkReal x950=IKsin(j4);
IkReal x951=(cj5*r00);
IkReal x952=(r11*sj5);
IkReal x953=(r01*sj5);
IkReal x954=((0.0775)*cj0);
IkReal x955=(cj5*r10);
IkReal x956=((0.0775)*sj0);
IkReal x957=((0.1075)*x949);
IkReal x958=((0.1075)*x950);
evalcond[0]=(((r02*x956))+(((-1.0)*r12*x954))+x957);
evalcond[1]=(((r22*x957))+(((-1.0)*cj5*r20*x958))+((r21*sj5*x958)));
evalcond[2]=(((r02*x957))+(((-1.0)*x951*x958))+((x953*x958))+x956);
evalcond[3]=(((x952*x958))+((r12*x957))+(((-1.0)*x954))+(((-1.0)*x955*x958)));
evalcond[4]=(((x951*x956))+((x952*x954))+(((-1.0)*x953*x956))+(((-1.0)*x954*x955))+(((-1.0)*x958)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x959=((0.0775)*r22);
IkReal x960=(r02*sj0);
IkReal x961=(cj0*r12);
CheckValue<IkReal> x962=IKPowWithIntegerCheck(((((0.1075)*r21*sj5))+(((-0.1075)*cj5*r20))),-1);
if(!x962.valid){
continue;
}
if( IKabs(((x962.value)*(((((-1.0)*x959*x961))+((x959*x960)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((0.720930232558139)*x961))+(((-0.720930232558139)*x960)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x962.value)*(((((-1.0)*x959*x961))+((x959*x960))))))+IKsqr(((((0.720930232558139)*x961))+(((-0.720930232558139)*x960))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x962.value)*(((((-1.0)*x959*x961))+((x959*x960))))), ((((0.720930232558139)*x961))+(((-0.720930232558139)*x960))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x963=IKcos(j4);
IkReal x964=IKsin(j4);
IkReal x965=(cj5*r00);
IkReal x966=(r11*sj5);
IkReal x967=(r01*sj5);
IkReal x968=((0.0775)*cj0);
IkReal x969=(cj5*r10);
IkReal x970=((0.0775)*sj0);
IkReal x971=((0.1075)*x963);
IkReal x972=((0.1075)*x964);
evalcond[0]=((((-1.0)*r12*x968))+((r02*x970))+x971);
evalcond[1]=(((r21*sj5*x972))+((r22*x971))+(((-1.0)*cj5*r20*x972)));
evalcond[2]=((((-1.0)*x965*x972))+((x967*x972))+((r02*x971))+x970);
evalcond[3]=((((-1.0)*x969*x972))+((x966*x972))+((r12*x971))+(((-1.0)*x968)));
evalcond[4]=(((x965*x970))+(((-1.0)*x967*x970))+((x966*x968))+(((-1.0)*x968*x969))+(((-1.0)*x972)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x974 = IKatan2WithCheck(IkReal(((0.1075)*r22)),IkReal(((((0.1075)*r21*sj5))+(((-0.1075)*cj5*r20)))),IKFAST_ATAN2_MAGTHRESH);
if(!x974.valid){
continue;
}
IkReal x973=x974.value;
j4array[0]=((-1.0)*x973);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x973)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

{
IkReal j0eval[3];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
IkReal x975=(r21*sj5);
IkReal x976=(cj5*r20);
IkReal x977=((1.0)*cj4*sj5);
IkReal x978=((1.0)*cj4*cj5);
j0eval[0]=((((-1.0)*x976))+x975);
j0eval[1]=IKsign(((((2.4025)*x975))+(((-2.4025)*x976))));
j0eval[2]=((IKabs(((((-1.0)*r11*x978))+(((-1.0)*r10*x977)))))+(IKabs(((((-1.0)*r01*x978))+(((-1.0)*r00*x977))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
IkReal x979=((1333.0)*sj4);
IkReal x980=(r20*sj5);
IkReal x981=(cj5*r21);
IkReal x982=((1333.0)*cj4*sj5);
IkReal x983=((1333.0)*cj4*cj5);
j0eval[0]=((((-1.0)*x980))+(((-1.0)*x981)));
j0eval[1]=((IKabs((((r12*x979))+((r10*x983))+(((-1.0)*r11*x982)))))+(IKabs(((((-1.0)*r01*x982))+((r00*x983))+((r02*x979))))));
j0eval[2]=IKsign(((((-961.0)*x980))+(((-961.0)*x981))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j0eval[0]=r12;
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x984=((1.38709677419355)*sj4);
IkReal x985=(cj5*r00);
IkReal x986=(r01*sj5);
IkReal x987=((43.0)*cj4);
IkReal x988=((43.0)*r02*sj4);
CheckValue<IkReal> x989=IKPowWithIntegerCheck(r12,-1);
if(!x989.valid){
continue;
}
if( IKabs(((((-1.38709677419355)*cj4*r02))+(((-1.0)*x984*x986))+((x984*x985)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.032258064516129)*(x989.value)*(((((-1.0)*x986*x988))+(((-1.0)*x987*(r02*r02)))+((x985*x988))+x987)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.38709677419355)*cj4*r02))+(((-1.0)*x984*x986))+((x984*x985))))+IKsqr(((0.032258064516129)*(x989.value)*(((((-1.0)*x986*x988))+(((-1.0)*x987*(r02*r02)))+((x985*x988))+x987))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(((((-1.38709677419355)*cj4*r02))+(((-1.0)*x984*x986))+((x984*x985))), ((0.032258064516129)*(x989.value)*(((((-1.0)*x986*x988))+(((-1.0)*x987*(r02*r02)))+((x985*x988))+x987))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x990=IKsin(j0);
IkReal x991=IKcos(j0);
IkReal x992=((0.1075)*cj4);
IkReal x993=(r11*sj5);
IkReal x994=(r01*sj5);
IkReal x995=((0.1075)*sj4);
IkReal x996=((0.0775)*x991);
IkReal x997=(cj5*x995);
IkReal x998=((0.0775)*x990);
evalcond[0]=((((-1.0)*r12*x996))+((r02*x998))+x992);
evalcond[1]=(((x994*x995))+((r02*x992))+(((-1.0)*r00*x997))+x998);
evalcond[2]=(((x993*x995))+((r12*x992))+(((-1.0)*r10*x997))+(((-1.0)*x996)));
evalcond[3]=(((cj5*r01*x998))+(((-1.0)*r10*sj5*x996))+(((-1.0)*cj5*r11*x996))+((r00*sj5*x998)));
evalcond[4]=(((x993*x996))+((cj5*r00*x998))+(((-1.0)*x994*x998))+(((-1.0)*cj5*r10*x996))+(((-1.0)*x995)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x999=((1333.0)*sj4);
IkReal x1000=((1333.0)*cj4*sj5);
IkReal x1001=((1333.0)*cj4*cj5);
CheckValue<IkReal> x1002 = IKatan2WithCheck(IkReal((((r12*x999))+(((-1.0)*r11*x1000))+((r10*x1001)))),IkReal((((r02*x999))+(((-1.0)*r01*x1000))+((r00*x1001)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1002.valid){
continue;
}
CheckValue<IkReal> x1003=IKPowWithIntegerCheck(IKsign(((((-961.0)*cj5*r21))+(((-961.0)*r20*sj5)))),-1);
if(!x1003.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x1002.value)+(((1.5707963267949)*(x1003.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1004=IKsin(j0);
IkReal x1005=IKcos(j0);
IkReal x1006=((0.1075)*cj4);
IkReal x1007=(r11*sj5);
IkReal x1008=(r01*sj5);
IkReal x1009=((0.1075)*sj4);
IkReal x1010=((0.0775)*x1005);
IkReal x1011=(cj5*x1009);
IkReal x1012=((0.0775)*x1004);
evalcond[0]=(x1006+((r02*x1012))+(((-1.0)*r12*x1010)));
evalcond[1]=(((x1008*x1009))+x1012+((r02*x1006))+(((-1.0)*r00*x1011)));
evalcond[2]=((((-1.0)*x1010))+((x1007*x1009))+((r12*x1006))+(((-1.0)*r10*x1011)));
evalcond[3]=(((cj5*r01*x1012))+((r00*sj5*x1012))+(((-1.0)*r10*sj5*x1010))+(((-1.0)*cj5*r11*x1010)));
evalcond[4]=(((cj5*r00*x1012))+(((-1.0)*x1009))+(((-1.0)*x1008*x1012))+((x1007*x1010))+(((-1.0)*cj5*r10*x1010)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1013=((3.3325)*cj4*cj5);
IkReal x1014=((3.3325)*cj4*sj5);
CheckValue<IkReal> x1015=IKPowWithIntegerCheck(IKsign(((((-2.4025)*cj5*r20))+(((2.4025)*r21*sj5)))),-1);
if(!x1015.valid){
continue;
}
CheckValue<IkReal> x1016 = IKatan2WithCheck(IkReal(((((-1.0)*r11*x1013))+(((-1.0)*r10*x1014)))),IkReal(((((-1.0)*r01*x1013))+(((-1.0)*r00*x1014)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1016.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1015.value)))+(x1016.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1017=IKsin(j0);
IkReal x1018=IKcos(j0);
IkReal x1019=((0.1075)*cj4);
IkReal x1020=(r11*sj5);
IkReal x1021=(r01*sj5);
IkReal x1022=((0.1075)*sj4);
IkReal x1023=((0.0775)*x1018);
IkReal x1024=(cj5*x1022);
IkReal x1025=((0.0775)*x1017);
evalcond[0]=((((-1.0)*r12*x1023))+x1019+((r02*x1025)));
evalcond[1]=(x1025+((r02*x1019))+((x1021*x1022))+(((-1.0)*r00*x1024)));
evalcond[2]=((((-1.0)*x1023))+((x1020*x1022))+(((-1.0)*r10*x1024))+((r12*x1019)));
evalcond[3]=(((r00*sj5*x1025))+((cj5*r01*x1025))+(((-1.0)*cj5*r11*x1023))+(((-1.0)*r10*sj5*x1023)));
evalcond[4]=(((cj5*r00*x1025))+(((-1.0)*x1021*x1025))+(((-1.0)*x1022))+((x1020*x1023))+(((-1.0)*cj5*r10*x1023)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x1026=((0.0775)*cj5);
IkReal x1027=((1.0)*pz);
IkReal x1028=((0.0775)*sj5);
IkReal x1029=((((-1.0)*r11*x1026))+(((-1.0)*r10*x1028)));
IkReal x1030=(((r01*x1026))+((r00*x1028)));
CheckValue<IkReal> x1033 = IKatan2WithCheck(IkReal(x1029),IkReal(x1030),IKFAST_ATAN2_MAGTHRESH);
if(!x1033.valid){
continue;
}
IkReal x1031=((1.0)*(x1033.value));
if((((x1030*x1030)+(x1029*x1029))) < -0.00001)
continue;
CheckValue<IkReal> x1034=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1030*x1030)+(x1029*x1029)))),-1);
if(!x1034.valid){
continue;
}
if( (((-1.0)*(x1034.value)*(((((-1.0)*cj5*r21*x1027))+(((-1.0)*r20*sj5*x1027)))))) < -1-IKFAST_SINCOS_THRESH || (((-1.0)*(x1034.value)*(((((-1.0)*cj5*r21*x1027))+(((-1.0)*r20*sj5*x1027)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1032=((-1.0)*(IKasin(((-1.0)*(x1034.value)*(((((-1.0)*cj5*r21*x1027))+(((-1.0)*r20*sj5*x1027))))))));
j0array[0]=((((-1.0)*x1031))+(((-1.0)*x1032)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1031))+(((1.0)*x1032)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal j4eval[1];
IkReal x1035=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1035);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1035);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1035);
rxp2_2=0;
j4eval[0]=(((r21*sj5))+(((-1.0)*cj5*r20)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
IkReal x1036=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1036);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1036);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1036);
rxp2_2=0;
j4eval[0]=(((r01*sj5))+(((-1.0)*cj5*r00)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
IkReal x1037=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1037);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1037);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1037);
rxp2_2=0;
j4eval[0]=((((-1.0)*cj5*r10))+((r11*sj5)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r10))+(IKabs(r11)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
IkReal x1038=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=0;
rxp0_0=0;
rxp0_1=(r00*x1038);
rxp0_2=0;
rxp1_0=0;
rxp1_1=(r01*x1038);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=0;
rxp2_2=0;
r10=0;
r11=0;
r22=0;
r02=0;
j4eval[0]=(((r21*sj5))+(((-1.0)*cj5*r20)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
IkReal x1039=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=0;
rxp0_0=0;
rxp0_1=(r00*x1039);
rxp0_2=0;
rxp1_0=0;
rxp1_1=(r01*x1039);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=0;
rxp2_2=0;
r10=0;
r11=0;
r22=0;
r02=0;
j4eval[0]=(((r01*sj5))+(((-1.0)*cj5*r00)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
IkReal x1040=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=0;
rxp0_0=0;
rxp0_1=(r00*x1040);
rxp0_2=0;
rxp1_0=0;
rxp1_1=(r01*x1040);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=0;
rxp2_2=0;
r10=0;
r11=0;
r22=0;
r02=0;
j4eval[0]=(((pz*r21*sj5))+(((-1.0)*cj5*pz*r20)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1041=((2150.0)*pz);
CheckValue<IkReal> x1042=IKPowWithIntegerCheck(((((-1.0)*cj5*r20*x1041))+((r21*sj5*x1041))),-1);
if(!x1042.valid){
continue;
}
if( IKabs(((111.0)*(x1042.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.720930232558139)*cj0*r12)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((111.0)*(x1042.value)))+IKsqr(((0.720930232558139)*cj0*r12))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((111.0)*(x1042.value)), ((0.720930232558139)*cj0*r12));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1043=IKcos(j4);
IkReal x1044=IKsin(j4);
IkReal x1045=((0.0775)*sj0);
IkReal x1046=(r01*sj5);
IkReal x1047=((1.0)*pz);
IkReal x1048=((0.215)*pz);
IkReal x1049=((0.0775)*cj0);
IkReal x1050=(r21*sj5);
IkReal x1051=(cj5*x1044);
IkReal x1052=((0.1075)*x1043);
IkReal x1053=((0.1075)*x1044);
evalcond[0]=(x1052+(((-1.0)*r12*x1049)));
evalcond[1]=(((r12*x1052))+(((-1.0)*x1049)));
evalcond[2]=(((x1050*x1053))+(((-0.1075)*r20*x1051))+(((-1.0)*x1047)));
evalcond[3]=((-0.0111)+(((-1.0)*r20*x1048*x1051))+((x1044*x1048*x1050)));
evalcond[4]=(x1045+(((-0.1075)*r00*x1051))+((x1046*x1053)));
evalcond[5]=((((-1.0)*x1053))+(((-1.0)*cj5*r20*x1047))+(((-1.0)*x1045*x1046))+((pz*x1050))+((cj5*r00*x1045)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x1054=IKPowWithIntegerCheck(((((43.0)*r01*sj5))+(((-43.0)*cj5*r00))),-1);
if(!x1054.valid){
continue;
}
if( IKabs(((-31.0)*sj0*(x1054.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.720930232558139)*cj0*r12)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-31.0)*sj0*(x1054.value)))+IKsqr(((0.720930232558139)*cj0*r12))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-31.0)*sj0*(x1054.value)), ((0.720930232558139)*cj0*r12));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1055=IKcos(j4);
IkReal x1056=IKsin(j4);
IkReal x1057=((0.0775)*sj0);
IkReal x1058=(r01*sj5);
IkReal x1059=((1.0)*pz);
IkReal x1060=((0.215)*pz);
IkReal x1061=((0.0775)*cj0);
IkReal x1062=(r21*sj5);
IkReal x1063=(cj5*x1056);
IkReal x1064=((0.1075)*x1055);
IkReal x1065=((0.1075)*x1056);
evalcond[0]=(x1064+(((-1.0)*r12*x1061)));
evalcond[1]=(((r12*x1064))+(((-1.0)*x1061)));
evalcond[2]=((((-1.0)*x1059))+((x1062*x1065))+(((-0.1075)*r20*x1063)));
evalcond[3]=((-0.0111)+((x1056*x1060*x1062))+(((-1.0)*r20*x1060*x1063)));
evalcond[4]=(x1057+(((-0.1075)*r00*x1063))+((x1058*x1065)));
evalcond[5]=((((-1.0)*cj5*r20*x1059))+((pz*x1062))+((cj5*r00*x1057))+(((-1.0)*x1057*x1058))+(((-1.0)*x1065)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x1066=IKPowWithIntegerCheck(((((0.1075)*r21*sj5))+(((-0.1075)*cj5*r20))),-1);
if(!x1066.valid){
continue;
}
if( IKabs((pz*(x1066.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.720930232558139)*cj0*r12)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((pz*(x1066.value)))+IKsqr(((0.720930232558139)*cj0*r12))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((pz*(x1066.value)), ((0.720930232558139)*cj0*r12));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1067=IKcos(j4);
IkReal x1068=IKsin(j4);
IkReal x1069=((0.0775)*sj0);
IkReal x1070=(r01*sj5);
IkReal x1071=((1.0)*pz);
IkReal x1072=((0.215)*pz);
IkReal x1073=((0.0775)*cj0);
IkReal x1074=(r21*sj5);
IkReal x1075=(cj5*x1068);
IkReal x1076=((0.1075)*x1067);
IkReal x1077=((0.1075)*x1068);
evalcond[0]=(x1076+(((-1.0)*r12*x1073)));
evalcond[1]=(((r12*x1076))+(((-1.0)*x1073)));
evalcond[2]=(((x1074*x1077))+(((-0.1075)*r20*x1075))+(((-1.0)*x1071)));
evalcond[3]=((-0.0111)+((x1068*x1072*x1074))+(((-1.0)*r20*x1072*x1075)));
evalcond[4]=(x1069+((x1070*x1077))+(((-0.1075)*r00*x1075)));
evalcond[5]=(((pz*x1074))+(((-1.0)*cj5*r20*x1071))+((cj5*r00*x1069))+(((-1.0)*x1069*x1070))+(((-1.0)*x1077)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r21))+(IKabs(r20)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
IkReal x1078=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1078);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1078);
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
r20=0;
r21=0;
r02=0;
r12=0;
j4eval[0]=(((r01*sj5))+(((-1.0)*cj5*r00)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
IkReal x1079=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1079);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1079);
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
r20=0;
r21=0;
r02=0;
r12=0;
j4eval[0]=((((-1.0)*cj5*r10))+((r11*sj5)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
IkReal x1080=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1080);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1080);
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
r20=0;
r21=0;
r02=0;
r12=0;
j4eval[0]=(((r01*sj5))+(((-1.0)*cj5*r00)));
j4eval[1]=pz;
j4eval[2]=r22;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x1081=IKPowWithIntegerCheck(((((43.0)*r01*sj5))+(((-43.0)*cj5*r00))),-1);
if(!x1081.valid){
continue;
}
CheckValue<IkReal> x1082=IKPowWithIntegerCheck(pz,-1);
if(!x1082.valid){
continue;
}
CheckValue<IkReal> x1083=IKPowWithIntegerCheck(r22,-1);
if(!x1083.valid){
continue;
}
if( IKabs(((-31.0)*sj0*(x1081.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.0516279069767442)*(x1082.value)*(x1083.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-31.0)*sj0*(x1081.value)))+IKsqr(((0.0516279069767442)*(x1082.value)*(x1083.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-31.0)*sj0*(x1081.value)), ((0.0516279069767442)*(x1082.value)*(x1083.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1084=IKcos(j4);
IkReal x1085=IKsin(j4);
IkReal x1086=(r11*sj5);
IkReal x1087=(cj5*r00);
IkReal x1088=((1.0)*pz);
IkReal x1089=(r01*sj5);
IkReal x1090=((0.0775)*cj0);
IkReal x1091=(cj5*r10);
IkReal x1092=((0.0775)*sj0);
IkReal x1093=(r22*x1084);
IkReal x1094=((0.1075)*x1085);
evalcond[0]=((-0.0111)+(((0.215)*pz*x1093)));
evalcond[1]=((((0.1075)*x1084))+(((-1.0)*r22*x1088)));
evalcond[2]=((((0.1075)*x1093))+(((-1.0)*x1088)));
evalcond[3]=(x1092+((x1089*x1094))+(((-1.0)*x1087*x1094)));
evalcond[4]=((((-1.0)*x1091*x1094))+((x1086*x1094))+(((-1.0)*x1090)));
evalcond[5]=(((x1087*x1092))+(((-1.0)*x1090*x1091))+((x1086*x1090))+(((-1.0)*x1094))+(((-1.0)*x1089*x1092)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x1095=IKPowWithIntegerCheck(((((-43.0)*cj5*r10))+(((43.0)*r11*sj5))),-1);
if(!x1095.valid){
continue;
}
if( IKabs(((31.0)*cj0*(x1095.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((9.30232558139535)*pz*r22)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((31.0)*cj0*(x1095.value)))+IKsqr(((9.30232558139535)*pz*r22))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((31.0)*cj0*(x1095.value)), ((9.30232558139535)*pz*r22));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1096=IKcos(j4);
IkReal x1097=IKsin(j4);
IkReal x1098=(r11*sj5);
IkReal x1099=(cj5*r00);
IkReal x1100=((1.0)*pz);
IkReal x1101=(r01*sj5);
IkReal x1102=((0.0775)*cj0);
IkReal x1103=(cj5*r10);
IkReal x1104=((0.0775)*sj0);
IkReal x1105=(r22*x1096);
IkReal x1106=((0.1075)*x1097);
evalcond[0]=((-0.0111)+(((0.215)*pz*x1105)));
evalcond[1]=((((-1.0)*r22*x1100))+(((0.1075)*x1096)));
evalcond[2]=((((0.1075)*x1105))+(((-1.0)*x1100)));
evalcond[3]=(x1104+((x1101*x1106))+(((-1.0)*x1099*x1106)));
evalcond[4]=((((-1.0)*x1103*x1106))+((x1098*x1106))+(((-1.0)*x1102)));
evalcond[5]=(((x1098*x1102))+((x1099*x1104))+(((-1.0)*x1106))+(((-1.0)*x1102*x1103))+(((-1.0)*x1101*x1104)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x1107=IKPowWithIntegerCheck(((((43.0)*r01*sj5))+(((-43.0)*cj5*r00))),-1);
if(!x1107.valid){
continue;
}
if( IKabs(((-31.0)*sj0*(x1107.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((9.30232558139535)*pz*r22)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-31.0)*sj0*(x1107.value)))+IKsqr(((9.30232558139535)*pz*r22))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-31.0)*sj0*(x1107.value)), ((9.30232558139535)*pz*r22));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1108=IKcos(j4);
IkReal x1109=IKsin(j4);
IkReal x1110=(r11*sj5);
IkReal x1111=(cj5*r00);
IkReal x1112=((1.0)*pz);
IkReal x1113=(r01*sj5);
IkReal x1114=((0.0775)*cj0);
IkReal x1115=(cj5*r10);
IkReal x1116=((0.0775)*sj0);
IkReal x1117=(r22*x1108);
IkReal x1118=((0.1075)*x1109);
evalcond[0]=((-0.0111)+(((0.215)*pz*x1117)));
evalcond[1]=((((0.1075)*x1108))+(((-1.0)*r22*x1112)));
evalcond[2]=((((0.1075)*x1117))+(((-1.0)*x1112)));
evalcond[3]=(x1116+((x1113*x1118))+(((-1.0)*x1111*x1118)));
evalcond[4]=(((x1110*x1118))+(((-1.0)*x1114))+(((-1.0)*x1115*x1118)));
evalcond[5]=((((-1.0)*x1114*x1115))+((x1111*x1116))+((x1110*x1114))+(((-1.0)*x1113*x1116))+(((-1.0)*x1118)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1119=((31.0)*cj0);
IkReal x1120=(pz*r22);
IkReal x1121=(r02*sj0);
CheckValue<IkReal> x1122=IKPowWithIntegerCheck(((((-43.0)*cj5*r10))+(((43.0)*r11*sj5))),-1);
if(!x1122.valid){
continue;
}
if( IKabs(((x1122.value)*((x1119+(((-400.0)*r12*x1120))+(((-1.0)*x1119*(r12*r12)))+(((31.0)*r12*x1121)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((9.30232558139535)*x1120))+(((-0.720930232558139)*x1121))+(((0.720930232558139)*cj0*r12)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1122.value)*((x1119+(((-400.0)*r12*x1120))+(((-1.0)*x1119*(r12*r12)))+(((31.0)*r12*x1121))))))+IKsqr(((((9.30232558139535)*x1120))+(((-0.720930232558139)*x1121))+(((0.720930232558139)*cj0*r12))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1122.value)*((x1119+(((-400.0)*r12*x1120))+(((-1.0)*x1119*(r12*r12)))+(((31.0)*r12*x1121))))), ((((9.30232558139535)*x1120))+(((-0.720930232558139)*x1121))+(((0.720930232558139)*cj0*r12))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1123=IKcos(j4);
IkReal x1124=IKsin(j4);
IkReal x1125=(r01*sj5);
IkReal x1126=((0.0775)*sj0);
IkReal x1127=(cj5*r00);
IkReal x1128=((0.0775)*cj0);
IkReal x1129=(cj5*r10);
IkReal x1130=(r21*sj5);
IkReal x1131=((0.215)*pz);
IkReal x1132=(r11*sj5);
IkReal x1133=((1.0)*pz);
IkReal x1134=(cj5*r20);
IkReal x1135=((0.1075)*x1124);
IkReal x1136=((0.1075)*x1123);
evalcond[0]=(x1136+(((-1.0)*r12*x1128))+(((-1.0)*r22*x1133))+((r02*x1126)));
evalcond[1]=(((x1130*x1135))+((r22*x1136))+(((-1.0)*x1134*x1135))+(((-1.0)*x1133)));
evalcond[2]=(x1126+(((-1.0)*x1127*x1135))+((x1125*x1135))+((r02*x1136)));
evalcond[3]=((((-1.0)*x1128))+((r12*x1136))+(((-1.0)*x1129*x1135))+((x1132*x1135)));
evalcond[4]=((-0.0111)+((x1124*x1130*x1131))+(((-1.0)*x1124*x1131*x1134))+((r22*x1123*x1131)));
evalcond[5]=(((pz*x1130))+(((-1.0)*x1135))+(((-1.0)*x1128*x1129))+((x1128*x1132))+(((-1.0)*x1125*x1126))+(((-1.0)*x1133*x1134))+((x1126*x1127)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1137=(pz*r22);
IkReal x1138=(cj0*r12);
IkReal x1139=((31.0)*sj0);
CheckValue<IkReal> x1140=IKPowWithIntegerCheck(((((43.0)*r01*sj5))+(((-43.0)*cj5*r00))),-1);
if(!x1140.valid){
continue;
}
if( IKabs(((x1140.value)*(((((-31.0)*r02*x1138))+((x1139*(r02*r02)))+(((-1.0)*x1139))+(((-400.0)*r02*x1137)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-0.720930232558139)*r02*sj0))+(((0.720930232558139)*x1138))+(((9.30232558139535)*x1137)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1140.value)*(((((-31.0)*r02*x1138))+((x1139*(r02*r02)))+(((-1.0)*x1139))+(((-400.0)*r02*x1137))))))+IKsqr(((((-0.720930232558139)*r02*sj0))+(((0.720930232558139)*x1138))+(((9.30232558139535)*x1137))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1140.value)*(((((-31.0)*r02*x1138))+((x1139*(r02*r02)))+(((-1.0)*x1139))+(((-400.0)*r02*x1137))))), ((((-0.720930232558139)*r02*sj0))+(((0.720930232558139)*x1138))+(((9.30232558139535)*x1137))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1141=IKcos(j4);
IkReal x1142=IKsin(j4);
IkReal x1143=(r01*sj5);
IkReal x1144=((0.0775)*sj0);
IkReal x1145=(cj5*r00);
IkReal x1146=((0.0775)*cj0);
IkReal x1147=(cj5*r10);
IkReal x1148=(r21*sj5);
IkReal x1149=((0.215)*pz);
IkReal x1150=(r11*sj5);
IkReal x1151=((1.0)*pz);
IkReal x1152=(cj5*r20);
IkReal x1153=((0.1075)*x1142);
IkReal x1154=((0.1075)*x1141);
evalcond[0]=(x1154+((r02*x1144))+(((-1.0)*r22*x1151))+(((-1.0)*r12*x1146)));
evalcond[1]=(((r22*x1154))+(((-1.0)*x1151))+(((-1.0)*x1152*x1153))+((x1148*x1153)));
evalcond[2]=(x1144+((x1143*x1153))+((r02*x1154))+(((-1.0)*x1145*x1153)));
evalcond[3]=(((r12*x1154))+(((-1.0)*x1146))+(((-1.0)*x1147*x1153))+((x1150*x1153)));
evalcond[4]=((-0.0111)+((r22*x1141*x1149))+((x1142*x1148*x1149))+(((-1.0)*x1142*x1149*x1152)));
evalcond[5]=(((x1146*x1150))+(((-1.0)*x1143*x1144))+(((-1.0)*x1153))+((pz*x1148))+(((-1.0)*x1146*x1147))+((x1144*x1145))+(((-1.0)*x1151*x1152)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1155=((0.0775)*r22);
IkReal x1156=(r02*sj0);
IkReal x1157=(cj0*r12);
CheckValue<IkReal> x1158=IKPowWithIntegerCheck(((((0.1075)*r21*sj5))+(((-0.1075)*cj5*r20))),-1);
if(!x1158.valid){
continue;
}
if( IKabs(((x1158.value)*(((((-1.0)*x1155*x1157))+(((-1.0)*pz*(r22*r22)))+pz+((x1155*x1156)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((0.720930232558139)*x1157))+(((9.30232558139535)*pz*r22))+(((-0.720930232558139)*x1156)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1158.value)*(((((-1.0)*x1155*x1157))+(((-1.0)*pz*(r22*r22)))+pz+((x1155*x1156))))))+IKsqr(((((0.720930232558139)*x1157))+(((9.30232558139535)*pz*r22))+(((-0.720930232558139)*x1156))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1158.value)*(((((-1.0)*x1155*x1157))+(((-1.0)*pz*(r22*r22)))+pz+((x1155*x1156))))), ((((0.720930232558139)*x1157))+(((9.30232558139535)*pz*r22))+(((-0.720930232558139)*x1156))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1159=IKcos(j4);
IkReal x1160=IKsin(j4);
IkReal x1161=(r01*sj5);
IkReal x1162=((0.0775)*sj0);
IkReal x1163=(cj5*r00);
IkReal x1164=((0.0775)*cj0);
IkReal x1165=(cj5*r10);
IkReal x1166=(r21*sj5);
IkReal x1167=((0.215)*pz);
IkReal x1168=(r11*sj5);
IkReal x1169=((1.0)*pz);
IkReal x1170=(cj5*r20);
IkReal x1171=((0.1075)*x1160);
IkReal x1172=((0.1075)*x1159);
evalcond[0]=(x1172+((r02*x1162))+(((-1.0)*r12*x1164))+(((-1.0)*r22*x1169)));
evalcond[1]=(((x1166*x1171))+(((-1.0)*x1170*x1171))+((r22*x1172))+(((-1.0)*x1169)));
evalcond[2]=(((r02*x1172))+x1162+(((-1.0)*x1163*x1171))+((x1161*x1171)));
evalcond[3]=((((-1.0)*x1165*x1171))+((x1168*x1171))+((r12*x1172))+(((-1.0)*x1164)));
evalcond[4]=((-0.0111)+((r22*x1159*x1167))+(((-1.0)*x1160*x1167*x1170))+((x1160*x1166*x1167)));
evalcond[5]=(((x1164*x1168))+((x1162*x1163))+((pz*x1166))+(((-1.0)*x1169*x1170))+(((-1.0)*x1171))+(((-1.0)*x1164*x1165))+(((-1.0)*x1161*x1162)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
IkReal x1173=((0.215)*pz);
IkReal x1174=((((-1.0)*cj5*r20*x1173))+((r21*sj5*x1173)));
CheckValue<IkReal> x1177 = IKatan2WithCheck(IkReal((r22*x1173)),IkReal(x1174),IKFAST_ATAN2_MAGTHRESH);
if(!x1177.valid){
continue;
}
IkReal x1175=((1.0)*(x1177.value));
if((((((0.046225)*(pz*pz)*(r22*r22)))+(x1174*x1174))) < -0.00001)
continue;
CheckValue<IkReal> x1178=IKPowWithIntegerCheck(IKabs(IKsqrt(((((0.046225)*(pz*pz)*(r22*r22)))+(x1174*x1174)))),-1);
if(!x1178.valid){
continue;
}
if( (((0.0111)*(x1178.value))) < -1-IKFAST_SINCOS_THRESH || (((0.0111)*(x1178.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1176=IKasin(((0.0111)*(x1178.value)));
j4array[0]=(x1176+(((-1.0)*x1175)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x1175))+(((-1.0)*x1176)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
IkReal x1179=IKsin(j4);
IkReal x1180=((0.1075)*x1179);
evalcond[0]=((((-1.0)*cj5*r20*x1180))+(((0.1075)*r22*(IKcos(j4))))+(((-1.0)*pz))+((r21*sj5*x1180)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1181=((1.38709677419355)*sj4);
IkReal x1182=((1.38709677419355)*cj4);
if( IKabs((((cj5*r00*x1181))+(((-1.0)*r01*sj5*x1181))+(((-1.0)*r02*x1182)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj5*r10*x1181))+((r11*sj5*x1181))+((r12*x1182)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj5*r00*x1181))+(((-1.0)*r01*sj5*x1181))+(((-1.0)*r02*x1182))))+IKsqr(((((-1.0)*cj5*r10*x1181))+((r11*sj5*x1181))+((r12*x1182))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2((((cj5*r00*x1181))+(((-1.0)*r01*sj5*x1181))+(((-1.0)*r02*x1182))), ((((-1.0)*cj5*r10*x1181))+((r11*sj5*x1181))+((r12*x1182))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1183=IKsin(j0);
IkReal x1184=IKcos(j0);
IkReal x1185=((0.0775)*sj5);
IkReal x1186=((0.0775)*cj5);
IkReal x1187=((1.0)*pz);
IkReal x1188=((0.1075)*sj4);
IkReal x1189=((0.1075)*cj4);
IkReal x1190=(r10*x1184);
IkReal x1191=(r01*x1183);
IkReal x1192=((0.0775)*x1183);
IkReal x1193=(r11*x1184);
IkReal x1194=(r00*x1183);
IkReal x1195=((0.0775)*x1184);
evalcond[0]=(x1189+(((-1.0)*r22*x1187))+((r02*x1192))+(((-1.0)*r12*x1195)));
evalcond[1]=(x1192+((r02*x1189))+(((-1.0)*cj5*r00*x1188))+((r01*sj5*x1188)));
evalcond[2]=((((-1.0)*cj5*r10*x1188))+((r11*sj5*x1188))+(((-1.0)*x1195))+((r12*x1189)));
evalcond[3]=(((x1186*x1191))+(((-1.0)*cj5*r21*x1187))+((x1185*x1194))+(((-1.0)*x1186*x1193))+(((-1.0)*r20*sj5*x1187))+(((-1.0)*x1185*x1190)));
evalcond[4]=(((x1186*x1194))+(((-1.0)*cj5*r20*x1187))+((x1185*x1193))+(((-1.0)*x1186*x1190))+(((-1.0)*x1188))+((pz*r21*sj5))+(((-1.0)*x1185*x1191)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
IkReal x1196=((((0.1075)*r21*sj5))+(((-0.1075)*cj5*r20)));
CheckValue<IkReal> x1199 = IKatan2WithCheck(IkReal(((0.1075)*r22)),IkReal(x1196),IKFAST_ATAN2_MAGTHRESH);
if(!x1199.valid){
continue;
}
IkReal x1197=((1.0)*(x1199.value));
if((((((0.01155625)*(r22*r22)))+(x1196*x1196))) < -0.00001)
continue;
CheckValue<IkReal> x1200=IKPowWithIntegerCheck(IKabs(IKsqrt(((((0.01155625)*(r22*r22)))+(x1196*x1196)))),-1);
if(!x1200.valid){
continue;
}
if( ((pz*(x1200.value))) < -1-IKFAST_SINCOS_THRESH || ((pz*(x1200.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1198=IKasin((pz*(x1200.value)));
j4array[0]=(x1198+(((-1.0)*x1197)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x1197))+(((-1.0)*x1198)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
IkReal x1201=IKsin(j4);
IkReal x1202=((0.215)*pz);
evalcond[0]=((-0.0111)+((r22*x1202*(IKcos(j4))))+((r21*sj5*x1201*x1202))+(((-1.0)*cj5*r20*x1201*x1202)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1203=((1.38709677419355)*sj4);
IkReal x1204=((1.38709677419355)*cj4);
if( IKabs(((((-1.0)*r02*x1204))+((cj5*r00*x1203))+(((-1.0)*r01*sj5*x1203)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r11*sj5*x1203))+((r12*x1204))+(((-1.0)*cj5*r10*x1203)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r02*x1204))+((cj5*r00*x1203))+(((-1.0)*r01*sj5*x1203))))+IKsqr((((r11*sj5*x1203))+((r12*x1204))+(((-1.0)*cj5*r10*x1203))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(((((-1.0)*r02*x1204))+((cj5*r00*x1203))+(((-1.0)*r01*sj5*x1203))), (((r11*sj5*x1203))+((r12*x1204))+(((-1.0)*cj5*r10*x1203))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1205=IKsin(j0);
IkReal x1206=IKcos(j0);
IkReal x1207=((0.0775)*sj5);
IkReal x1208=((0.0775)*cj5);
IkReal x1209=((1.0)*pz);
IkReal x1210=((0.1075)*sj4);
IkReal x1211=((0.1075)*cj4);
IkReal x1212=(r10*x1206);
IkReal x1213=(r01*x1205);
IkReal x1214=((0.0775)*x1205);
IkReal x1215=(r11*x1206);
IkReal x1216=(r00*x1205);
IkReal x1217=((0.0775)*x1206);
evalcond[0]=(x1211+((r02*x1214))+(((-1.0)*r22*x1209))+(((-1.0)*r12*x1217)));
evalcond[1]=(x1214+((r02*x1211))+(((-1.0)*cj5*r00*x1210))+((r01*sj5*x1210)));
evalcond[2]=(((r12*x1211))+(((-1.0)*cj5*r10*x1210))+(((-1.0)*x1217))+((r11*sj5*x1210)));
evalcond[3]=((((-1.0)*x1207*x1212))+(((-1.0)*cj5*r21*x1209))+(((-1.0)*x1208*x1215))+((x1207*x1216))+(((-1.0)*r20*sj5*x1209))+((x1208*x1213)));
evalcond[4]=((((-1.0)*cj5*r20*x1209))+(((-1.0)*x1207*x1213))+(((-1.0)*x1208*x1212))+((x1207*x1215))+((pz*r21*sj5))+(((-1.0)*x1210))+((x1208*x1216)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
IkReal x1218=((0.1075)*r22);
IkReal x1219=((1.0)*pz);
IkReal x1220=(pz*r22);
IkReal x1221=((0.215)*x1220);
IkReal x1222=((-0.0111)+(((-1.0)*x1221)));
IkReal x1223=(x1218+(((-1.0)*x1219)));
IkReal x1224=((-1.0)*pz);
IkReal x1225=((-0.0111)+x1221);
IkReal x1226=((((-1.0)*x1219))+(((-1.0)*x1218)));
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=x1220;
rxp0_0=(pz*r10);
rxp0_1=(r00*x1224);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1224);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1224);
rxp2_2=0;
IkReal gconst32=x1225;
IkReal gconst33=x1222;
IkReal gconst34=x1223;
IkReal gconst35=x1226;
IkReal gconst36=x1225;
IkReal gconst37=x1222;
IkReal gconst38=x1223;
IkReal gconst39=x1226;
IkReal gconst40=x1225;
IkReal gconst41=x1222;
IkReal gconst42=x1223;
IkReal gconst43=x1226;
IkReal gconst44=x1225;
IkReal gconst45=x1222;
IkReal gconst46=x1223;
IkReal gconst47=x1226;
IkReal x1227=pz*pz;
IkReal x1228=r21*r21;
IkReal x1229=r22*r22;
IkReal x1230=pz*pz*pz*pz;
IkReal x1231=r20*r20;
IkReal x1232=(r20*r21);
IkReal x1233=((0.7396)*x1230);
IkReal x1234=((0.00820956)*x1227);
IkReal x1235=(x1227*x1229);
IkReal x1236=(x1230*x1231);
IkReal x1237=(x1227*x1231);
IkReal x1238=(x1229*x1230);
IkReal x1239=(x1232*x1234);
IkReal x1240=((((2.2781529e-5)*x1232))+((x1232*x1233)));
j5eval[0]=((((0.5)*(IKabs(((((0.00205239)*x1237))+(((0.00205239)*x1235))+(((-0.1849)*x1238))+(((-0.1849)*x1236))+(((-5.69538225e-6)*x1229))+(((-5.69538225e-6)*x1231)))))))+(IKabs((x1240+(((-1.0)*x1239)))))+(IKabs(((((-1.0)*x1228*x1233))+(((-2.2781529e-5)*x1229))+(((-2.2781529e-5)*x1228))+(((-1.0)*x1229*x1233))+((x1228*x1234))+((x1229*x1234)))))+(((0.5)*(IKabs(((((-0.00410478)*x1237))+(((-4.5563058e-5)*x1228))+(((0.3698)*x1236))+(((0.01641912)*x1227*x1228))+(((1.13907645e-5)*x1231))+(((-1.1094)*x1238))+(((0.01231434)*x1235))+(((-1.4792)*x1228*x1230))+(((-3.41722935e-5)*x1229)))))))+(IKabs((x1239+(((-1.0)*x1240))))));
if( IKabs(j5eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j0, j4, j5]

} else
{
IkReal op[8+1], zeror[8];
int numroots;
IkReal x1241=r20*r20;
IkReal x1242=pz*pz;
IkReal x1243=r21*r21;
IkReal x1244=(gconst32*gconst36);
IkReal x1245=(gconst33*gconst38);
IkReal x1246=(r20*r21);
IkReal x1247=(gconst35*gconst40);
IkReal x1248=(gconst45*gconst46);
IkReal x1249=(gconst40*gconst44);
IkReal x1250=(gconst37*gconst38);
IkReal x1251=(gconst32*gconst43);
IkReal x1252=((1.0)*gconst42);
IkReal x1253=(gconst38*gconst41);
IkReal x1254=(gconst37*gconst46);
IkReal x1255=(gconst44*pz);
IkReal x1256=(gconst33*gconst34);
IkReal x1257=(gconst36*gconst39);
IkReal x1258=(gconst36*gconst41);
IkReal x1259=((1.0)*gconst34);
IkReal x1260=(gconst32*gconst44);
IkReal x1261=(gconst36*pz);
IkReal x1262=(gconst33*gconst44);
IkReal x1263=(gconst40*gconst43);
IkReal x1264=(gconst41*gconst44);
IkReal x1265=(gconst34*gconst47);
IkReal x1266=(gconst33*gconst36);
IkReal x1267=(gconst32*gconst35);
IkReal x1268=((1.0)*gconst47);
IkReal x1269=(gconst39*gconst44);
IkReal x1270=(gconst38*gconst45);
IkReal x1271=(gconst42*gconst47);
IkReal x1272=(gconst33*gconst46*pz);
IkReal x1273=((0.3698)*x1243);
IkReal x1274=((0.7396)*x1243);
IkReal x1275=((0.1849)*x1241);
IkReal x1276=(gconst33*x1271);
IkReal x1277=((1.0)*gconst39*gconst43);
IkReal x1278=(gconst39*x1264);
IkReal x1279=(gconst36*x1268);
IkReal x1280=((0.1849)*x1243);
IkReal x1281=((0.3698)*x1241);
IkReal x1282=((1.0)*gconst35*gconst39);
IkReal x1283=((0.09245)*x1241);
IkReal x1284=((0.046225)*x1241);
IkReal x1285=(gconst41*gconst46*pz);
IkReal x1286=(gconst35*gconst38*x1242);
IkReal x1287=(gconst43*gconst46*x1242);
IkReal x1288=(gconst35*x1283);
IkReal x1289=(gconst35*gconst46*x1242);
IkReal x1290=(gconst38*gconst43*x1242);
IkReal x1291=(x1264*x1284);
IkReal x1292=((0.00820956)*x1242*x1246);
IkReal x1293=(x1262*x1284);
IkReal x1294=(x1258*x1284);
IkReal x1295=(x1266*x1284);
IkReal x1296=(gconst43*x1255*x1283);
IkReal x1297=(x1283*x1285);
IkReal x1298=(gconst43*x1261*x1283);
IkReal x1299=(pz*x1253*x1283);
IkReal x1300=(x1272*x1283);
IkReal x1301=(x1255*x1288);
IkReal x1302=(x1261*x1288);
IkReal x1303=(pz*x1245*x1283);
IkReal x1304=(x1275*x1287);
IkReal x1305=(x1275*x1289);
IkReal x1306=(x1275*x1290);
IkReal x1307=(x1275*x1286);
IkReal x1308=((((0.7396)*x1246*(x1242*x1242)))+(((2.2781529e-5)*x1246)));
IkReal x1309=(x1292+(((-1.0)*x1308)));
IkReal x1310=(x1308+(((-1.0)*x1292)));
IkReal x1311=(x1307+x1295);
IkReal x1312=(x1304+x1291);
IkReal x1313=(x1302+x1303);
IkReal x1314=(x1296+x1297);
IkReal x1315=(x1305+x1306+x1293+x1294);
IkReal x1316=(x1300+x1301+x1298+x1299);
op[0]=(x1314+((x1264*x1271))+(((-1.0)*x1312))+(((-1.0)*gconst43*x1249*x1268))+(((-1.0)*gconst41*x1248*x1252))+((x1248*x1263)));
op[1]=x1309;
op[2]=(x1316+(((-1.0)*gconst45*x1252*x1253))+(((-1.0)*gconst44*x1247*x1268))+(((-1.0)*x1249*x1277))+(((-1.0)*gconst43*x1255*x1275))+(((-1.0)*x1264*x1280))+((gconst43*x1255*x1273))+(((-1.0)*x1275*x1285))+((x1264*x1265))+((gconst42*x1278))+(((-1.0)*x1315))+((x1258*x1271))+(((-1.0)*x1263*x1279))+((x1247*x1248))+((x1254*x1263))+((x1263*x1270))+(((-1.0)*gconst33*x1248*x1252))+(((-1.0)*x1274*x1287))+((x1262*x1271))+(((-1.0)*gconst41*x1252*x1254))+((x1264*x1283))+(((-1.0)*gconst44*x1251*x1268))+((x1273*x1285))+((x1281*x1287))+((x1248*x1251))+(((-1.0)*gconst41*x1248*x1259)));
op[3]=x1309;
op[4]=(((gconst43*x1261*x1273))+x1314+x1313+((x1247*x1254))+((gconst35*x1255*x1273))+(((-1.0)*gconst33*x1252*x1254))+(((-1.0)*x1274*x1290))+((x1247*x1270))+((gconst44*gconst47*x1256))+((gconst39*gconst42*x1262))+(((-1.0)*x1247*x1269))+((x1262*x1283))+(((-1.0)*gconst35*x1260*x1268))+((x1258*x1265))+((x1272*x1273))+(((-1.0)*gconst43*x1244*x1268))+(((-1.0)*x1311))+(((-1.0)*x1312))+(((-1.0)*x1251*x1269))+((x1281*x1290))+(((-1.0)*x1272*x1275))+(((-1.0)*gconst41*x1250*x1252))+((x1266*x1271))+(((-1.0)*gconst35*x1255*x1275))+(((-1.0)*x1257*x1263))+((x1250*x1263))+((x1258*x1283))+(((-1.0)*gconst43*x1261*x1275))+(((-1.0)*x1248*x1256))+(((-1.0)*x1247*x1279))+(((-1.0)*pz*x1253*x1275))+(((-1.0)*x1274*x1289))+(((-1.0)*gconst45*x1245*x1252))+(((-1.0)*x1262*x1280))+((x1251*x1254))+(((-1.0)*gconst45*x1253*x1259))+(((-1.0)*gconst41*x1254*x1259))+(((-1.0)*x1258*x1280))+((gconst41*gconst42*x1257))+((gconst34*x1278))+((x1281*x1289))+((x1251*x1270))+((pz*x1253*x1273))+((x1248*x1267)));
op[5]=x1310;
op[6]=(((pz*x1245*x1273))+x1316+((x1247*x1250))+(((-1.0)*x1260*x1282))+((gconst36*gconst47*x1256))+(((-1.0)*x1247*x1257))+(((-1.0)*x1266*x1280))+(((-1.0)*gconst35*x1244*x1268))+(((-1.0)*gconst35*x1261*x1275))+(((-1.0)*x1315))+((gconst34*gconst41*x1257))+(((-1.0)*x1244*x1277))+((x1256*x1269))+(((-1.0)*gconst41*x1250*x1259))+((x1267*x1270))+((x1250*x1251))+((x1254*x1267))+(((-1.0)*x1254*x1256))+(((-1.0)*pz*x1245*x1275))+((gconst33*gconst42*x1257))+((gconst35*x1261*x1273))+(((-1.0)*x1274*x1286))+(((-1.0)*gconst45*x1245*x1259))+((x1266*x1283))+((x1281*x1286))+(((-1.0)*gconst37*x1245*x1252)));
op[7]=x1310;
op[8]=(x1313+(((-1.0)*x1244*x1282))+(((-1.0)*x1311))+((x1256*x1257))+((x1250*x1267))+(((-1.0)*gconst37*x1245*x1259)));
polyroots8(op,zeror,numroots);
IkReal j5array[8], cj5array[8], sj5array[8], tempj5array[1];
int numsolutions = 0;
for(int ij5 = 0; ij5 < numroots; ++ij5)
{
IkReal htj5 = zeror[ij5];
tempj5array[0]=((2.0)*(atan(htj5)));
for(int kj5 = 0; kj5 < 1; ++kj5)
{
j5array[numsolutions] = tempj5array[kj5];
if( j5array[numsolutions] > IKPI )
{
    j5array[numsolutions]-=IK2PI;
}
else if( j5array[numsolutions] < -IKPI )
{
    j5array[numsolutions]+=IK2PI;
}
sj5array[numsolutions] = IKsin(j5array[numsolutions]);
cj5array[numsolutions] = IKcos(j5array[numsolutions]);
numsolutions++;
}
}
bool j5valid[8]={true,true,true,true,true,true,true,true};
_nj5 = 8;
for(int ij5 = 0; ij5 < numsolutions; ++ij5)
    {
if( !j5valid[ij5] )
{
    continue;
}
    j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
htj5 = IKtan(j5/2);

_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < numsolutions; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
{
IkReal j4eval[2];
IkReal x1317=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1317);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1317);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1317);
rxp2_2=0;
IkReal x1318=(cj5*r20);
IkReal x1319=(r21*sj5);
j4eval[0]=((r22*r22)+(x1318*x1318)+(x1319*x1319)+(((-2.0)*x1318*x1319)));
j4eval[1]=((((9.30232558139535)*(IKabs(((((-0.1075)*x1318))+(((0.1075)*x1319)))))))+(IKabs(r22)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
IkReal x1320=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1320);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1320);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1320);
rxp2_2=0;
IkReal x1321=pz*pz;
IkReal x1322=(cj5*r20);
IkReal x1323=(r21*sj5);
j4eval[0]=((IKabs((pz*r22)))+(IKabs((((pz*x1323))+(((-1.0)*pz*x1322))))));
j4eval[1]=((((-2.0)*x1321*x1322*x1323))+((x1321*(r22*r22)))+((x1321*(x1323*x1323)))+((x1321*(x1322*x1322))));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
IkReal x1324=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1324);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1324);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1324);
rxp2_2=0;
IkReal x1325=cj5*cj5;
IkReal x1326=sj5*sj5;
IkReal x1327=((0.0775)*cj5);
IkReal x1328=((0.0775)*sj5);
IkReal x1329=((2.0)*cj5*sj5);
j0eval[0]=(((r00*r01*x1329))+((r10*r11*x1329))+((x1326*(r00*r00)))+((x1326*(r10*r10)))+((x1325*(r01*r01)))+((x1325*(r11*r11))));
j0eval[1]=((IKabs(((((-1.0)*r11*x1327))+(((-1.0)*r10*x1328)))))+(IKabs((((r01*x1327))+((r00*x1328))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(pz);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j4eval[0]=((IKabs(r22))+(((9.30232558139535)*(IKabs(((((0.1075)*r21*sj5))+(((-0.1075)*cj5*r20))))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
IkReal x1330=((0.0775)*cj5);
IkReal x1331=((0.0775)*sj5);
j0eval[0]=((IKabs(((((-1.0)*r10*x1331))+(((-1.0)*r11*x1330)))))+(IKabs((((r00*x1331))+((r01*x1330))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0, j4]

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x1332=((0.0775)*cj5);
IkReal x1333=((0.0775)*sj5);
CheckValue<IkReal> x1335 = IKatan2WithCheck(IkReal(((((-1.0)*r10*x1333))+(((-1.0)*r11*x1332)))),IkReal((((r00*x1333))+((r01*x1332)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1335.valid){
continue;
}
IkReal x1334=x1335.value;
j0array[0]=((-1.0)*x1334);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1334)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal j4eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j4eval[0]=(((r21*sj5))+(((-1.0)*cj5*r20)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j4eval[0]=(((r01*sj5))+(((-1.0)*cj5*r00)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j4eval[0]=((((-1.0)*cj5*r10))+((r11*sj5)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r10))+(IKabs(r11)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
cj4array[0]=((0.720930232558139)*cj0*r12);
if( cj4array[0] >= -1-IKFAST_SINCOS_THRESH && cj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKacos(cj4array[0]);
    sj4array[0] = IKsin(j4array[0]);
    cj4array[1] = cj4array[0];
    j4array[1] = -j4array[0];
    sj4array[1] = -sj4array[0];
}
else if( isnan(cj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x1336=IKsin(j4);
IkReal x1337=((0.1075)*x1336);
evalcond[0]=((-0.1075)*x1336);
evalcond[1]=((((0.1075)*r12*(IKcos(j4))))+(((-0.0775)*cj0)));
evalcond[2]=(((r21*sj5*x1337))+(((-1.0)*cj5*r20*x1337)));
evalcond[3]=((((-1.0)*cj5*r00*x1337))+((r01*sj5*x1337)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r21))+(IKabs(r20)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
IkReal x1338=((0.720930232558139)*cj5);
IkReal x1339=((0.720930232558139)*sj5);
sj4array[0]=(((r00*sj0*x1338))+((cj0*r11*x1339))+(((-1.0)*r01*sj0*x1339))+(((-1.0)*cj0*r10*x1338)));
if( sj4array[0] >= -1-IKFAST_SINCOS_THRESH && sj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKasin(sj4array[0]);
    cj4array[0] = IKcos(j4array[0]);
    sj4array[1] = sj4array[0];
    j4array[1] = j4array[0] > 0 ? (IKPI-j4array[0]) : (-IKPI-j4array[0]);
    cj4array[1] = -cj4array[0];
}
else if( isnan(sj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x1340=IKcos(j4);
IkReal x1341=IKsin(j4);
IkReal x1342=((0.1075)*x1340);
IkReal x1343=((0.1075)*x1341);
evalcond[0]=x1342;
evalcond[1]=(r22*x1342);
evalcond[2]=(((r01*sj5*x1343))+(((0.0775)*sj0))+(((-1.0)*cj5*r00*x1343)));
evalcond[3]=(((r11*sj5*x1343))+(((-1.0)*cj5*r10*x1343))+(((-0.0775)*cj0)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1344=((31.0)*cj0);
IkReal x1345=(r02*sj0);
CheckValue<IkReal> x1346=IKPowWithIntegerCheck(((((-43.0)*cj5*r10))+(((43.0)*r11*sj5))),-1);
if(!x1346.valid){
continue;
}
if( IKabs(((x1346.value)*((x1344+(((-1.0)*x1344*(r12*r12)))+(((31.0)*r12*x1345)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-0.720930232558139)*x1345))+(((0.720930232558139)*cj0*r12)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1346.value)*((x1344+(((-1.0)*x1344*(r12*r12)))+(((31.0)*r12*x1345))))))+IKsqr(((((-0.720930232558139)*x1345))+(((0.720930232558139)*cj0*r12))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1346.value)*((x1344+(((-1.0)*x1344*(r12*r12)))+(((31.0)*r12*x1345))))), ((((-0.720930232558139)*x1345))+(((0.720930232558139)*cj0*r12))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x1347=IKcos(j4);
IkReal x1348=IKsin(j4);
IkReal x1349=(cj5*r00);
IkReal x1350=(r11*sj5);
IkReal x1351=(r01*sj5);
IkReal x1352=((0.0775)*cj0);
IkReal x1353=(cj5*r10);
IkReal x1354=((0.0775)*sj0);
IkReal x1355=((0.1075)*x1347);
IkReal x1356=((0.1075)*x1348);
evalcond[0]=(x1355+(((-1.0)*r12*x1352))+((r02*x1354)));
evalcond[1]=(((r22*x1355))+((r21*sj5*x1356))+(((-1.0)*cj5*r20*x1356)));
evalcond[2]=(x1354+((r02*x1355))+((x1351*x1356))+(((-1.0)*x1349*x1356)));
evalcond[3]=((((-1.0)*x1352))+((x1350*x1356))+((r12*x1355))+(((-1.0)*x1353*x1356)));
evalcond[4]=((((-1.0)*x1356))+(((-1.0)*x1352*x1353))+((x1349*x1354))+((x1350*x1352))+(((-1.0)*x1351*x1354)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1357=(cj0*r12);
IkReal x1358=((31.0)*sj0);
CheckValue<IkReal> x1359=IKPowWithIntegerCheck(((((43.0)*r01*sj5))+(((-43.0)*cj5*r00))),-1);
if(!x1359.valid){
continue;
}
if( IKabs(((x1359.value)*(((((-1.0)*x1358))+(((-31.0)*r02*x1357))+((x1358*(r02*r02))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((0.720930232558139)*x1357))+(((-0.720930232558139)*r02*sj0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1359.value)*(((((-1.0)*x1358))+(((-31.0)*r02*x1357))+((x1358*(r02*r02)))))))+IKsqr(((((0.720930232558139)*x1357))+(((-0.720930232558139)*r02*sj0))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1359.value)*(((((-1.0)*x1358))+(((-31.0)*r02*x1357))+((x1358*(r02*r02)))))), ((((0.720930232558139)*x1357))+(((-0.720930232558139)*r02*sj0))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x1360=IKcos(j4);
IkReal x1361=IKsin(j4);
IkReal x1362=(cj5*r00);
IkReal x1363=(r11*sj5);
IkReal x1364=(r01*sj5);
IkReal x1365=((0.0775)*cj0);
IkReal x1366=(cj5*r10);
IkReal x1367=((0.0775)*sj0);
IkReal x1368=((0.1075)*x1360);
IkReal x1369=((0.1075)*x1361);
evalcond[0]=(x1368+(((-1.0)*r12*x1365))+((r02*x1367)));
evalcond[1]=(((r22*x1368))+(((-1.0)*cj5*r20*x1369))+((r21*sj5*x1369)));
evalcond[2]=(x1367+((r02*x1368))+(((-1.0)*x1362*x1369))+((x1364*x1369)));
evalcond[3]=((((-1.0)*x1366*x1369))+((x1363*x1369))+((r12*x1368))+(((-1.0)*x1365)));
evalcond[4]=((((-1.0)*x1364*x1367))+((x1363*x1365))+(((-1.0)*x1365*x1366))+((x1362*x1367))+(((-1.0)*x1369)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1370=((0.0775)*r22);
IkReal x1371=(r02*sj0);
IkReal x1372=(cj0*r12);
CheckValue<IkReal> x1373=IKPowWithIntegerCheck(((((0.1075)*r21*sj5))+(((-0.1075)*cj5*r20))),-1);
if(!x1373.valid){
continue;
}
if( IKabs(((x1373.value)*(((((-1.0)*x1370*x1372))+((x1370*x1371)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-0.720930232558139)*x1371))+(((0.720930232558139)*x1372)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1373.value)*(((((-1.0)*x1370*x1372))+((x1370*x1371))))))+IKsqr(((((-0.720930232558139)*x1371))+(((0.720930232558139)*x1372))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1373.value)*(((((-1.0)*x1370*x1372))+((x1370*x1371))))), ((((-0.720930232558139)*x1371))+(((0.720930232558139)*x1372))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x1374=IKcos(j4);
IkReal x1375=IKsin(j4);
IkReal x1376=(cj5*r00);
IkReal x1377=(r11*sj5);
IkReal x1378=(r01*sj5);
IkReal x1379=((0.0775)*cj0);
IkReal x1380=(cj5*r10);
IkReal x1381=((0.0775)*sj0);
IkReal x1382=((0.1075)*x1374);
IkReal x1383=((0.1075)*x1375);
evalcond[0]=(x1382+(((-1.0)*r12*x1379))+((r02*x1381)));
evalcond[1]=((((-1.0)*cj5*r20*x1383))+((r21*sj5*x1383))+((r22*x1382)));
evalcond[2]=(x1381+(((-1.0)*x1376*x1383))+((x1378*x1383))+((r02*x1382)));
evalcond[3]=((((-1.0)*x1379))+(((-1.0)*x1380*x1383))+((x1377*x1383))+((r12*x1382)));
evalcond[4]=((((-1.0)*x1383))+((x1377*x1379))+((x1376*x1381))+(((-1.0)*x1378*x1381))+(((-1.0)*x1379*x1380)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x1385 = IKatan2WithCheck(IkReal(((0.1075)*r22)),IkReal(((((0.1075)*r21*sj5))+(((-0.1075)*cj5*r20)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1385.valid){
continue;
}
IkReal x1384=x1385.value;
j4array[0]=((-1.0)*x1384);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x1384)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

{
IkReal j0eval[3];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
IkReal x1386=(r21*sj5);
IkReal x1387=(cj5*r20);
IkReal x1388=((1.0)*cj4*sj5);
IkReal x1389=((1.0)*cj4*cj5);
j0eval[0]=(x1386+(((-1.0)*x1387)));
j0eval[1]=IKsign(((((2.4025)*x1386))+(((-2.4025)*x1387))));
j0eval[2]=((IKabs(((((-1.0)*r11*x1389))+(((-1.0)*r10*x1388)))))+(IKabs(((((-1.0)*r00*x1388))+(((-1.0)*r01*x1389))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
IkReal x1390=((1333.0)*sj4);
IkReal x1391=(r20*sj5);
IkReal x1392=(cj5*r21);
IkReal x1393=((1333.0)*cj4*sj5);
IkReal x1394=((1333.0)*cj4*cj5);
j0eval[0]=((((-1.0)*x1392))+(((-1.0)*x1391)));
j0eval[1]=((IKabs(((((-1.0)*r01*x1393))+((r00*x1394))+((r02*x1390)))))+(IKabs((((r10*x1394))+((r12*x1390))+(((-1.0)*r11*x1393))))));
j0eval[2]=IKsign(((((-961.0)*x1392))+(((-961.0)*x1391))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j0eval[0]=r12;
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1395=((1.38709677419355)*cj5);
IkReal x1396=((1.38709677419355)*sj5);
if( IKabs(((((-1.0)*r01*x1396))+((r00*x1395)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r10*x1395))+((r11*x1396)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r01*x1396))+((r00*x1395))))+IKsqr(((((-1.0)*r10*x1395))+((r11*x1396))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(((((-1.0)*r01*x1396))+((r00*x1395))), ((((-1.0)*r10*x1395))+((r11*x1396))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1397=IKsin(j0);
IkReal x1398=IKcos(j0);
IkReal x1399=(r01*sj5);
IkReal x1400=(cj5*r10);
IkReal x1401=(cj5*r00);
IkReal x1402=((0.0775)*x1397);
IkReal x1403=((0.0775)*x1398);
IkReal x1404=(sj5*x1403);
evalcond[0]=((((-1.0)*r12*x1403))+((r02*x1402)));
evalcond[1]=((((0.1075)*x1399))+(((-0.1075)*x1401))+x1402);
evalcond[2]=((((-0.1075)*x1400))+(((-1.0)*x1403))+(((0.1075)*r11*sj5)));
evalcond[3]=(((r00*sj5*x1402))+((cj5*r01*x1402))+(((-1.0)*r10*x1404))+(((-1.0)*cj5*r11*x1403)));
evalcond[4]=((-0.1075)+(((-1.0)*x1399*x1402))+((r11*x1404))+(((-1.0)*x1400*x1403))+((x1401*x1402)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1405=((1.38709677419355)*cj5);
IkReal x1406=((1.38709677419355)*sj5);
if( IKabs(((((-1.0)*r00*x1405))+((r01*x1406)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r11*x1406))+((r10*x1405)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r00*x1405))+((r01*x1406))))+IKsqr(((((-1.0)*r11*x1406))+((r10*x1405))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(((((-1.0)*r00*x1405))+((r01*x1406))), ((((-1.0)*r11*x1406))+((r10*x1405))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1407=IKsin(j0);
IkReal x1408=IKcos(j0);
IkReal x1409=(r01*sj5);
IkReal x1410=(cj5*r10);
IkReal x1411=(cj5*r00);
IkReal x1412=((0.0775)*x1407);
IkReal x1413=((0.0775)*x1408);
IkReal x1414=(sj5*x1413);
evalcond[0]=((((-1.0)*r12*x1413))+((r02*x1412)));
evalcond[1]=((((-0.1075)*x1409))+x1412+(((0.1075)*x1411)));
evalcond[2]=((((-1.0)*x1413))+(((-0.1075)*r11*sj5))+(((0.1075)*x1410)));
evalcond[3]=((((-1.0)*cj5*r11*x1413))+((cj5*r01*x1412))+(((-1.0)*r10*x1414))+((r00*sj5*x1412)));
evalcond[4]=((0.1075)+((r11*x1414))+((x1411*x1412))+(((-1.0)*x1410*x1413))+(((-1.0)*x1409*x1412)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r21))+(IKabs(r20)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1415=((1.38709677419355)*cj5*sj4);
IkReal x1416=((1.38709677419355)*sj4*sj5);
if( IKabs((((r00*x1415))+(((-1.0)*r01*x1416)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r10*x1415))+((r11*x1416)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r00*x1415))+(((-1.0)*r01*x1416))))+IKsqr(((((-1.0)*r10*x1415))+((r11*x1416))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2((((r00*x1415))+(((-1.0)*r01*x1416))), ((((-1.0)*r10*x1415))+((r11*x1416))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[4];
IkReal x1417=IKsin(j0);
IkReal x1418=IKcos(j0);
IkReal x1419=((0.1075)*sj4);
IkReal x1420=(r01*sj5);
IkReal x1421=(cj5*r00);
IkReal x1422=(cj5*r10);
IkReal x1423=((0.0775)*x1417);
IkReal x1424=((0.0775)*x1418);
IkReal x1425=(r11*x1424);
evalcond[0]=((((-1.0)*x1419*x1421))+((x1419*x1420))+x1423);
evalcond[1]=(((r11*sj5*x1419))+(((-1.0)*x1419*x1422))+(((-1.0)*x1424)));
evalcond[2]=((((-1.0)*cj5*x1425))+((r00*sj5*x1423))+(((-1.0)*r10*sj5*x1424))+((cj5*r01*x1423)));
evalcond[3]=((((-1.0)*x1419))+(((-1.0)*x1420*x1423))+(((-1.0)*x1422*x1424))+((sj5*x1425))+((x1421*x1423)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1426=((1.38709677419355)*sj4);
IkReal x1427=(cj5*r00);
IkReal x1428=(r01*sj5);
IkReal x1429=((43.0)*cj4);
IkReal x1430=((43.0)*r02*sj4);
CheckValue<IkReal> x1431=IKPowWithIntegerCheck(r12,-1);
if(!x1431.valid){
continue;
}
if( IKabs(((((-1.0)*x1426*x1428))+((x1426*x1427))+(((-1.38709677419355)*cj4*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.032258064516129)*(x1431.value)*(((((-1.0)*x1429*(r02*r02)))+(((-1.0)*x1428*x1430))+((x1427*x1430))+x1429)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x1426*x1428))+((x1426*x1427))+(((-1.38709677419355)*cj4*r02))))+IKsqr(((0.032258064516129)*(x1431.value)*(((((-1.0)*x1429*(r02*r02)))+(((-1.0)*x1428*x1430))+((x1427*x1430))+x1429))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(((((-1.0)*x1426*x1428))+((x1426*x1427))+(((-1.38709677419355)*cj4*r02))), ((0.032258064516129)*(x1431.value)*(((((-1.0)*x1429*(r02*r02)))+(((-1.0)*x1428*x1430))+((x1427*x1430))+x1429))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1432=IKsin(j0);
IkReal x1433=IKcos(j0);
IkReal x1434=((0.1075)*cj4);
IkReal x1435=(r11*sj5);
IkReal x1436=(r01*sj5);
IkReal x1437=((0.1075)*sj4);
IkReal x1438=((0.0775)*x1433);
IkReal x1439=(cj5*x1437);
IkReal x1440=((0.0775)*x1432);
evalcond[0]=((((-1.0)*r12*x1438))+((r02*x1440))+x1434);
evalcond[1]=(((r02*x1434))+((x1436*x1437))+(((-1.0)*r00*x1439))+x1440);
evalcond[2]=(((r12*x1434))+((x1435*x1437))+(((-1.0)*x1438))+(((-1.0)*r10*x1439)));
evalcond[3]=(((r00*sj5*x1440))+(((-1.0)*r10*sj5*x1438))+((cj5*r01*x1440))+(((-1.0)*cj5*r11*x1438)));
evalcond[4]=(((x1435*x1438))+(((-1.0)*x1437))+(((-1.0)*cj5*r10*x1438))+((cj5*r00*x1440))+(((-1.0)*x1436*x1440)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1441=((1333.0)*sj4);
IkReal x1442=((1333.0)*cj4*sj5);
IkReal x1443=((1333.0)*cj4*cj5);
CheckValue<IkReal> x1444 = IKatan2WithCheck(IkReal((((r12*x1441))+((r10*x1443))+(((-1.0)*r11*x1442)))),IkReal(((((-1.0)*r01*x1442))+((r02*x1441))+((r00*x1443)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1444.valid){
continue;
}
CheckValue<IkReal> x1445=IKPowWithIntegerCheck(IKsign(((((-961.0)*cj5*r21))+(((-961.0)*r20*sj5)))),-1);
if(!x1445.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x1444.value)+(((1.5707963267949)*(x1445.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1446=IKsin(j0);
IkReal x1447=IKcos(j0);
IkReal x1448=((0.1075)*cj4);
IkReal x1449=(r11*sj5);
IkReal x1450=(r01*sj5);
IkReal x1451=((0.1075)*sj4);
IkReal x1452=((0.0775)*x1447);
IkReal x1453=(cj5*x1451);
IkReal x1454=((0.0775)*x1446);
evalcond[0]=(x1448+((r02*x1454))+(((-1.0)*r12*x1452)));
evalcond[1]=(((x1450*x1451))+((r02*x1448))+(((-1.0)*r00*x1453))+x1454);
evalcond[2]=(((r12*x1448))+(((-1.0)*x1452))+(((-1.0)*r10*x1453))+((x1449*x1451)));
evalcond[3]=(((cj5*r01*x1454))+((r00*sj5*x1454))+(((-1.0)*r10*sj5*x1452))+(((-1.0)*cj5*r11*x1452)));
evalcond[4]=((((-1.0)*x1451))+((cj5*r00*x1454))+(((-1.0)*cj5*r10*x1452))+((x1449*x1452))+(((-1.0)*x1450*x1454)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1455=((3.3325)*cj4*cj5);
IkReal x1456=((3.3325)*cj4*sj5);
CheckValue<IkReal> x1457=IKPowWithIntegerCheck(IKsign(((((-2.4025)*cj5*r20))+(((2.4025)*r21*sj5)))),-1);
if(!x1457.valid){
continue;
}
CheckValue<IkReal> x1458 = IKatan2WithCheck(IkReal(((((-1.0)*r10*x1456))+(((-1.0)*r11*x1455)))),IkReal(((((-1.0)*r01*x1455))+(((-1.0)*r00*x1456)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1458.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1457.value)))+(x1458.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1459=IKsin(j0);
IkReal x1460=IKcos(j0);
IkReal x1461=((0.1075)*cj4);
IkReal x1462=(r11*sj5);
IkReal x1463=(r01*sj5);
IkReal x1464=((0.1075)*sj4);
IkReal x1465=((0.0775)*x1460);
IkReal x1466=(cj5*x1464);
IkReal x1467=((0.0775)*x1459);
evalcond[0]=(x1461+((r02*x1467))+(((-1.0)*r12*x1465)));
evalcond[1]=(((x1463*x1464))+(((-1.0)*r00*x1466))+x1467+((r02*x1461)));
evalcond[2]=((((-1.0)*x1465))+((r12*x1461))+((x1462*x1464))+(((-1.0)*r10*x1466)));
evalcond[3]=(((cj5*r01*x1467))+(((-1.0)*cj5*r11*x1465))+((r00*sj5*x1467))+(((-1.0)*r10*sj5*x1465)));
evalcond[4]=(((cj5*r00*x1467))+(((-1.0)*x1464))+(((-1.0)*x1463*x1467))+(((-1.0)*cj5*r10*x1465))+((x1462*x1465)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x1468=((0.0775)*cj5);
IkReal x1469=((1.0)*pz);
IkReal x1470=((0.0775)*sj5);
IkReal x1471=((((-1.0)*r10*x1470))+(((-1.0)*r11*x1468)));
IkReal x1472=(((r01*x1468))+((r00*x1470)));
CheckValue<IkReal> x1475 = IKatan2WithCheck(IkReal(x1471),IkReal(x1472),IKFAST_ATAN2_MAGTHRESH);
if(!x1475.valid){
continue;
}
IkReal x1473=((1.0)*(x1475.value));
if((((x1471*x1471)+(x1472*x1472))) < -0.00001)
continue;
CheckValue<IkReal> x1476=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1471*x1471)+(x1472*x1472)))),-1);
if(!x1476.valid){
continue;
}
if( (((-1.0)*(x1476.value)*(((((-1.0)*cj5*r21*x1469))+(((-1.0)*r20*sj5*x1469)))))) < -1-IKFAST_SINCOS_THRESH || (((-1.0)*(x1476.value)*(((((-1.0)*cj5*r21*x1469))+(((-1.0)*r20*sj5*x1469)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1474=((-1.0)*(IKasin(((-1.0)*(x1476.value)*(((((-1.0)*cj5*r21*x1469))+(((-1.0)*r20*sj5*x1469))))))));
j0array[0]=((((-1.0)*x1473))+(((-1.0)*x1474)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((1.0)*x1474))+(((-1.0)*x1473)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal j4eval[1];
IkReal x1477=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1477);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1477);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1477);
rxp2_2=0;
j4eval[0]=(((r21*sj5))+(((-1.0)*cj5*r20)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
IkReal x1478=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1478);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1478);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1478);
rxp2_2=0;
j4eval[0]=(((r01*sj5))+(((-1.0)*cj5*r00)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
IkReal x1479=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1479);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1479);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1479);
rxp2_2=0;
j4eval[0]=((((-1.0)*cj5*r10))+((r11*sj5)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x1481 = ((1.0)+(((-1.0)*(r12*r12))));
if(IKabs(x1481)==0){
continue;
}
IkReal x1480=pow(x1481,-0.5);
CheckValue<IkReal> x1482 = IKatan2WithCheck(IkReal(((-1.0)*r10)),IkReal(r11),IKFAST_ATAN2_MAGTHRESH);
if(!x1482.valid){
continue;
}
IkReal gconst64=((-1.0)*(x1482.value));
IkReal gconst65=(r10*x1480);
IkReal gconst66=(r11*x1480);
CheckValue<IkReal> x1483 = IKatan2WithCheck(IkReal(((-1.0)*r10)),IkReal(r11),IKFAST_ATAN2_MAGTHRESH);
if(!x1483.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x1483.value)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1484=((0.0775)*r22);
IkReal x1485=(r02*sj0);
IkReal x1486=(cj0*r12);
CheckValue<IkReal> x1487=IKPowWithIntegerCheck(((((0.1075)*gconst65*r21))+(((-0.1075)*gconst66*r20))),-1);
if(!x1487.valid){
continue;
}
if( IKabs(((x1487.value)*(((((-1.0)*x1484*x1486))+(((-1.0)*pz*(r22*r22)))+pz+((x1484*x1485)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((0.720930232558139)*x1486))+(((9.30232558139535)*pz*r22))+(((-0.720930232558139)*x1485)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1487.value)*(((((-1.0)*x1484*x1486))+(((-1.0)*pz*(r22*r22)))+pz+((x1484*x1485))))))+IKsqr(((((0.720930232558139)*x1486))+(((9.30232558139535)*pz*r22))+(((-0.720930232558139)*x1485))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1487.value)*(((((-1.0)*x1484*x1486))+(((-1.0)*pz*(r22*r22)))+pz+((x1484*x1485))))), ((((0.720930232558139)*x1486))+(((9.30232558139535)*pz*r22))+(((-0.720930232558139)*x1485))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1488=IKcos(j4);
IkReal x1489=IKsin(j4);
IkReal x1490=((0.0775)*cj0);
IkReal x1491=((0.215)*pz);
IkReal x1492=((1.0)*pz);
IkReal x1493=((0.0775)*sj0);
IkReal x1494=(gconst65*r21);
IkReal x1495=((0.1075)*x1488);
IkReal x1496=(gconst66*x1489);
IkReal x1497=((0.1075)*gconst65*x1489);
evalcond[0]=((((-1.0)*r12*x1490))+x1495+(((-1.0)*r22*x1492))+((r02*x1493)));
evalcond[1]=((((-1.0)*x1492))+(((-0.1075)*r20*x1496))+((r22*x1495))+(((0.1075)*x1489*x1494)));
evalcond[2]=(((r01*x1497))+(((-0.1075)*r00*x1496))+x1493+((r02*x1495)));
evalcond[3]=((((-1.0)*x1490))+((r12*x1495))+((r11*x1497))+(((-0.1075)*r10*x1496)));
evalcond[4]=((-0.0111)+((r22*x1488*x1491))+((x1489*x1491*x1494))+(((-1.0)*r20*x1491*x1496)));
evalcond[5]=(((gconst66*r00*x1493))+(((-1.0)*gconst66*r10*x1490))+((pz*x1494))+(((-1.0)*gconst66*r20*x1492))+(((-1.0)*gconst65*r01*x1493))+((gconst65*r11*x1490))+(((-0.1075)*x1489)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1500 = ((1.0)+(((-1.0)*(r12*r12))));
if(IKabs(x1500)==0){
continue;
}
IkReal x1498=pow(x1500,-0.5);
IkReal x1499=((-1.0)*x1498);
CheckValue<IkReal> x1501 = IKatan2WithCheck(IkReal(((-1.0)*r10)),IkReal(r11),IKFAST_ATAN2_MAGTHRESH);
if(!x1501.valid){
continue;
}
IkReal gconst67=((3.14159265358979)+(((-1.0)*(x1501.value))));
IkReal gconst68=(r10*x1499);
IkReal gconst69=(r11*x1499);
CheckValue<IkReal> x1502 = IKatan2WithCheck(IkReal(((-1.0)*r10)),IkReal(r11),IKFAST_ATAN2_MAGTHRESH);
if(!x1502.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x1502.value)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1503=((0.0775)*r22);
IkReal x1504=(r02*sj0);
IkReal x1505=(cj0*r12);
CheckValue<IkReal> x1506=IKPowWithIntegerCheck(((((-0.1075)*gconst69*r20))+(((0.1075)*gconst68*r21))),-1);
if(!x1506.valid){
continue;
}
if( IKabs(((x1506.value)*(((((-1.0)*pz*(r22*r22)))+pz+((x1503*x1504))+(((-1.0)*x1503*x1505)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-0.720930232558139)*x1504))+(((0.720930232558139)*x1505))+(((9.30232558139535)*pz*r22)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1506.value)*(((((-1.0)*pz*(r22*r22)))+pz+((x1503*x1504))+(((-1.0)*x1503*x1505))))))+IKsqr(((((-0.720930232558139)*x1504))+(((0.720930232558139)*x1505))+(((9.30232558139535)*pz*r22))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1506.value)*(((((-1.0)*pz*(r22*r22)))+pz+((x1503*x1504))+(((-1.0)*x1503*x1505))))), ((((-0.720930232558139)*x1504))+(((0.720930232558139)*x1505))+(((9.30232558139535)*pz*r22))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1507=IKcos(j4);
IkReal x1508=IKsin(j4);
IkReal x1509=((0.0775)*cj0);
IkReal x1510=(gconst69*r10);
IkReal x1511=((0.215)*pz);
IkReal x1512=((1.0)*pz);
IkReal x1513=(gconst69*r20);
IkReal x1514=((0.0775)*sj0);
IkReal x1515=(gconst69*r00);
IkReal x1516=((0.1075)*x1507);
IkReal x1517=(gconst68*x1508);
IkReal x1518=((0.1075)*x1508);
evalcond[0]=((((-1.0)*r22*x1512))+x1516+((r02*x1514))+(((-1.0)*r12*x1509)));
evalcond[1]=((((-1.0)*x1512))+(((-1.0)*x1513*x1518))+((r22*x1516))+(((0.1075)*r21*x1517)));
evalcond[2]=((((-1.0)*x1515*x1518))+(((0.1075)*r01*x1517))+x1514+((r02*x1516)));
evalcond[3]=((((-1.0)*x1509))+((r12*x1516))+(((0.1075)*r11*x1517))+(((-1.0)*x1510*x1518)));
evalcond[4]=((-0.0111)+((r22*x1507*x1511))+((r21*x1511*x1517))+(((-1.0)*x1508*x1511*x1513)));
evalcond[5]=(((x1514*x1515))+(((-1.0)*x1518))+((gconst68*r11*x1509))+(((-1.0)*gconst68*r01*x1514))+(((-1.0)*x1512*x1513))+(((-1.0)*x1509*x1510))+((gconst68*pz*r21)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1520 = ((1.0)+(((-1.0)*(r02*r02))));
if(IKabs(x1520)==0){
continue;
}
IkReal x1519=pow(x1520,-0.5);
CheckValue<IkReal> x1521 = IKatan2WithCheck(IkReal(((-1.0)*r00)),IkReal(r01),IKFAST_ATAN2_MAGTHRESH);
if(!x1521.valid){
continue;
}
IkReal gconst70=((-1.0)*(x1521.value));
IkReal gconst71=(r00*x1519);
IkReal gconst72=(r01*x1519);
CheckValue<IkReal> x1522 = IKatan2WithCheck(IkReal(((-1.0)*r00)),IkReal(r01),IKFAST_ATAN2_MAGTHRESH);
if(!x1522.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x1522.value)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1523=((0.0775)*r22);
IkReal x1524=(cj0*r12);
IkReal x1525=(r02*sj0);
CheckValue<IkReal> x1526=IKPowWithIntegerCheck(((((-0.1075)*gconst72*r20))+(((0.1075)*gconst71*r21))),-1);
if(!x1526.valid){
continue;
}
if( IKabs(((x1526.value)*((((x1523*x1525))+(((-1.0)*pz*(r22*r22)))+pz+(((-1.0)*x1523*x1524)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-0.720930232558139)*x1525))+(((0.720930232558139)*x1524))+(((9.30232558139535)*pz*r22)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1526.value)*((((x1523*x1525))+(((-1.0)*pz*(r22*r22)))+pz+(((-1.0)*x1523*x1524))))))+IKsqr(((((-0.720930232558139)*x1525))+(((0.720930232558139)*x1524))+(((9.30232558139535)*pz*r22))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1526.value)*((((x1523*x1525))+(((-1.0)*pz*(r22*r22)))+pz+(((-1.0)*x1523*x1524))))), ((((-0.720930232558139)*x1525))+(((0.720930232558139)*x1524))+(((9.30232558139535)*pz*r22))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1527=IKcos(j4);
IkReal x1528=IKsin(j4);
IkReal x1529=((0.0775)*cj0);
IkReal x1530=(gconst72*r00);
IkReal x1531=((0.0775)*sj0);
IkReal x1532=(gconst71*r01);
IkReal x1533=((1.0)*pz);
IkReal x1534=(gconst71*r21);
IkReal x1535=((0.215)*pz);
IkReal x1536=(gconst72*r20);
IkReal x1537=(gconst72*r10);
IkReal x1538=(gconst71*r11);
IkReal x1539=((0.1075)*x1528);
IkReal x1540=((0.1075)*x1527);
evalcond[0]=((((-1.0)*r12*x1529))+(((-1.0)*r22*x1533))+x1540+((r02*x1531)));
evalcond[1]=((((-1.0)*x1533))+((r22*x1540))+((x1534*x1539))+(((-1.0)*x1536*x1539)));
evalcond[2]=((((-1.0)*x1530*x1539))+((x1532*x1539))+x1531+((r02*x1540)));
evalcond[3]=(((x1538*x1539))+(((-1.0)*x1537*x1539))+(((-1.0)*x1529))+((r12*x1540)));
evalcond[4]=((-0.0111)+(((-1.0)*x1528*x1535*x1536))+((r22*x1527*x1535))+((x1528*x1534*x1535)));
evalcond[5]=((((-1.0)*x1529*x1537))+(((-1.0)*x1531*x1532))+(((-1.0)*x1539))+((x1530*x1531))+((x1529*x1538))+(((-1.0)*x1533*x1536))+((pz*x1534)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1541=((-1.0)*r00);
IkReal x1543 = ((1.0)+(((-1.0)*(r02*r02))));
if(IKabs(x1543)==0){
continue;
}
IkReal x1542=pow(x1543,-0.5);
CheckValue<IkReal> x1544 = IKatan2WithCheck(IkReal(x1541),IkReal(r01),IKFAST_ATAN2_MAGTHRESH);
if(!x1544.valid){
continue;
}
IkReal gconst73=((3.14159265358979)+(((-1.0)*(x1544.value))));
IkReal gconst74=(x1541*x1542);
IkReal gconst75=((-1.0)*r01*x1542);
CheckValue<IkReal> x1545 = IKatan2WithCheck(IkReal(((-1.0)*r00)),IkReal(r01),IKFAST_ATAN2_MAGTHRESH);
if(!x1545.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x1545.value)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1546=((0.0775)*r22);
IkReal x1547=(r02*sj0);
IkReal x1548=(cj0*r12);
CheckValue<IkReal> x1549=IKPowWithIntegerCheck(((((-0.1075)*gconst75*r20))+(((0.1075)*gconst74*r21))),-1);
if(!x1549.valid){
continue;
}
if( IKabs(((x1549.value)*(((((-1.0)*x1546*x1548))+(((-1.0)*pz*(r22*r22)))+((x1546*x1547))+pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((9.30232558139535)*pz*r22))+(((-0.720930232558139)*x1547))+(((0.720930232558139)*x1548)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1549.value)*(((((-1.0)*x1546*x1548))+(((-1.0)*pz*(r22*r22)))+((x1546*x1547))+pz))))+IKsqr(((((9.30232558139535)*pz*r22))+(((-0.720930232558139)*x1547))+(((0.720930232558139)*x1548))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1549.value)*(((((-1.0)*x1546*x1548))+(((-1.0)*pz*(r22*r22)))+((x1546*x1547))+pz))), ((((9.30232558139535)*pz*r22))+(((-0.720930232558139)*x1547))+(((0.720930232558139)*x1548))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1550=IKcos(j4);
IkReal x1551=IKsin(j4);
IkReal x1552=((0.0775)*cj0);
IkReal x1553=(pz*r20);
IkReal x1554=((1.0)*pz);
IkReal x1555=(gconst74*r11);
IkReal x1556=((0.0775)*sj0);
IkReal x1557=(gconst74*r01);
IkReal x1558=((0.215)*pz);
IkReal x1559=(gconst74*r21);
IkReal x1560=((0.1075)*x1550);
IkReal x1561=(gconst75*x1551);
IkReal x1562=((0.1075)*x1551);
evalcond[0]=((((-1.0)*r22*x1554))+x1560+((r02*x1556))+(((-1.0)*r12*x1552)));
evalcond[1]=((((-0.1075)*r20*x1561))+((r22*x1560))+(((-1.0)*x1554))+((x1559*x1562)));
evalcond[2]=((((-0.1075)*r00*x1561))+x1556+((x1557*x1562))+((r02*x1560)));
evalcond[3]=(((x1555*x1562))+(((-0.1075)*r10*x1561))+((r12*x1560))+(((-1.0)*x1552)));
evalcond[4]=((-0.0111)+((r22*x1550*x1558))+((x1551*x1558*x1559))+(((-0.215)*x1553*x1561)));
evalcond[5]=(((x1552*x1555))+(((-1.0)*gconst75*x1553))+((gconst75*r00*x1556))+((pz*x1559))+(((-1.0)*gconst75*r10*x1552))+(((-1.0)*x1556*x1557))+(((-1.0)*x1562)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1564 = ((1.0)+(((-1.0)*(r22*r22))));
if(IKabs(x1564)==0){
continue;
}
IkReal x1563=pow(x1564,-0.5);
CheckValue<IkReal> x1565 = IKatan2WithCheck(IkReal(((-1.0)*r20)),IkReal(r21),IKFAST_ATAN2_MAGTHRESH);
if(!x1565.valid){
continue;
}
IkReal gconst76=((-1.0)*(x1565.value));
IkReal gconst77=(r20*x1563);
IkReal gconst78=(r21*x1563);
CheckValue<IkReal> x1566 = IKatan2WithCheck(IkReal(((-1.0)*r20)),IkReal(r21),IKFAST_ATAN2_MAGTHRESH);
if(!x1566.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x1566.value)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1567=(pz*r22);
IkReal x1568=(cj0*r12);
IkReal x1569=((31.0)*sj0);
CheckValue<IkReal> x1570=IKPowWithIntegerCheck(((((43.0)*gconst77*r01))+(((-43.0)*gconst78*r00))),-1);
if(!x1570.valid){
continue;
}
if( IKabs(((x1570.value)*((((x1569*(r02*r02)))+(((-31.0)*r02*x1568))+(((-1.0)*x1569))+(((-400.0)*r02*x1567)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-0.720930232558139)*r02*sj0))+(((0.720930232558139)*x1568))+(((9.30232558139535)*x1567)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1570.value)*((((x1569*(r02*r02)))+(((-31.0)*r02*x1568))+(((-1.0)*x1569))+(((-400.0)*r02*x1567))))))+IKsqr(((((-0.720930232558139)*r02*sj0))+(((0.720930232558139)*x1568))+(((9.30232558139535)*x1567))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1570.value)*((((x1569*(r02*r02)))+(((-31.0)*r02*x1568))+(((-1.0)*x1569))+(((-400.0)*r02*x1567))))), ((((-0.720930232558139)*r02*sj0))+(((0.720930232558139)*x1568))+(((9.30232558139535)*x1567))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1571=IKcos(j4);
IkReal x1572=IKsin(j4);
IkReal x1573=(gconst78*r20);
IkReal x1574=((0.0775)*cj0);
IkReal x1575=(gconst77*r11);
IkReal x1576=((0.0775)*sj0);
IkReal x1577=(gconst77*r01);
IkReal x1578=(gconst78*r00);
IkReal x1579=(gconst77*r21);
IkReal x1580=(gconst78*r10);
IkReal x1581=(pz*r22);
IkReal x1582=((1.0)*pz);
IkReal x1583=((0.1075)*x1572);
IkReal x1584=((0.1075)*x1571);
IkReal x1585=((0.215)*pz*x1572);
evalcond[0]=(x1584+((r02*x1576))+(((-1.0)*x1581))+(((-1.0)*r12*x1574)));
evalcond[1]=((((-1.0)*x1582))+(((-1.0)*x1573*x1583))+((r22*x1584))+((x1579*x1583)));
evalcond[2]=((((-1.0)*x1578*x1583))+x1576+((r02*x1584))+((x1577*x1583)));
evalcond[3]=((((-1.0)*x1580*x1583))+((r12*x1584))+((x1575*x1583))+(((-1.0)*x1574)));
evalcond[4]=((-0.0111)+(((-1.0)*x1573*x1585))+(((0.215)*x1571*x1581))+((x1579*x1585)));
evalcond[5]=((((-1.0)*x1583))+(((-1.0)*x1576*x1577))+(((-1.0)*x1573*x1582))+((x1576*x1578))+(((-1.0)*x1574*x1580))+((pz*x1579))+((x1574*x1575)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1588 = ((1.0)+(((-1.0)*(r22*r22))));
if(IKabs(x1588)==0){
continue;
}
IkReal x1586=pow(x1588,-0.5);
IkReal x1587=((-1.0)*x1586);
CheckValue<IkReal> x1589 = IKatan2WithCheck(IkReal(((-1.0)*r20)),IkReal(r21),IKFAST_ATAN2_MAGTHRESH);
if(!x1589.valid){
continue;
}
IkReal gconst79=((3.14159265358979)+(((-1.0)*(x1589.value))));
IkReal gconst80=(r20*x1587);
IkReal gconst81=(r21*x1587);
CheckValue<IkReal> x1590 = IKatan2WithCheck(IkReal(((-1.0)*r20)),IkReal(r21),IKFAST_ATAN2_MAGTHRESH);
if(!x1590.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x1590.value)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1591=(pz*r22);
IkReal x1592=((31.0)*sj0);
IkReal x1593=(cj0*r12);
CheckValue<IkReal> x1594=IKPowWithIntegerCheck(((((-43.0)*gconst81*r00))+(((43.0)*gconst80*r01))),-1);
if(!x1594.valid){
continue;
}
if( IKabs(((x1594.value)*(((((-1.0)*x1592))+(((-400.0)*r02*x1591))+(((-31.0)*r02*x1593))+((x1592*(r02*r02))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((9.30232558139535)*x1591))+(((-0.720930232558139)*r02*sj0))+(((0.720930232558139)*x1593)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1594.value)*(((((-1.0)*x1592))+(((-400.0)*r02*x1591))+(((-31.0)*r02*x1593))+((x1592*(r02*r02)))))))+IKsqr(((((9.30232558139535)*x1591))+(((-0.720930232558139)*r02*sj0))+(((0.720930232558139)*x1593))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1594.value)*(((((-1.0)*x1592))+(((-400.0)*r02*x1591))+(((-31.0)*r02*x1593))+((x1592*(r02*r02)))))), ((((9.30232558139535)*x1591))+(((-0.720930232558139)*r02*sj0))+(((0.720930232558139)*x1593))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1595=IKcos(j4);
IkReal x1596=IKsin(j4);
IkReal x1597=((0.0775)*cj0);
IkReal x1598=(gconst80*r11);
IkReal x1599=((1.0)*pz);
IkReal x1600=(gconst81*r20);
IkReal x1601=(gconst80*r21);
IkReal x1602=((0.0775)*sj0);
IkReal x1603=((0.215)*pz);
IkReal x1604=(gconst80*r01);
IkReal x1605=((0.1075)*x1595);
IkReal x1606=((0.1075)*x1596);
IkReal x1607=(gconst81*x1606);
evalcond[0]=(x1605+(((-1.0)*r22*x1599))+((r02*x1602))+(((-1.0)*r12*x1597)));
evalcond[1]=((((-1.0)*x1599))+((x1601*x1606))+(((-1.0)*x1600*x1606))+((r22*x1605)));
evalcond[2]=(x1602+(((-1.0)*r00*x1607))+((r02*x1605))+((x1604*x1606)));
evalcond[3]=((((-1.0)*x1597))+((r12*x1605))+((x1598*x1606))+(((-1.0)*r10*x1607)));
evalcond[4]=((-0.0111)+(((-1.0)*x1596*x1600*x1603))+((x1596*x1601*x1603))+((r22*x1595*x1603)));
evalcond[5]=(((gconst81*r00*x1602))+(((-1.0)*x1606))+(((-1.0)*gconst81*r10*x1597))+(((-1.0)*x1599*x1600))+(((-1.0)*x1602*x1604))+((x1597*x1598))+((pz*x1601)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r21))+(IKabs(r20)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
IkReal x1608=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1608);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1608);
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
r20=0;
r21=0;
r02=0;
r12=0;
j4eval[0]=(((r01*sj5))+(((-1.0)*cj5*r00)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
IkReal x1609=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1609);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1609);
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
r20=0;
r21=0;
r02=0;
r12=0;
j4eval[0]=((((-1.0)*cj5*r10))+((r11*sj5)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
IkReal x1610=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1610);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1610);
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
r20=0;
r21=0;
r02=0;
r12=0;
j4eval[0]=(((r01*sj5))+(((-1.0)*cj5*r00)));
j4eval[1]=pz;
j4eval[2]=r22;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(pz);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
IkReal x1611=((0.720930232558139)*cj5);
IkReal x1612=((0.720930232558139)*sj5);
sj4array[0]=(((cj0*r11*x1612))+(((-1.0)*cj0*r10*x1611))+((r00*sj0*x1611))+(((-1.0)*r01*sj0*x1612)));
if( sj4array[0] >= -1-IKFAST_SINCOS_THRESH && sj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKasin(sj4array[0]);
    cj4array[0] = IKcos(j4array[0]);
    sj4array[1] = sj4array[0];
    j4array[1] = j4array[0] > 0 ? (IKPI-j4array[0]) : (-IKPI-j4array[0]);
    cj4array[1] = -cj4array[0];
}
else if( isnan(sj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x1613=IKcos(j4);
IkReal x1614=IKsin(j4);
IkReal x1615=((0.1075)*x1613);
IkReal x1616=((0.1075)*x1614);
evalcond[0]=x1615;
evalcond[1]=(r22*x1615);
evalcond[2]=(((r01*sj5*x1616))+(((-1.0)*cj5*r00*x1616))+(((0.0775)*sj0)));
evalcond[3]=(((r11*sj5*x1616))+(((-1.0)*cj5*r10*x1616))+(((-0.0775)*cj0)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x1617=IKPowWithIntegerCheck(((((43.0)*r01*sj5))+(((-43.0)*cj5*r00))),-1);
if(!x1617.valid){
continue;
}
CheckValue<IkReal> x1618=IKPowWithIntegerCheck(pz,-1);
if(!x1618.valid){
continue;
}
CheckValue<IkReal> x1619=IKPowWithIntegerCheck(r22,-1);
if(!x1619.valid){
continue;
}
if( IKabs(((-31.0)*sj0*(x1617.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.0516279069767442)*(x1618.value)*(x1619.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-31.0)*sj0*(x1617.value)))+IKsqr(((0.0516279069767442)*(x1618.value)*(x1619.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-31.0)*sj0*(x1617.value)), ((0.0516279069767442)*(x1618.value)*(x1619.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1620=IKcos(j4);
IkReal x1621=IKsin(j4);
IkReal x1622=(r11*sj5);
IkReal x1623=(cj5*r00);
IkReal x1624=((1.0)*pz);
IkReal x1625=(r01*sj5);
IkReal x1626=((0.0775)*cj0);
IkReal x1627=(cj5*r10);
IkReal x1628=((0.0775)*sj0);
IkReal x1629=(r22*x1620);
IkReal x1630=((0.1075)*x1621);
evalcond[0]=((-0.0111)+(((0.215)*pz*x1629)));
evalcond[1]=((((0.1075)*x1620))+(((-1.0)*r22*x1624)));
evalcond[2]=((((-1.0)*x1624))+(((0.1075)*x1629)));
evalcond[3]=((((-1.0)*x1623*x1630))+x1628+((x1625*x1630)));
evalcond[4]=((((-1.0)*x1626))+((x1622*x1630))+(((-1.0)*x1627*x1630)));
evalcond[5]=(((x1623*x1628))+((x1622*x1626))+(((-1.0)*x1630))+(((-1.0)*x1625*x1628))+(((-1.0)*x1626*x1627)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x1631=IKPowWithIntegerCheck(((((-43.0)*cj5*r10))+(((43.0)*r11*sj5))),-1);
if(!x1631.valid){
continue;
}
if( IKabs(((31.0)*cj0*(x1631.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((9.30232558139535)*pz*r22)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((31.0)*cj0*(x1631.value)))+IKsqr(((9.30232558139535)*pz*r22))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((31.0)*cj0*(x1631.value)), ((9.30232558139535)*pz*r22));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1632=IKcos(j4);
IkReal x1633=IKsin(j4);
IkReal x1634=(r11*sj5);
IkReal x1635=(cj5*r00);
IkReal x1636=((1.0)*pz);
IkReal x1637=(r01*sj5);
IkReal x1638=((0.0775)*cj0);
IkReal x1639=(cj5*r10);
IkReal x1640=((0.0775)*sj0);
IkReal x1641=(r22*x1632);
IkReal x1642=((0.1075)*x1633);
evalcond[0]=((-0.0111)+(((0.215)*pz*x1641)));
evalcond[1]=((((-1.0)*r22*x1636))+(((0.1075)*x1632)));
evalcond[2]=((((-1.0)*x1636))+(((0.1075)*x1641)));
evalcond[3]=((((-1.0)*x1635*x1642))+((x1637*x1642))+x1640);
evalcond[4]=((((-1.0)*x1639*x1642))+(((-1.0)*x1638))+((x1634*x1642)));
evalcond[5]=((((-1.0)*x1638*x1639))+(((-1.0)*x1642))+(((-1.0)*x1637*x1640))+((x1635*x1640))+((x1634*x1638)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x1643=IKPowWithIntegerCheck(((((43.0)*r01*sj5))+(((-43.0)*cj5*r00))),-1);
if(!x1643.valid){
continue;
}
if( IKabs(((-31.0)*sj0*(x1643.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((9.30232558139535)*pz*r22)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-31.0)*sj0*(x1643.value)))+IKsqr(((9.30232558139535)*pz*r22))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-31.0)*sj0*(x1643.value)), ((9.30232558139535)*pz*r22));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1644=IKcos(j4);
IkReal x1645=IKsin(j4);
IkReal x1646=(r11*sj5);
IkReal x1647=(cj5*r00);
IkReal x1648=((1.0)*pz);
IkReal x1649=(r01*sj5);
IkReal x1650=((0.0775)*cj0);
IkReal x1651=(cj5*r10);
IkReal x1652=((0.0775)*sj0);
IkReal x1653=(r22*x1644);
IkReal x1654=((0.1075)*x1645);
evalcond[0]=((-0.0111)+(((0.215)*pz*x1653)));
evalcond[1]=((((-1.0)*r22*x1648))+(((0.1075)*x1644)));
evalcond[2]=((((0.1075)*x1653))+(((-1.0)*x1648)));
evalcond[3]=(x1652+(((-1.0)*x1647*x1654))+((x1649*x1654)));
evalcond[4]=(((x1646*x1654))+(((-1.0)*x1650))+(((-1.0)*x1651*x1654)));
evalcond[5]=((((-1.0)*x1650*x1651))+((x1647*x1652))+((x1646*x1650))+(((-1.0)*x1654))+(((-1.0)*x1649*x1652)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1655=((31.0)*cj0);
IkReal x1656=(pz*r22);
IkReal x1657=(r02*sj0);
CheckValue<IkReal> x1658=IKPowWithIntegerCheck(((((-43.0)*cj5*r10))+(((43.0)*r11*sj5))),-1);
if(!x1658.valid){
continue;
}
if( IKabs(((x1658.value)*(((((31.0)*r12*x1657))+x1655+(((-400.0)*r12*x1656))+(((-1.0)*x1655*(r12*r12))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-0.720930232558139)*x1657))+(((9.30232558139535)*x1656))+(((0.720930232558139)*cj0*r12)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1658.value)*(((((31.0)*r12*x1657))+x1655+(((-400.0)*r12*x1656))+(((-1.0)*x1655*(r12*r12)))))))+IKsqr(((((-0.720930232558139)*x1657))+(((9.30232558139535)*x1656))+(((0.720930232558139)*cj0*r12))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1658.value)*(((((31.0)*r12*x1657))+x1655+(((-400.0)*r12*x1656))+(((-1.0)*x1655*(r12*r12)))))), ((((-0.720930232558139)*x1657))+(((9.30232558139535)*x1656))+(((0.720930232558139)*cj0*r12))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1659=IKcos(j4);
IkReal x1660=IKsin(j4);
IkReal x1661=(r01*sj5);
IkReal x1662=((0.0775)*sj0);
IkReal x1663=(cj5*r00);
IkReal x1664=((0.0775)*cj0);
IkReal x1665=(cj5*r10);
IkReal x1666=(r21*sj5);
IkReal x1667=((0.215)*pz);
IkReal x1668=(r11*sj5);
IkReal x1669=((1.0)*pz);
IkReal x1670=(cj5*r20);
IkReal x1671=((0.1075)*x1660);
IkReal x1672=((0.1075)*x1659);
evalcond[0]=(x1672+((r02*x1662))+(((-1.0)*r12*x1664))+(((-1.0)*r22*x1669)));
evalcond[1]=(((x1666*x1671))+(((-1.0)*x1669))+(((-1.0)*x1670*x1671))+((r22*x1672)));
evalcond[2]=(((r02*x1672))+(((-1.0)*x1663*x1671))+x1662+((x1661*x1671)));
evalcond[3]=(((x1668*x1671))+(((-1.0)*x1664))+(((-1.0)*x1665*x1671))+((r12*x1672)));
evalcond[4]=((-0.0111)+((x1660*x1666*x1667))+(((-1.0)*x1660*x1667*x1670))+((r22*x1659*x1667)));
evalcond[5]=((((-1.0)*x1661*x1662))+(((-1.0)*x1669*x1670))+((pz*x1666))+((x1662*x1663))+(((-1.0)*x1671))+((x1664*x1668))+(((-1.0)*x1664*x1665)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1673=(pz*r22);
IkReal x1674=(cj0*r12);
IkReal x1675=((31.0)*sj0);
CheckValue<IkReal> x1676=IKPowWithIntegerCheck(((((43.0)*r01*sj5))+(((-43.0)*cj5*r00))),-1);
if(!x1676.valid){
continue;
}
if( IKabs(((x1676.value)*(((((-31.0)*r02*x1674))+((x1675*(r02*r02)))+(((-400.0)*r02*x1673))+(((-1.0)*x1675)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((9.30232558139535)*x1673))+(((-0.720930232558139)*r02*sj0))+(((0.720930232558139)*x1674)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1676.value)*(((((-31.0)*r02*x1674))+((x1675*(r02*r02)))+(((-400.0)*r02*x1673))+(((-1.0)*x1675))))))+IKsqr(((((9.30232558139535)*x1673))+(((-0.720930232558139)*r02*sj0))+(((0.720930232558139)*x1674))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1676.value)*(((((-31.0)*r02*x1674))+((x1675*(r02*r02)))+(((-400.0)*r02*x1673))+(((-1.0)*x1675))))), ((((9.30232558139535)*x1673))+(((-0.720930232558139)*r02*sj0))+(((0.720930232558139)*x1674))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1677=IKcos(j4);
IkReal x1678=IKsin(j4);
IkReal x1679=(r01*sj5);
IkReal x1680=((0.0775)*sj0);
IkReal x1681=(cj5*r00);
IkReal x1682=((0.0775)*cj0);
IkReal x1683=(cj5*r10);
IkReal x1684=(r21*sj5);
IkReal x1685=((0.215)*pz);
IkReal x1686=(r11*sj5);
IkReal x1687=((1.0)*pz);
IkReal x1688=(cj5*r20);
IkReal x1689=((0.1075)*x1678);
IkReal x1690=((0.1075)*x1677);
evalcond[0]=((((-1.0)*r12*x1682))+x1690+((r02*x1680))+(((-1.0)*r22*x1687)));
evalcond[1]=((((-1.0)*x1687))+((r22*x1690))+((x1684*x1689))+(((-1.0)*x1688*x1689)));
evalcond[2]=((((-1.0)*x1681*x1689))+x1680+((r02*x1690))+((x1679*x1689)));
evalcond[3]=(((r12*x1690))+(((-1.0)*x1682))+(((-1.0)*x1683*x1689))+((x1686*x1689)));
evalcond[4]=((-0.0111)+(((-1.0)*x1678*x1685*x1688))+((x1678*x1684*x1685))+((r22*x1677*x1685)));
evalcond[5]=((((-1.0)*x1687*x1688))+(((-1.0)*x1689))+((x1680*x1681))+(((-1.0)*x1682*x1683))+(((-1.0)*x1679*x1680))+((pz*x1684))+((x1682*x1686)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1691=((0.0775)*r22);
IkReal x1692=(r02*sj0);
IkReal x1693=(cj0*r12);
CheckValue<IkReal> x1694=IKPowWithIntegerCheck(((((0.1075)*r21*sj5))+(((-0.1075)*cj5*r20))),-1);
if(!x1694.valid){
continue;
}
if( IKabs(((x1694.value)*((((x1691*x1692))+(((-1.0)*pz*(r22*r22)))+(((-1.0)*x1691*x1693))+pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-0.720930232558139)*x1692))+(((9.30232558139535)*pz*r22))+(((0.720930232558139)*x1693)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1694.value)*((((x1691*x1692))+(((-1.0)*pz*(r22*r22)))+(((-1.0)*x1691*x1693))+pz))))+IKsqr(((((-0.720930232558139)*x1692))+(((9.30232558139535)*pz*r22))+(((0.720930232558139)*x1693))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1694.value)*((((x1691*x1692))+(((-1.0)*pz*(r22*r22)))+(((-1.0)*x1691*x1693))+pz))), ((((-0.720930232558139)*x1692))+(((9.30232558139535)*pz*r22))+(((0.720930232558139)*x1693))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1695=IKcos(j4);
IkReal x1696=IKsin(j4);
IkReal x1697=(r01*sj5);
IkReal x1698=((0.0775)*sj0);
IkReal x1699=(cj5*r00);
IkReal x1700=((0.0775)*cj0);
IkReal x1701=(cj5*r10);
IkReal x1702=(r21*sj5);
IkReal x1703=((0.215)*pz);
IkReal x1704=(r11*sj5);
IkReal x1705=((1.0)*pz);
IkReal x1706=(cj5*r20);
IkReal x1707=((0.1075)*x1696);
IkReal x1708=((0.1075)*x1695);
evalcond[0]=(x1708+((r02*x1698))+(((-1.0)*r22*x1705))+(((-1.0)*r12*x1700)));
evalcond[1]=(((r22*x1708))+(((-1.0)*x1705))+(((-1.0)*x1706*x1707))+((x1702*x1707)));
evalcond[2]=(((x1697*x1707))+((r02*x1708))+x1698+(((-1.0)*x1699*x1707)));
evalcond[3]=(((r12*x1708))+(((-1.0)*x1700))+((x1704*x1707))+(((-1.0)*x1701*x1707)));
evalcond[4]=((-0.0111)+((x1696*x1702*x1703))+((r22*x1695*x1703))+(((-1.0)*x1696*x1703*x1706)));
evalcond[5]=((((-1.0)*x1697*x1698))+((x1700*x1704))+(((-1.0)*x1707))+(((-1.0)*x1705*x1706))+(((-1.0)*x1700*x1701))+((x1698*x1699))+((pz*x1702)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
IkReal x1709=((0.215)*pz);
IkReal x1710=(((r21*sj5*x1709))+(((-1.0)*cj5*r20*x1709)));
CheckValue<IkReal> x1713 = IKatan2WithCheck(IkReal((r22*x1709)),IkReal(x1710),IKFAST_ATAN2_MAGTHRESH);
if(!x1713.valid){
continue;
}
IkReal x1711=((1.0)*(x1713.value));
if((((x1710*x1710)+(((0.046225)*(pz*pz)*(r22*r22))))) < -0.00001)
continue;
CheckValue<IkReal> x1714=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1710*x1710)+(((0.046225)*(pz*pz)*(r22*r22)))))),-1);
if(!x1714.valid){
continue;
}
if( (((0.0111)*(x1714.value))) < -1-IKFAST_SINCOS_THRESH || (((0.0111)*(x1714.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1712=IKasin(((0.0111)*(x1714.value)));
j4array[0]=(x1712+(((-1.0)*x1711)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x1711))+(((-1.0)*x1712)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
IkReal x1715=IKsin(j4);
IkReal x1716=((0.1075)*x1715);
evalcond[0]=((((-1.0)*cj5*r20*x1716))+(((0.1075)*r22*(IKcos(j4))))+(((-1.0)*pz))+((r21*sj5*x1716)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1717=((1.38709677419355)*sj4);
IkReal x1718=((1.38709677419355)*cj4);
if( IKabs(((((-1.0)*r01*sj5*x1717))+(((-1.0)*r02*x1718))+((cj5*r00*x1717)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj5*r10*x1717))+((r12*x1718))+((r11*sj5*x1717)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r01*sj5*x1717))+(((-1.0)*r02*x1718))+((cj5*r00*x1717))))+IKsqr(((((-1.0)*cj5*r10*x1717))+((r12*x1718))+((r11*sj5*x1717))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(((((-1.0)*r01*sj5*x1717))+(((-1.0)*r02*x1718))+((cj5*r00*x1717))), ((((-1.0)*cj5*r10*x1717))+((r12*x1718))+((r11*sj5*x1717))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1719=IKsin(j0);
IkReal x1720=IKcos(j0);
IkReal x1721=((0.0775)*sj5);
IkReal x1722=((0.0775)*cj5);
IkReal x1723=((1.0)*pz);
IkReal x1724=((0.1075)*sj4);
IkReal x1725=((0.1075)*cj4);
IkReal x1726=(r10*x1720);
IkReal x1727=(r01*x1719);
IkReal x1728=((0.0775)*x1719);
IkReal x1729=(r11*x1720);
IkReal x1730=(r00*x1719);
IkReal x1731=((0.0775)*x1720);
evalcond[0]=((((-1.0)*r22*x1723))+x1725+(((-1.0)*r12*x1731))+((r02*x1728)));
evalcond[1]=(x1728+((r02*x1725))+(((-1.0)*cj5*r00*x1724))+((r01*sj5*x1724)));
evalcond[2]=((((-1.0)*cj5*r10*x1724))+((r11*sj5*x1724))+((r12*x1725))+(((-1.0)*x1731)));
evalcond[3]=(((x1722*x1727))+(((-1.0)*x1722*x1729))+((x1721*x1730))+(((-1.0)*r20*sj5*x1723))+(((-1.0)*cj5*r21*x1723))+(((-1.0)*x1721*x1726)));
evalcond[4]=(((x1722*x1730))+(((-1.0)*x1722*x1726))+((x1721*x1729))+(((-1.0)*cj5*r20*x1723))+((pz*r21*sj5))+(((-1.0)*x1724))+(((-1.0)*x1721*x1727)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
IkReal x1732=((((0.1075)*r21*sj5))+(((-0.1075)*cj5*r20)));
CheckValue<IkReal> x1735 = IKatan2WithCheck(IkReal(((0.1075)*r22)),IkReal(x1732),IKFAST_ATAN2_MAGTHRESH);
if(!x1735.valid){
continue;
}
IkReal x1733=((1.0)*(x1735.value));
if((((((0.01155625)*(r22*r22)))+(x1732*x1732))) < -0.00001)
continue;
CheckValue<IkReal> x1736=IKPowWithIntegerCheck(IKabs(IKsqrt(((((0.01155625)*(r22*r22)))+(x1732*x1732)))),-1);
if(!x1736.valid){
continue;
}
if( ((pz*(x1736.value))) < -1-IKFAST_SINCOS_THRESH || ((pz*(x1736.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1734=IKasin((pz*(x1736.value)));
j4array[0]=(x1734+(((-1.0)*x1733)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x1734))+(((-1.0)*x1733)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
IkReal x1737=IKsin(j4);
IkReal x1738=((0.215)*pz);
evalcond[0]=((-0.0111)+((r22*x1738*(IKcos(j4))))+((r21*sj5*x1737*x1738))+(((-1.0)*cj5*r20*x1737*x1738)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1739=((1.38709677419355)*sj4);
IkReal x1740=((1.38709677419355)*cj4);
if( IKabs((((cj5*r00*x1739))+(((-1.0)*r01*sj5*x1739))+(((-1.0)*r02*x1740)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r12*x1740))+(((-1.0)*cj5*r10*x1739))+((r11*sj5*x1739)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj5*r00*x1739))+(((-1.0)*r01*sj5*x1739))+(((-1.0)*r02*x1740))))+IKsqr((((r12*x1740))+(((-1.0)*cj5*r10*x1739))+((r11*sj5*x1739))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2((((cj5*r00*x1739))+(((-1.0)*r01*sj5*x1739))+(((-1.0)*r02*x1740))), (((r12*x1740))+(((-1.0)*cj5*r10*x1739))+((r11*sj5*x1739))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1741=IKsin(j0);
IkReal x1742=IKcos(j0);
IkReal x1743=((0.0775)*sj5);
IkReal x1744=((0.0775)*cj5);
IkReal x1745=((1.0)*pz);
IkReal x1746=((0.1075)*sj4);
IkReal x1747=((0.1075)*cj4);
IkReal x1748=(r10*x1742);
IkReal x1749=(r01*x1741);
IkReal x1750=((0.0775)*x1741);
IkReal x1751=(r11*x1742);
IkReal x1752=(r00*x1741);
IkReal x1753=((0.0775)*x1742);
evalcond[0]=((((-1.0)*r12*x1753))+x1747+((r02*x1750))+(((-1.0)*r22*x1745)));
evalcond[1]=(((r01*sj5*x1746))+x1750+((r02*x1747))+(((-1.0)*cj5*r00*x1746)));
evalcond[2]=(((r12*x1747))+((r11*sj5*x1746))+(((-1.0)*x1753))+(((-1.0)*cj5*r10*x1746)));
evalcond[3]=(((x1744*x1749))+(((-1.0)*cj5*r21*x1745))+((x1743*x1752))+(((-1.0)*x1744*x1751))+(((-1.0)*r20*sj5*x1745))+(((-1.0)*x1743*x1748)));
evalcond[4]=(((x1744*x1752))+(((-1.0)*cj5*r20*x1745))+(((-1.0)*x1746))+((x1743*x1751))+((pz*r21*sj5))+(((-1.0)*x1744*x1748))+(((-1.0)*x1743*x1749)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j4, j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x1756 = IKatan2WithCheck(IkReal(((0.155)*py)),IkReal(((-0.155)*px)),IKFAST_ATAN2_MAGTHRESH);
if(!x1756.valid){
continue;
}
IkReal x1754=((1.0)*(x1756.value));
if((((((0.024025)*(py*py)))+(((0.024025)*(px*px))))) < -0.00001)
continue;
CheckValue<IkReal> x1757=IKPowWithIntegerCheck(IKabs(IKsqrt(((((0.024025)*(py*py)))+(((0.024025)*(px*px)))))),-1);
if(!x1757.valid){
continue;
}
if( (((x1757.value)*(((-0.00555)+pp)))) < -1-IKFAST_SINCOS_THRESH || (((x1757.value)*(((-0.00555)+pp)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1755=IKasin(((x1757.value)*(((-0.00555)+pp))));
j0array[0]=((((-1.0)*x1754))+(((-1.0)*x1755)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x1755+(((-1.0)*x1754)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
cj4array[0]=((((-0.720930232558139)*r02*sj0))+(((9.30232558139535)*npz))+(((0.720930232558139)*cj0*r12)));
if( cj4array[0] >= -1-IKFAST_SINCOS_THRESH && cj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKacos(cj4array[0]);
    sj4array[0] = IKsin(j4array[0]);
    cj4array[1] = cj4array[0];
    j4array[1] = -j4array[0];
    sj4array[1] = -sj4array[0];
}
else if( isnan(cj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

{
IkReal j5eval[3];
IkReal x1758=(r02*sj4);
IkReal x1759=((31.0)*cj0);
IkReal x1760=((43.0)*cj4);
j5eval[0]=x1758;
j5eval[1]=IKsign(x1758);
j5eval[2]=((IKabs(((((-1.0)*r00*x1760))+(((-1.0)*r21*x1759))+(((400.0)*rxp1_0)))))+(IKabs((((r01*x1760))+(((400.0)*rxp0_0))+(((-1.0)*r20*x1759))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal j5eval[3];
IkReal x1761=(r12*sj4);
IkReal x1762=((43.0)*cj4);
IkReal x1763=((31.0)*sj0);
j5eval[0]=x1761;
j5eval[1]=IKsign(x1761);
j5eval[2]=((IKabs((((r20*x1763))+(((-1.0)*r11*x1762))+(((-400.0)*rxp0_1)))))+(IKabs((((r21*x1763))+(((-400.0)*rxp1_1))+((r10*x1762))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal j5eval[3];
IkReal x1764=((200.0)*pp);
IkReal x1765=((400.0)*pz);
IkReal x1766=(npx*r21*sj4);
IkReal x1767=((43.0)*cj4*npz);
IkReal x1768=((43.0)*cj4*r22);
IkReal x1769=(npy*r20*sj4);
j5eval[0]=((((-1.0)*x1766))+x1769);
j5eval[1]=((IKabs((((r20*x1764))+(((-1.0)*r20*x1767))+((npx*x1768))+(((1.11)*r20))+(((-1.0)*npx*x1765)))))+(IKabs((((r21*x1764))+(((-1.0)*r21*x1767))+((npy*x1768))+(((-1.0)*npy*x1765))+(((1.11)*r21))))));
j5eval[2]=IKsign(((((43.0)*x1769))+(((-43.0)*x1766))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
sj4=0;
cj4=1.0;
j4=0;
IkReal x1770=((0.0775)*sj0);
IkReal x1771=((0.0775)*cj0);
j5eval[0]=((IKabs(((((-1.0)*npx))+((r00*x1770))+(((-1.0)*r10*x1771)))))+(IKabs((((r11*x1771))+npy+(((-1.0)*r01*x1770))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
sj4=0;
cj4=1.0;
j4=0;
IkReal x1772=((0.0775)*sj0);
IkReal x1773=((0.0775)*cj0);
j5eval[0]=((IKabs(((((-1.0)*npx))+((r00*x1772))+(((-1.0)*r10*x1773)))))+(IKabs(((((-1.0)*npy))+((r01*x1772))+(((-1.0)*r11*x1773))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j5]

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1774=((0.0775)*sj0);
IkReal x1775=((0.0775)*cj0);
CheckValue<IkReal> x1777 = IKatan2WithCheck(IkReal(((((-1.0)*npy))+((r01*x1774))+(((-1.0)*r11*x1775)))),IkReal(((((-1.0)*npx))+((r00*x1774))+(((-1.0)*r10*x1775)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1777.valid){
continue;
}
IkReal x1776=x1777.value;
j5array[0]=((-1.0)*x1776);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1776)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1778=IKsin(j5);
IkReal x1779=IKcos(j5);
IkReal x1780=((0.0775)*sj0);
IkReal x1781=((0.0775)*cj0);
evalcond[0]=(((r00*x1779*x1780))+((npy*x1778))+(((-1.0)*r10*x1779*x1781))+(((-1.0)*npx*x1779))+(((-1.0)*r01*x1778*x1780))+((r11*x1778*x1781)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1782=((0.0775)*sj0);
IkReal x1783=((0.0775)*cj0);
CheckValue<IkReal> x1785 = IKatan2WithCheck(IkReal(((((-1.0)*r10*x1783))+(((-1.0)*npx))+((r00*x1782)))),IkReal(((((-1.0)*r01*x1782))+npy+((r11*x1783)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1785.valid){
continue;
}
IkReal x1784=x1785.value;
j5array[0]=((-1.0)*x1784);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1784)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1786=IKcos(j5);
IkReal x1787=IKsin(j5);
IkReal x1788=((0.0775)*cj0);
IkReal x1789=((0.0775)*sj0);
evalcond[0]=((((-1.0)*npy*x1786))+(((-1.0)*r10*x1787*x1788))+((r01*x1786*x1789))+((r00*x1787*x1789))+(((-1.0)*r11*x1786*x1788))+(((-1.0)*npx*x1787)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
IkReal x1790=((0.0775)*sj0);
IkReal x1791=((0.0775)*cj0);
j5eval[0]=((IKabs((((r00*x1790))+(((-1.0)*r10*x1791))+(((-1.0)*npx)))))+(IKabs(((((-1.0)*r01*x1790))+npy+((r11*x1791))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
IkReal x1792=((0.0775)*sj0);
IkReal x1793=((0.0775)*cj0);
j5eval[0]=((IKabs((((r00*x1792))+(((-1.0)*r10*x1793))+(((-1.0)*npx)))))+(IKabs(((((-1.0)*r11*x1793))+(((-1.0)*npy))+((r01*x1792))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j5]

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1794=((0.0775)*sj0);
IkReal x1795=((0.0775)*cj0);
CheckValue<IkReal> x1797 = IKatan2WithCheck(IkReal(((((-1.0)*r11*x1795))+(((-1.0)*npy))+((r01*x1794)))),IkReal((((r00*x1794))+(((-1.0)*r10*x1795))+(((-1.0)*npx)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1797.valid){
continue;
}
IkReal x1796=x1797.value;
j5array[0]=((-1.0)*x1796);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1796)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1798=IKsin(j5);
IkReal x1799=IKcos(j5);
IkReal x1800=((0.0775)*sj0);
IkReal x1801=((0.0775)*cj0);
evalcond[0]=((((-1.0)*r10*x1799*x1801))+((r11*x1798*x1801))+((npy*x1798))+((r00*x1799*x1800))+(((-1.0)*r01*x1798*x1800))+(((-1.0)*npx*x1799)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1802=((0.0775)*sj0);
IkReal x1803=((0.0775)*cj0);
CheckValue<IkReal> x1805 = IKatan2WithCheck(IkReal(((((-1.0)*r10*x1803))+(((-1.0)*npx))+((r00*x1802)))),IkReal(((((-1.0)*r01*x1802))+npy+((r11*x1803)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1805.valid){
continue;
}
IkReal x1804=x1805.value;
j5array[0]=((-1.0)*x1804);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1804)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1806=IKcos(j5);
IkReal x1807=IKsin(j5);
IkReal x1808=((0.0775)*cj0);
IkReal x1809=((0.0775)*sj0);
evalcond[0]=((((-1.0)*r10*x1807*x1808))+(((-1.0)*npy*x1806))+((r00*x1807*x1809))+(((-1.0)*npx*x1807))+((r01*x1806*x1809))+(((-1.0)*r11*x1806*x1808)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(r02);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[3];
r02=0;
npz=(((py*r12))+((pz*r22)));
rxp2_1=(px*r22);
rxp2_2=((-1.0)*px*r12);
IkReal x1810=(r12*sj4);
IkReal x1811=((31.0)*sj0);
IkReal x1812=((43.0)*cj4*r22);
j5eval[0]=x1810;
j5eval[1]=((IKabs(((((-400.0)*rxp1_1))+(((-1.0)*r01*x1812))+((r21*x1811)))))+(IKabs((((r20*x1811))+(((-400.0)*rxp0_1))+(((-1.0)*r00*x1812))))));
j5eval[2]=IKsign(x1810);
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal j5eval[3];
r02=0;
npz=(((py*r12))+((pz*r22)));
rxp2_1=(px*r22);
rxp2_2=((-1.0)*px*r12);
IkReal x1813=(r22*sj4);
IkReal x1814=((31.0)*sj0);
IkReal x1815=((31.0)*cj0);
IkReal x1816=((43.0)*cj4*r12);
j5eval[0]=x1813;
j5eval[1]=IKsign(x1813);
j5eval[2]=((IKabs(((((-1.0)*r01*x1816))+((r01*x1815))+((r11*x1814))+(((400.0)*rxp1_2)))))+(IKabs(((((400.0)*rxp0_2))+(((-1.0)*r00*x1816))+((r00*x1815))+((r10*x1814))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
r02=0;
npz=(((py*r12))+((pz*r22)));
rxp2_1=(px*r22);
rxp2_2=((-1.0)*px*r12);
sj4=0;
cj4=1.0;
j4=0;
IkReal x1817=((0.0775)*sj0);
IkReal x1818=((0.0775)*cj0);
j5eval[0]=((IKabs(((((-1.0)*npx))+(((-1.0)*r10*x1818))+((r00*x1817)))))+(IKabs((npy+(((-1.0)*r01*x1817))+((r11*x1818))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
r02=0;
npz=(((py*r12))+((pz*r22)));
rxp2_1=(px*r22);
rxp2_2=((-1.0)*px*r12);
sj4=0;
cj4=1.0;
j4=0;
IkReal x1819=((0.0775)*sj0);
IkReal x1820=((0.0775)*cj0);
j5eval[0]=((IKabs(((((-1.0)*npx))+((r00*x1819))+(((-1.0)*r10*x1820)))))+(IKabs(((((-1.0)*npy))+((r01*x1819))+(((-1.0)*r11*x1820))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j5]

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1821=((0.0775)*sj0);
IkReal x1822=((0.0775)*cj0);
CheckValue<IkReal> x1824 = IKatan2WithCheck(IkReal(((((-1.0)*npy))+((r01*x1821))+(((-1.0)*r11*x1822)))),IkReal((((r00*x1821))+(((-1.0)*npx))+(((-1.0)*r10*x1822)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1824.valid){
continue;
}
IkReal x1823=x1824.value;
j5array[0]=((-1.0)*x1823);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1823)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1825=IKsin(j5);
IkReal x1826=IKcos(j5);
IkReal x1827=((0.0775)*sj0);
IkReal x1828=((0.0775)*cj0);
evalcond[0]=(((r00*x1826*x1827))+(((-1.0)*r01*x1825*x1827))+((r11*x1825*x1828))+((npy*x1825))+(((-1.0)*npx*x1826))+(((-1.0)*r10*x1826*x1828)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1829=((0.0775)*sj0);
IkReal x1830=((0.0775)*cj0);
CheckValue<IkReal> x1832 = IKatan2WithCheck(IkReal((((r00*x1829))+(((-1.0)*r10*x1830))+(((-1.0)*npx)))),IkReal((npy+((r11*x1830))+(((-1.0)*r01*x1829)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1832.valid){
continue;
}
IkReal x1831=x1832.value;
j5array[0]=((-1.0)*x1831);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1831)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1833=IKcos(j5);
IkReal x1834=IKsin(j5);
IkReal x1835=((0.0775)*cj0);
IkReal x1836=((0.0775)*sj0);
evalcond[0]=(((r00*x1834*x1836))+(((-1.0)*npy*x1833))+(((-1.0)*r10*x1834*x1835))+(((-1.0)*npx*x1834))+((r01*x1833*x1836))+(((-1.0)*r11*x1833*x1835)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
r02=0;
npz=(((py*r12))+((pz*r22)));
rxp2_1=(px*r22);
rxp2_2=((-1.0)*px*r12);
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
IkReal x1837=((0.0775)*sj0);
IkReal x1838=((0.0775)*cj0);
j5eval[0]=((IKabs(((((-1.0)*r01*x1837))+npy+((r11*x1838)))))+(IKabs(((((-1.0)*r10*x1838))+(((-1.0)*npx))+((r00*x1837))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
r02=0;
npz=(((py*r12))+((pz*r22)));
rxp2_1=(px*r22);
rxp2_2=((-1.0)*px*r12);
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
IkReal x1839=((0.0775)*sj0);
IkReal x1840=((0.0775)*cj0);
j5eval[0]=((IKabs((((r01*x1839))+(((-1.0)*npy))+(((-1.0)*r11*x1840)))))+(IKabs(((((-1.0)*npx))+(((-1.0)*r10*x1840))+((r00*x1839))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j5]

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1841=((0.0775)*sj0);
IkReal x1842=((0.0775)*cj0);
CheckValue<IkReal> x1844 = IKatan2WithCheck(IkReal(((((-1.0)*npy))+((r01*x1841))+(((-1.0)*r11*x1842)))),IkReal(((((-1.0)*npx))+(((-1.0)*r10*x1842))+((r00*x1841)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1844.valid){
continue;
}
IkReal x1843=x1844.value;
j5array[0]=((-1.0)*x1843);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1843)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1845=IKsin(j5);
IkReal x1846=IKcos(j5);
IkReal x1847=((0.0775)*sj0);
IkReal x1848=((0.0775)*cj0);
evalcond[0]=((((-1.0)*r10*x1846*x1848))+((r11*x1845*x1848))+((r00*x1846*x1847))+((npy*x1845))+(((-1.0)*r01*x1845*x1847))+(((-1.0)*npx*x1846)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1849=((0.0775)*sj0);
IkReal x1850=((0.0775)*cj0);
CheckValue<IkReal> x1852 = IKatan2WithCheck(IkReal(((((-1.0)*npx))+((r00*x1849))+(((-1.0)*r10*x1850)))),IkReal(((((-1.0)*r01*x1849))+npy+((r11*x1850)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1852.valid){
continue;
}
IkReal x1851=x1852.value;
j5array[0]=((-1.0)*x1851);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1851)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1853=IKcos(j5);
IkReal x1854=IKsin(j5);
IkReal x1855=((0.0775)*cj0);
IkReal x1856=((0.0775)*sj0);
evalcond[0]=((((-1.0)*r11*x1853*x1855))+(((-1.0)*npy*x1853))+(((-1.0)*npx*x1854))+((r00*x1854*x1856))+(((-1.0)*r10*x1854*x1855))+((r01*x1853*x1856)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(r12);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[3];
r02=0;
npz=(pz*r22);
rxp2_1=(px*r22);
rxp2_2=0;
r12=0;
rxp2_0=((-1.0)*py*r22);
IkReal x1857=(r22*sj4);
IkReal x1858=((31.0)*sj0);
IkReal x1859=((31.0)*cj0);
j5eval[0]=x1857;
j5eval[1]=((IKabs((((r10*x1858))+((r00*x1859))+(((400.0)*rxp0_2)))))+(IKabs((((r01*x1859))+((r11*x1858))+(((400.0)*rxp1_2))))));
j5eval[2]=IKsign(x1857);
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
r02=0;
npz=(pz*r22);
rxp2_1=(px*r22);
rxp2_2=0;
r12=0;
rxp2_0=((-1.0)*py*r22);
sj4=0;
cj4=1.0;
j4=0;
j5eval[0]=((IKabs((pz*r20)))+(IKabs((pz*r21))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
CheckValue<IkReal> x1861 = IKatan2WithCheck(IkReal((((px*r01))+(((-1.0)*npy))+((py*r11)))),IkReal((((px*r00))+(((-1.0)*npx))+((py*r10)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1861.valid){
continue;
}
IkReal x1860=x1861.value;
j5array[0]=((-1.0)*x1860);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1860)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1862=IKcos(j5);
IkReal x1863=IKsin(j5);
IkReal x1864=((1.0)*x1863);
evalcond[0]=(((py*r10*x1862))+(((-1.0)*px*r01*x1864))+(((-1.0)*py*r11*x1864))+(((-1.0)*npx*x1862))+((px*r00*x1862))+((npy*x1863)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
r02=0;
npz=(pz*r22);
rxp2_1=(px*r22);
rxp2_2=0;
r12=0;
rxp2_0=((-1.0)*py*r22);
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
j5eval[0]=((IKabs((pz*r20)))+(IKabs((pz*r21))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
CheckValue<IkReal> x1866 = IKatan2WithCheck(IkReal((((px*r01))+(((-1.0)*npy))+((py*r11)))),IkReal((((px*r00))+(((-1.0)*npx))+((py*r10)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1866.valid){
continue;
}
IkReal x1865=x1866.value;
j5array[0]=((-1.0)*x1865);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1865)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1867=IKcos(j5);
IkReal x1868=IKsin(j5);
IkReal x1869=((1.0)*x1868);
evalcond[0]=(((py*r10*x1867))+(((-1.0)*px*r01*x1869))+(((-1.0)*py*r11*x1869))+(((-1.0)*npx*x1867))+((px*r00*x1867))+((npy*x1868)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1870=((31.0)*cj0);
IkReal x1871=((31.0)*sj0);
CheckValue<IkReal> x1872=IKPowWithIntegerCheck(IKsign((r22*sj4)),-1);
if(!x1872.valid){
continue;
}
CheckValue<IkReal> x1873 = IKatan2WithCheck(IkReal(((((400.0)*rxp0_2))+((r00*x1870))+((r10*x1871)))),IkReal((((r01*x1870))+(((400.0)*rxp1_2))+((r11*x1871)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1873.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1872.value)))+(x1873.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1874=IKsin(j5);
IkReal x1875=IKcos(j5);
IkReal x1876=((0.0775)*cj0);
IkReal x1877=((0.1075)*sj4);
IkReal x1878=((0.215)*sj4);
IkReal x1879=((0.0775)*sj0);
IkReal x1880=(cj4*r22);
IkReal x1881=((1.0)*npx);
IkReal x1882=(r10*x1875);
IkReal x1883=(npy*x1874);
IkReal x1884=(r01*x1874);
IkReal x1885=(r00*x1875);
IkReal x1886=(r11*x1874);
evalcond[0]=(((x1877*x1884))+(((-1.0)*px))+x1879+(((-1.0)*x1877*x1885)));
evalcond[1]=(((x1877*x1886))+(((-1.0)*x1876))+(((-1.0)*py))+(((-1.0)*x1877*x1882)));
evalcond[2]=((((0.1075)*x1880))+(((-1.0)*r20*x1875*x1877))+(((-1.0)*pz))+((r21*x1874*x1877)));
evalcond[3]=((-0.00555)+((x1878*x1883))+(((-1.0)*pp))+(((-1.0)*npx*x1875*x1878))+(((0.215)*pz*x1880)));
evalcond[4]=((((-1.0)*r10*x1874*x1876))+((r01*x1875*x1879))+(((-1.0)*r11*x1875*x1876))+(((-1.0)*npy*x1875))+((r00*x1874*x1879))+(((-1.0)*x1874*x1881)));
evalcond[5]=(((x1879*x1885))+(((-1.0)*x1876*x1882))+(((-1.0)*x1879*x1884))+(((-1.0)*x1877))+(((-1.0)*x1875*x1881))+((x1876*x1886))+x1883);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1887=((31.0)*cj0);
IkReal x1888=((31.0)*sj0);
IkReal x1889=((43.0)*cj4*r12);
CheckValue<IkReal> x1890=IKPowWithIntegerCheck(IKsign((r22*sj4)),-1);
if(!x1890.valid){
continue;
}
CheckValue<IkReal> x1891 = IKatan2WithCheck(IkReal((((r00*x1887))+(((400.0)*rxp0_2))+((r10*x1888))+(((-1.0)*r00*x1889)))),IkReal((((r01*x1887))+(((-1.0)*r01*x1889))+((r11*x1888))+(((400.0)*rxp1_2)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1891.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1890.value)))+(x1891.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1892=IKsin(j5);
IkReal x1893=IKcos(j5);
IkReal x1894=((0.215)*cj4);
IkReal x1895=((0.0775)*cj0);
IkReal x1896=((0.1075)*sj4);
IkReal x1897=((0.215)*sj4);
IkReal x1898=((0.0775)*sj0);
IkReal x1899=((1.0)*npx);
IkReal x1900=((0.1075)*cj4);
IkReal x1901=(r10*x1893);
IkReal x1902=(npy*x1892);
IkReal x1903=(r01*x1892);
IkReal x1904=(r00*x1893);
IkReal x1905=(r11*x1892);
evalcond[0]=((((-1.0)*px))+x1898+(((-1.0)*x1896*x1904))+((x1896*x1903)));
evalcond[1]=(((r21*x1892*x1896))+(((-1.0)*r20*x1893*x1896))+(((-1.0)*pz))+((r22*x1900)));
evalcond[2]=(((r12*x1900))+(((-1.0)*py))+(((-1.0)*x1896*x1901))+(((-1.0)*x1895))+((x1896*x1905)));
evalcond[3]=((-0.00555)+(((-1.0)*npx*x1893*x1897))+((py*r12*x1894))+(((-1.0)*pp))+((pz*r22*x1894))+((x1897*x1902)));
evalcond[4]=((((-1.0)*x1892*x1899))+((r01*x1893*x1898))+(((-1.0)*r11*x1893*x1895))+(((-1.0)*r10*x1892*x1895))+((r00*x1892*x1898))+(((-1.0)*npy*x1893)));
evalcond[5]=((((-1.0)*x1893*x1899))+((x1898*x1904))+(((-1.0)*x1898*x1903))+x1902+((x1895*x1905))+(((-1.0)*x1896))+(((-1.0)*x1895*x1901)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1906=((31.0)*sj0);
IkReal x1907=((43.0)*cj4*r22);
CheckValue<IkReal> x1908 = IKatan2WithCheck(IkReal(((((-400.0)*rxp0_1))+((r20*x1906))+(((-1.0)*r00*x1907)))),IkReal(((((-400.0)*rxp1_1))+((r21*x1906))+(((-1.0)*r01*x1907)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1908.valid){
continue;
}
CheckValue<IkReal> x1909=IKPowWithIntegerCheck(IKsign((r12*sj4)),-1);
if(!x1909.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(x1908.value)+(((-1.5707963267949)*(x1909.value))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1910=IKsin(j5);
IkReal x1911=IKcos(j5);
IkReal x1912=((0.215)*cj4);
IkReal x1913=((0.0775)*cj0);
IkReal x1914=((0.1075)*sj4);
IkReal x1915=((0.215)*sj4);
IkReal x1916=((0.0775)*sj0);
IkReal x1917=((1.0)*npx);
IkReal x1918=((0.1075)*cj4);
IkReal x1919=(r10*x1911);
IkReal x1920=(npy*x1910);
IkReal x1921=(r01*x1910);
IkReal x1922=(r00*x1911);
IkReal x1923=(r11*x1910);
evalcond[0]=((((-1.0)*x1914*x1922))+(((-1.0)*px))+x1916+((x1914*x1921)));
evalcond[1]=((((-1.0)*r20*x1911*x1914))+((r22*x1918))+(((-1.0)*pz))+((r21*x1910*x1914)));
evalcond[2]=((((-1.0)*x1914*x1919))+(((-1.0)*py))+((r12*x1918))+((x1914*x1923))+(((-1.0)*x1913)));
evalcond[3]=((-0.00555)+(((-1.0)*npx*x1911*x1915))+((pz*r22*x1912))+(((-1.0)*pp))+((py*r12*x1912))+((x1915*x1920)));
evalcond[4]=((((-1.0)*x1910*x1917))+((r01*x1911*x1916))+((r00*x1910*x1916))+(((-1.0)*npy*x1911))+(((-1.0)*r10*x1910*x1913))+(((-1.0)*r11*x1911*x1913)));
evalcond[5]=((((-1.0)*x1911*x1917))+(((-1.0)*x1916*x1921))+x1920+((x1916*x1922))+(((-1.0)*x1913*x1919))+((x1913*x1923))+(((-1.0)*x1914)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1924=((200.0)*pp);
IkReal x1925=((43.0)*npy);
IkReal x1926=(cj4*r22);
IkReal x1927=((400.0)*pz);
IkReal x1928=((43.0)*npx);
IkReal x1929=((43.0)*cj4*npz);
CheckValue<IkReal> x1930=IKPowWithIntegerCheck(IKsign(((((-1.0)*r21*sj4*x1928))+((r20*sj4*x1925)))),-1);
if(!x1930.valid){
continue;
}
CheckValue<IkReal> x1931 = IKatan2WithCheck(IkReal(((((-1.0)*npx*x1927))+(((-1.0)*r20*x1929))+((r20*x1924))+(((1.11)*r20))+((x1926*x1928)))),IkReal(((((-1.0)*npy*x1927))+(((-1.0)*r21*x1929))+(((1.11)*r21))+((r21*x1924))+((x1925*x1926)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1931.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1930.value)))+(x1931.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1932=IKsin(j5);
IkReal x1933=IKcos(j5);
IkReal x1934=((0.0775)*cj0);
IkReal x1935=((0.1075)*sj4);
IkReal x1936=((0.215)*sj4);
IkReal x1937=((0.0775)*sj0);
IkReal x1938=((1.0)*npx);
IkReal x1939=((0.1075)*cj4);
IkReal x1940=(r10*x1933);
IkReal x1941=(npy*x1932);
IkReal x1942=(r01*x1932);
IkReal x1943=(r00*x1933);
IkReal x1944=(r11*x1932);
evalcond[0]=((((-1.0)*r20*x1933*x1935))+((r21*x1932*x1935))+(((-1.0)*pz))+((r22*x1939)));
evalcond[1]=((-0.00555)+(((0.215)*cj4*npz))+(((-1.0)*npx*x1933*x1936))+((x1936*x1941))+(((-1.0)*pp)));
evalcond[2]=(((r02*x1939))+(((-1.0)*px))+((x1935*x1942))+(((-1.0)*x1935*x1943))+x1937);
evalcond[3]=((((-1.0)*py))+((x1935*x1944))+(((-1.0)*x1935*x1940))+((r12*x1939))+(((-1.0)*x1934)));
evalcond[4]=((((-1.0)*r10*x1932*x1934))+((r00*x1932*x1937))+(((-1.0)*npy*x1933))+(((-1.0)*r11*x1933*x1934))+(((-1.0)*x1932*x1938))+((r01*x1933*x1937)));
evalcond[5]=((((-1.0)*x1937*x1942))+(((-1.0)*x1933*x1938))+((x1937*x1943))+x1941+(((-1.0)*x1934*x1940))+((x1934*x1944))+(((-1.0)*x1935)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1945=((43.0)*cj4);
IkReal x1946=((31.0)*sj0);
CheckValue<IkReal> x1947 = IKatan2WithCheck(IkReal((((r20*x1946))+(((-400.0)*rxp0_1))+(((-1.0)*r11*x1945)))),IkReal(((((-400.0)*rxp1_1))+((r10*x1945))+((r21*x1946)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1947.valid){
continue;
}
CheckValue<IkReal> x1948=IKPowWithIntegerCheck(IKsign((r12*sj4)),-1);
if(!x1948.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(x1947.value)+(((-1.5707963267949)*(x1948.value))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1949=IKsin(j5);
IkReal x1950=IKcos(j5);
IkReal x1951=((0.0775)*cj0);
IkReal x1952=((0.1075)*sj4);
IkReal x1953=((0.215)*sj4);
IkReal x1954=((0.0775)*sj0);
IkReal x1955=((1.0)*npx);
IkReal x1956=((0.1075)*cj4);
IkReal x1957=(r10*x1950);
IkReal x1958=(npy*x1949);
IkReal x1959=(r01*x1949);
IkReal x1960=(r00*x1950);
IkReal x1961=(r11*x1949);
evalcond[0]=((((-1.0)*pz))+((r22*x1956))+((r21*x1949*x1952))+(((-1.0)*r20*x1950*x1952)));
evalcond[1]=((-0.00555)+(((0.215)*cj4*npz))+(((-1.0)*pp))+((x1953*x1958))+(((-1.0)*npx*x1950*x1953)));
evalcond[2]=((((-1.0)*x1952*x1960))+((x1952*x1959))+(((-1.0)*px))+x1954+((r02*x1956)));
evalcond[3]=((((-1.0)*x1951))+(((-1.0)*x1952*x1957))+((r12*x1956))+(((-1.0)*py))+((x1952*x1961)));
evalcond[4]=((((-1.0)*x1949*x1955))+(((-1.0)*r10*x1949*x1951))+((r01*x1950*x1954))+(((-1.0)*npy*x1950))+(((-1.0)*r11*x1950*x1951))+((r00*x1949*x1954)));
evalcond[5]=((((-1.0)*x1952))+(((-1.0)*x1954*x1959))+(((-1.0)*x1950*x1955))+((x1951*x1961))+(((-1.0)*x1951*x1957))+((x1954*x1960))+x1958);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1962=((31.0)*cj0);
IkReal x1963=((43.0)*cj4);
CheckValue<IkReal> x1964=IKPowWithIntegerCheck(IKsign((r02*sj4)),-1);
if(!x1964.valid){
continue;
}
CheckValue<IkReal> x1965 = IKatan2WithCheck(IkReal(((((400.0)*rxp0_0))+((r01*x1963))+(((-1.0)*r20*x1962)))),IkReal(((((-1.0)*r00*x1963))+(((-1.0)*r21*x1962))+(((400.0)*rxp1_0)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1965.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1964.value)))+(x1965.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1966=IKsin(j5);
IkReal x1967=IKcos(j5);
IkReal x1968=((0.0775)*cj0);
IkReal x1969=((0.1075)*sj4);
IkReal x1970=((0.215)*sj4);
IkReal x1971=((0.0775)*sj0);
IkReal x1972=((1.0)*npx);
IkReal x1973=((0.1075)*cj4);
IkReal x1974=(r10*x1967);
IkReal x1975=(npy*x1966);
IkReal x1976=(r01*x1966);
IkReal x1977=(r00*x1967);
IkReal x1978=(r11*x1966);
evalcond[0]=(((r21*x1966*x1969))+(((-1.0)*r20*x1967*x1969))+(((-1.0)*pz))+((r22*x1973)));
evalcond[1]=((-0.00555)+(((0.215)*cj4*npz))+(((-1.0)*npx*x1967*x1970))+((x1970*x1975))+(((-1.0)*pp)));
evalcond[2]=(((x1969*x1976))+((r02*x1973))+(((-1.0)*px))+x1971+(((-1.0)*x1969*x1977)));
evalcond[3]=(((x1969*x1978))+((r12*x1973))+(((-1.0)*x1968))+(((-1.0)*py))+(((-1.0)*x1969*x1974)));
evalcond[4]=((((-1.0)*r10*x1966*x1968))+((r01*x1967*x1971))+((r00*x1966*x1971))+(((-1.0)*npy*x1967))+(((-1.0)*x1966*x1972))+(((-1.0)*r11*x1967*x1968)));
evalcond[5]=(((x1971*x1977))+(((-1.0)*x1969))+(((-1.0)*x1968*x1974))+(((-1.0)*x1971*x1976))+x1975+(((-1.0)*x1967*x1972))+((x1968*x1978)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}
}
}

}

}
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x175=((1.0)*sj4);
IkReal x176=((1.0)*cj4);
IkReal x177=((1.0)*sj5);
IkReal x178=((1.0)*sj0);
IkReal x179=((1.0)*cj5);
IkReal x180=(((r11*sj0))+((cj0*r01)));
IkReal x181=(((r10*sj0))+((cj0*r00)));
IkReal x182=(((r12*sj0))+((cj0*r02)));
IkReal x183=(((cj5*r20))+(((-1.0)*r21*x177)));
IkReal x184=((((-1.0)*r00*x178))+((cj0*r10)));
IkReal x185=((((-1.0)*r01*x178))+((cj0*r11)));
IkReal x186=((((-1.0)*r02*x178))+((cj0*r12)));
IkReal x187=((1.0)*x186);
IkReal x188=((((-1.0)*x179*x181))+((sj5*x180)));
IkReal x189=((((-1.0)*x179*x184))+((sj5*x185)));
new_r00=((((-1.0)*x175*x182))+((cj4*x188)));
new_r01=(((cj5*x180))+((sj5*x181)));
new_r02=((((-1.0)*x176*x182))+(((-1.0)*x175*x188)));
new_r10=(((r22*sj4))+((cj4*x183)));
new_r11=((((-1.0)*r20*x177))+(((-1.0)*r21*x179)));
new_r12=(((cj4*r22))+(((-1.0)*x175*x183)));
new_r20=((((-1.0)*x175*x186))+((cj4*x189)));
new_r21=(((cj5*x185))+((sj5*x184)));
new_r22=((((-1.0)*x176*x186))+(((-1.0)*x175*x189)));
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
sj2array[0]=((-1.0)*new_r22);
if( sj2array[0] >= -1-IKFAST_SINCOS_THRESH && sj2array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j2valid[0] = j2valid[1] = true;
    j2array[0] = IKasin(sj2array[0]);
    cj2array[0] = IKcos(j2array[0]);
    sj2array[1] = sj2array[0];
    j2array[1] = j2array[0] > 0 ? (IKPI-j2array[0]) : (-IKPI-j2array[0]);
    cj2array[1] = -cj2array[0];
}
else if( isnan(sj2array[0]) )
{
    // probably any value will work
    j2valid[0] = true;
    cj2array[0] = 1; sj2array[0] = 0; j2array[0] = 0;
}
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

{
IkReal j3eval[3];
j3eval[0]=cj2;
j3eval[1]=IKsign(cj2);
j3eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
j1eval[0]=cj2;
j1eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j1eval[2]=IKsign(cj2);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
j1eval[0]=cj2;
j1eval[1]=new_r02;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j3mul = 1;
j3=0;
j1mul=1.0;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1=IKatan2(new_r01, ((-1.0)*new_r11));
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].fmul = j1mul;
vinfos[1].freeind = 0;
vinfos[1].maxsolutions = 0;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].fmul = j3mul;
vinfos[3].freeind = 0;
vinfos[3].maxsolutions = 0;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(1);
vfree[0] = 3;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j3mul = 1;
j3=0;
j1mul=-1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1=IKatan2(((-1.0)*new_r01), new_r11);
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].fmul = j1mul;
vinfos[1].freeind = 0;
vinfos[1].maxsolutions = 0;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].fmul = j3mul;
vinfos[3].freeind = 0;
vinfos[3].maxsolutions = 0;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(1);
vfree[0] = 3;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
IkReal x190=new_r22*new_r22;
IkReal x191=((16.0)*new_r10);
IkReal x192=((16.0)*new_r01);
IkReal x193=((16.0)*new_r00);
IkReal x194=(new_r11*new_r22);
IkReal x195=((8.0)*new_r00);
IkReal x196=(x190*x191);
IkReal x197=(x190*x192);
j1eval[0]=((IKabs(((((-32.0)*new_r11*x190))+((new_r22*x193))+(((16.0)*new_r11)))))+(IKabs(((((-1.0)*x197))+x192)))+(IKabs(((((-8.0)*x194))+((x190*x195)))))+(IKabs((((new_r22*x195))+(((-8.0)*new_r11)))))+(IKabs(((((-1.0)*x192))+x197)))+(IKabs(((((-1.0)*x191))+x196)))+(IKabs(((((-1.0)*x196))+x191)))+(IKabs(((((32.0)*new_r00))+(((-1.0)*x190*x193))+(((-16.0)*x194))))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j3]

} else
{
IkReal op[4+1], zeror[4];
int numroots;
IkReal j1evalpoly[1];
IkReal x198=new_r22*new_r22;
IkReal x199=((16.0)*new_r01);
IkReal x200=(new_r00*new_r22);
IkReal x201=(x198*x199);
IkReal x202=((((8.0)*x200))+(((-8.0)*new_r11)));
op[0]=x202;
op[1]=((((-1.0)*x199))+x201);
op[2]=((((-32.0)*new_r11*x198))+(((16.0)*x200))+(((16.0)*new_r11)));
op[3]=(x199+(((-1.0)*x201)));
op[4]=x202;
polyroots4(op,zeror,numroots);
IkReal j1array[4], cj1array[4], sj1array[4], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[4]={true,true,true,true};
_nj1 = 4;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x203=new_r22*new_r22;
IkReal x204=((16.0)*new_r10);
IkReal x205=(new_r11*new_r22);
IkReal x206=((8.0)*x205);
IkReal x207=(new_r00*x203);
IkReal x208=((8.0)*x207);
IkReal x209=(x203*x204);
j1evalpoly[0]=(((htj1*(((((-1.0)*x204))+x209))))+(((htj1*htj1*htj1*htj1)*(((((-1.0)*x206))+x208))))+(((-1.0)*x206))+x208+(((htj1*htj1*htj1)*(((((-1.0)*x209))+x204))))+(((htj1*htj1)*(((((32.0)*new_r00))+(((-16.0)*x207))+(((-16.0)*x205)))))));
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j3eval[3];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
IkReal x210=new_r22*new_r22;
IkReal x211=cj1*cj1;
IkReal x212=(new_r22*sj1);
IkReal x213=(((x210*x211))+(((-1.0)*x210))+(((-1.0)*x211)));
j3eval[0]=x213;
j3eval[1]=((IKabs((((new_r01*x212))+(((-1.0)*cj1*new_r00)))))+(IKabs((((cj1*new_r01))+((new_r00*x212))))));
j3eval[2]=IKsign(x213);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j3eval[0]=new_r22;
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j3eval[0]=cj1;
j3eval[1]=new_r22;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-1.0)*new_r11), new_r10);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x214=IKsin(j3);
IkReal x215=IKcos(j3);
IkReal x216=((1.0)*new_r22);
IkReal x217=((1.0)*x215);
IkReal x218=((1.0)*x214);
evalcond[0]=(x214+new_r11);
evalcond[1]=(new_r10+(((-1.0)*x217)));
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x214*x216)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x215*x216)));
evalcond[4]=((((-1.0)*x218))+(((-1.0)*new_r00*x216)));
evalcond[5]=((((-1.0)*new_r01*x216))+(((-1.0)*x217)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(new_r11, ((-1.0)*new_r10));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x219=IKsin(j3);
IkReal x220=IKcos(j3);
IkReal x221=((1.0)*x220);
IkReal x222=((1.0)*x219);
evalcond[0]=(x219+(((-1.0)*new_r11)));
evalcond[1]=((((-1.0)*new_r22*x222))+new_r00);
evalcond[2]=((((-1.0)*new_r22*x221))+new_r01);
evalcond[3]=((((-1.0)*new_r10))+(((-1.0)*x221)));
evalcond[4]=(((new_r00*new_r22))+(((-1.0)*x222)));
evalcond[5]=(((new_r01*new_r22))+(((-1.0)*x221)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x223=new_r22*new_r22;
CheckValue<IkReal> x224=IKPowWithIntegerCheck(((-1.0)+x223),-1);
if(!x224.valid){
continue;
}
if(((x223*(x224.value))) < -0.00001)
continue;
IkReal gconst88=IKsqrt((x223*(x224.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj1+(((-1.0)*gconst88)))))+(IKabs(((-1.0)+(IKsign(sj1)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if((((1.0)+(((-1.0)*(gconst88*gconst88))))) < -0.00001)
continue;
IkReal x225=IKsqrt(((1.0)+(((-1.0)*(gconst88*gconst88)))));
if( IKabs(((((-1.0)*new_r11*x225))+(((-1.0)*gconst88*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((gconst88*new_r00))+((new_r10*x225)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r11*x225))+(((-1.0)*gconst88*new_r01))))+IKsqr((((gconst88*new_r00))+((new_r10*x225))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*new_r11*x225))+(((-1.0)*gconst88*new_r01))), (((gconst88*new_r00))+((new_r10*x225))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[10];
IkReal x226=IKcos(j3);
IkReal x227=IKsin(j3);
IkReal x228=(gconst88*new_r11);
IkReal x229=(gconst88*new_r10);
IkReal x230=(gconst88*new_r22);
IkReal x231=((1.0)*new_r00);
IkReal x232=((1.0)*new_r01);
IkReal x233=((1.0)*x226);
IkReal x234=((1.0)*x227);
IkReal x235=x225;
IkReal x236=(new_r22*x235);
IkReal x237=(x227*x235);
evalcond[0]=(((gconst88*new_r01))+((new_r11*x235))+x227);
evalcond[1]=(((new_r10*x235))+((gconst88*new_r00))+(((-1.0)*x233)));
evalcond[2]=(((gconst88*x227))+((x226*x236))+new_r01);
evalcond[3]=((((-1.0)*x230*x233))+x237+new_r11);
evalcond[4]=((((-1.0)*new_r22*x234))+x229+(((-1.0)*x231*x235)));
evalcond[5]=((((-1.0)*new_r22*x233))+x228+(((-1.0)*x232*x235)));
evalcond[6]=(((x227*x236))+new_r00+(((-1.0)*gconst88*x233)));
evalcond[7]=((((-1.0)*x233*x235))+(((-1.0)*x230*x234))+new_r10);
evalcond[8]=((((-1.0)*x234))+(((-1.0)*x231*x236))+((new_r22*x229)));
evalcond[9]=((((-1.0)*x233))+((new_r22*x228))+(((-1.0)*x232*x236)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x238=new_r22*new_r22;
CheckValue<IkReal> x239=IKPowWithIntegerCheck(((-1.0)+x238),-1);
if(!x239.valid){
continue;
}
if(((x238*(x239.value))) < -0.00001)
continue;
IkReal gconst88=IKsqrt((x238*(x239.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj1+(((-1.0)*gconst88)))))+(IKabs(((1.0)+(IKsign(sj1)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if((((1.0)+(((-1.0)*(gconst88*gconst88))))) < -0.00001)
continue;
IkReal x240=IKsqrt(((1.0)+(((-1.0)*(gconst88*gconst88)))));
if( IKabs(((((-1.0)*gconst88*new_r01))+((new_r11*x240)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((gconst88*new_r00))+(((-1.0)*new_r10*x240)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*gconst88*new_r01))+((new_r11*x240))))+IKsqr((((gconst88*new_r00))+(((-1.0)*new_r10*x240))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*gconst88*new_r01))+((new_r11*x240))), (((gconst88*new_r00))+(((-1.0)*new_r10*x240))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[10];
IkReal x241=IKsin(j3);
IkReal x242=IKcos(j3);
IkReal x243=(gconst88*new_r11);
IkReal x244=(gconst88*new_r10);
IkReal x245=((1.0)*new_r22);
IkReal x246=((1.0)*x242);
IkReal x247=(gconst88*x241);
IkReal x248=((1.0)*x241);
IkReal x249=x240;
IkReal x250=(new_r22*x249);
IkReal x251=((1.0)*x249);
evalcond[0]=(((gconst88*new_r01))+(((-1.0)*new_r11*x251))+x241);
evalcond[1]=((((-1.0)*new_r10*x251))+((gconst88*new_r00))+(((-1.0)*x246)));
evalcond[2]=((((-1.0)*x241*x245))+x244+((new_r00*x249)));
evalcond[3]=((((-1.0)*x242*x245))+x243+((new_r01*x249)));
evalcond[4]=(x247+(((-1.0)*x242*x245*x249))+new_r01);
evalcond[5]=(((x242*x249))+(((-1.0)*x245*x247))+new_r10);
evalcond[6]=(((new_r00*x250))+((new_r22*x244))+(((-1.0)*x248)));
evalcond[7]=(((new_r01*x250))+((new_r22*x243))+(((-1.0)*x246)));
evalcond[8]=((((-1.0)*x248*x249))+(((-1.0)*gconst88*x242*x245))+new_r11);
evalcond[9]=((((-1.0)*gconst88*x246))+new_r00+(((-1.0)*x241*x245*x249)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x252=new_r22*new_r22;
CheckValue<IkReal> x253=IKPowWithIntegerCheck(((-1.0)+x252),-1);
if(!x253.valid){
continue;
}
if(((x252*(x253.value))) < -0.00001)
continue;
IkReal gconst89=((-1.0)*(IKsqrt((x252*(x253.value)))));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.0)+(IKsign(sj1)))))+(IKabs((cj1+(((-1.0)*gconst89)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if((((1.0)+(((-1.0)*(gconst89*gconst89))))) < -0.00001)
continue;
IkReal x254=IKsqrt(((1.0)+(((-1.0)*(gconst89*gconst89)))));
if( IKabs(((((-1.0)*new_r11*x254))+(((-1.0)*gconst89*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r10*x254))+((gconst89*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r11*x254))+(((-1.0)*gconst89*new_r01))))+IKsqr((((new_r10*x254))+((gconst89*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*new_r11*x254))+(((-1.0)*gconst89*new_r01))), (((new_r10*x254))+((gconst89*new_r00))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[10];
IkReal x255=IKsin(j3);
IkReal x256=IKcos(j3);
IkReal x257=(gconst89*new_r10);
IkReal x258=(gconst89*new_r22);
IkReal x259=((1.0)*new_r01);
IkReal x260=((1.0)*new_r00);
IkReal x261=((1.0)*x256);
IkReal x262=((1.0)*x255);
IkReal x263=x254;
IkReal x264=(new_r22*x263);
evalcond[0]=(x255+((gconst89*new_r01))+((new_r11*x263)));
evalcond[1]=(((gconst89*new_r00))+(((-1.0)*x261))+((new_r10*x263)));
evalcond[2]=(((x256*x264))+new_r01+((gconst89*x255)));
evalcond[3]=((((-1.0)*x258*x261))+((x255*x263))+new_r11);
evalcond[4]=((((-1.0)*new_r22*x262))+x257+(((-1.0)*x260*x263)));
evalcond[5]=((((-1.0)*x259*x263))+(((-1.0)*new_r22*x261))+((gconst89*new_r11)));
evalcond[6]=(((x255*x264))+(((-1.0)*gconst89*x261))+new_r00);
evalcond[7]=((((-1.0)*x258*x262))+(((-1.0)*x261*x263))+new_r10);
evalcond[8]=(((new_r22*x257))+(((-1.0)*x262))+(((-1.0)*x260*x264)));
evalcond[9]=((((-1.0)*x259*x264))+((new_r11*x258))+(((-1.0)*x261)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x265=new_r22*new_r22;
CheckValue<IkReal> x266=IKPowWithIntegerCheck(((-1.0)+x265),-1);
if(!x266.valid){
continue;
}
if(((x265*(x266.value))) < -0.00001)
continue;
IkReal gconst89=((-1.0)*(IKsqrt((x265*(x266.value)))));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.0)+(IKsign(sj1)))))+(IKabs((cj1+(((-1.0)*gconst89)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if((((1.0)+(((-1.0)*(gconst89*gconst89))))) < -0.00001)
continue;
IkReal x267=IKsqrt(((1.0)+(((-1.0)*(gconst89*gconst89)))));
if( IKabs(((((-1.0)*gconst89*new_r01))+((new_r11*x267)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r10*x267))+((gconst89*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*gconst89*new_r01))+((new_r11*x267))))+IKsqr(((((-1.0)*new_r10*x267))+((gconst89*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*gconst89*new_r01))+((new_r11*x267))), ((((-1.0)*new_r10*x267))+((gconst89*new_r00))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[10];
IkReal x268=IKsin(j3);
IkReal x269=IKcos(j3);
IkReal x270=(gconst89*new_r10);
IkReal x271=(gconst89*new_r22);
IkReal x272=((1.0)*x269);
IkReal x273=((1.0)*x268);
IkReal x274=x267;
IkReal x275=(new_r00*x274);
IkReal x276=((1.0)*x274);
IkReal x277=(new_r01*x274);
evalcond[0]=(x268+(((-1.0)*new_r11*x276))+((gconst89*new_r01)));
evalcond[1]=((((-1.0)*new_r10*x276))+(((-1.0)*x272))+((gconst89*new_r00)));
evalcond[2]=((((-1.0)*new_r22*x273))+x275+x270);
evalcond[3]=((((-1.0)*new_r22*x272))+x277+((gconst89*new_r11)));
evalcond[4]=(((gconst89*x268))+(((-1.0)*new_r22*x272*x274))+new_r01);
evalcond[5]=((((-1.0)*x271*x273))+new_r10+((x269*x274)));
evalcond[6]=(((new_r22*x270))+((new_r22*x275))+(((-1.0)*x273)));
evalcond[7]=(((new_r22*x277))+(((-1.0)*x272))+((new_r11*x271)));
evalcond[8]=((((-1.0)*x273*x274))+(((-1.0)*x271*x272))+new_r11);
evalcond[9]=((((-1.0)*new_r22*x273*x274))+(((-1.0)*gconst89*x272))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x278=((1.0)*cj1*new_r01);
CheckValue<IkReal> x279=IKPowWithIntegerCheck(cj1,-1);
if(!x279.valid){
continue;
}
CheckValue<IkReal> x280=IKPowWithIntegerCheck(new_r22,-1);
if(!x280.valid){
continue;
}
if( IKabs(((((-1.0)*x278))+(((-1.0)*new_r11*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x279.value)*(x280.value)*(((((-1.0)*sj1*x278))+((new_r11*(cj1*cj1))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x278))+(((-1.0)*new_r11*sj1))))+IKsqr(((x279.value)*(x280.value)*(((((-1.0)*sj1*x278))+((new_r11*(cj1*cj1)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*x278))+(((-1.0)*new_r11*sj1))), ((x279.value)*(x280.value)*(((((-1.0)*sj1*x278))+((new_r11*(cj1*cj1)))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[10];
IkReal x281=IKcos(j3);
IkReal x282=IKsin(j3);
IkReal x283=(cj1*new_r22);
IkReal x284=(new_r22*sj1);
IkReal x285=((1.0)*new_r00);
IkReal x286=((1.0)*new_r01);
IkReal x287=((1.0)*x281);
IkReal x288=(cj1*x282);
IkReal x289=((1.0)*x282);
evalcond[0]=(((new_r11*sj1))+((cj1*new_r01))+x282);
evalcond[1]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x287)));
evalcond[2]=(x288+new_r01+((x281*x284)));
evalcond[3]=(new_r11+((sj1*x282))+(((-1.0)*x283*x287)));
evalcond[4]=((((-1.0)*sj1*x285))+(((-1.0)*new_r22*x289))+((cj1*new_r10)));
evalcond[5]=((((-1.0)*sj1*x286))+(((-1.0)*new_r22*x287))+((cj1*new_r11)));
evalcond[6]=((((-1.0)*cj1*x287))+new_r00+((x282*x284)));
evalcond[7]=((((-1.0)*sj1*x287))+new_r10+(((-1.0)*x283*x289)));
evalcond[8]=((((-1.0)*x284*x285))+(((-1.0)*x289))+((new_r10*x283)));
evalcond[9]=((((-1.0)*x284*x286))+(((-1.0)*x287))+((new_r11*x283)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x290=((1.0)*new_r01);
CheckValue<IkReal> x291=IKPowWithIntegerCheck(new_r22,-1);
if(!x291.valid){
continue;
}
if( IKabs(((((-1.0)*cj1*x290))+(((-1.0)*new_r11*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x291.value)*((((cj1*new_r11))+(((-1.0)*sj1*x290)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj1*x290))+(((-1.0)*new_r11*sj1))))+IKsqr(((x291.value)*((((cj1*new_r11))+(((-1.0)*sj1*x290))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*cj1*x290))+(((-1.0)*new_r11*sj1))), ((x291.value)*((((cj1*new_r11))+(((-1.0)*sj1*x290))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[10];
IkReal x292=IKcos(j3);
IkReal x293=IKsin(j3);
IkReal x294=(cj1*new_r22);
IkReal x295=(new_r22*sj1);
IkReal x296=((1.0)*new_r00);
IkReal x297=((1.0)*new_r01);
IkReal x298=((1.0)*x292);
IkReal x299=(cj1*x293);
IkReal x300=((1.0)*x293);
evalcond[0]=(((new_r11*sj1))+((cj1*new_r01))+x293);
evalcond[1]=(((new_r10*sj1))+(((-1.0)*x298))+((cj1*new_r00)));
evalcond[2]=(x299+new_r01+((x292*x295)));
evalcond[3]=(((sj1*x293))+new_r11+(((-1.0)*x294*x298)));
evalcond[4]=((((-1.0)*new_r22*x300))+((cj1*new_r10))+(((-1.0)*sj1*x296)));
evalcond[5]=(((cj1*new_r11))+(((-1.0)*sj1*x297))+(((-1.0)*new_r22*x298)));
evalcond[6]=((((-1.0)*cj1*x298))+new_r00+((x293*x295)));
evalcond[7]=((((-1.0)*x294*x300))+(((-1.0)*sj1*x298))+new_r10);
evalcond[8]=(((new_r10*x294))+(((-1.0)*x295*x296))+(((-1.0)*x300)));
evalcond[9]=(((new_r11*x294))+(((-1.0)*x298))+(((-1.0)*x295*x297)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x301=new_r22*new_r22;
IkReal x302=cj1*cj1;
IkReal x303=(new_r22*sj1);
CheckValue<IkReal> x304 = IKatan2WithCheck(IkReal((((new_r00*x303))+((cj1*new_r01)))),IkReal((((new_r01*x303))+(((-1.0)*cj1*new_r00)))),IKFAST_ATAN2_MAGTHRESH);
if(!x304.valid){
continue;
}
CheckValue<IkReal> x305=IKPowWithIntegerCheck(IKsign((((x301*x302))+(((-1.0)*x301))+(((-1.0)*x302)))),-1);
if(!x305.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x304.value)+(((1.5707963267949)*(x305.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[10];
IkReal x306=IKcos(j3);
IkReal x307=IKsin(j3);
IkReal x308=(cj1*new_r22);
IkReal x309=(new_r22*sj1);
IkReal x310=((1.0)*new_r00);
IkReal x311=((1.0)*new_r01);
IkReal x312=((1.0)*x306);
IkReal x313=(cj1*x307);
IkReal x314=((1.0)*x307);
evalcond[0]=(((new_r11*sj1))+((cj1*new_r01))+x307);
evalcond[1]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x312)));
evalcond[2]=(x313+new_r01+((x306*x309)));
evalcond[3]=((((-1.0)*x308*x312))+new_r11+((sj1*x307)));
evalcond[4]=((((-1.0)*sj1*x310))+((cj1*new_r10))+(((-1.0)*new_r22*x314)));
evalcond[5]=((((-1.0)*sj1*x311))+((cj1*new_r11))+(((-1.0)*new_r22*x312)));
evalcond[6]=((((-1.0)*cj1*x312))+new_r00+((x307*x309)));
evalcond[7]=((((-1.0)*sj1*x312))+(((-1.0)*x308*x314))+new_r10);
evalcond[8]=(((new_r10*x308))+(((-1.0)*x314))+(((-1.0)*x309*x310)));
evalcond[9]=(((new_r11*x308))+(((-1.0)*x312))+(((-1.0)*x309*x311)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x316=IKPowWithIntegerCheck(cj2,-1);
if(!x316.valid){
continue;
}
IkReal x315=x316.value;
CheckValue<IkReal> x317=IKPowWithIntegerCheck(new_r02,-1);
if(!x317.valid){
continue;
}
CheckValue<IkReal> x318=IKPowWithIntegerCheck(x315,-2);
if(!x318.valid){
continue;
}
if( IKabs((x315*(x317.value)*(((x318.value)+(((-1.0)*(new_r12*new_r12))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r12*x315)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x315*(x317.value)*(((x318.value)+(((-1.0)*(new_r12*new_r12)))))))+IKsqr(((-1.0)*new_r12*x315))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((x315*(x317.value)*(((x318.value)+(((-1.0)*(new_r12*new_r12)))))), ((-1.0)*new_r12*x315));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x319=IKsin(j1);
IkReal x320=IKcos(j1);
IkReal x321=((1.0)*x319);
IkReal x322=(cj2*x320);
IkReal x323=(new_r12*x320);
evalcond[0]=(x322+new_r12);
evalcond[1]=((((-1.0)*cj2*x321))+new_r02);
evalcond[2]=(((new_r12*x319))+((new_r02*x320)));
evalcond[3]=(cj2+(((-1.0)*new_r02*x321))+x323);
evalcond[4]=(((new_r20*sj2))+((new_r10*x322))+(((-1.0)*cj2*new_r00*x321)));
evalcond[5]=((((-1.0)*cj2*new_r01*x321))+((new_r21*sj2))+((new_r11*x322)));
evalcond[6]=((((-1.0)*sj2*x323))+((cj2*new_r22))+((new_r02*sj2*x319)));
evalcond[7]=((1.0)+((new_r12*x322))+((new_r22*sj2))+(((-1.0)*cj2*new_r02*x321)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[3];
j3eval[0]=cj2;
j3eval[1]=IKsign(cj2);
j3eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
j3eval[0]=cj2;
j3eval[1]=sj1;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
j3eval[0]=cj2;
j3eval[1]=sj1;
j3eval[2]=sj2;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x324=((1.0)*cj1);
if( IKabs(((((-1.0)*new_r01*x324))+(((-1.0)*new_r11*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r01*sj1))+(((-1.0)*new_r11*x324)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r01*x324))+(((-1.0)*new_r11*sj1))))+IKsqr((((new_r01*sj1))+(((-1.0)*new_r11*x324))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*new_r01*x324))+(((-1.0)*new_r11*sj1))), (((new_r01*sj1))+(((-1.0)*new_r11*x324))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x325=IKsin(j3);
IkReal x326=IKcos(j3);
IkReal x327=((1.0)*sj1);
IkReal x328=(cj1*x325);
IkReal x329=(cj1*x326);
IkReal x330=(x326*x327);
evalcond[0]=(((new_r11*sj1))+((cj1*new_r01))+x325);
evalcond[1]=(((cj1*new_r10))+x325+(((-1.0)*new_r00*x327)));
evalcond[2]=(((cj1*new_r11))+x326+(((-1.0)*new_r01*x327)));
evalcond[3]=(((new_r10*sj1))+(((-1.0)*x326))+((cj1*new_r00)));
evalcond[4]=(x329+((sj1*x325))+new_r11);
evalcond[5]=(x328+(((-1.0)*x330))+new_r01);
evalcond[6]=(x328+(((-1.0)*x330))+new_r10);
evalcond[7]=((((-1.0)*x325*x327))+(((-1.0)*x329))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x331=((1.0)*new_r01);
if( IKabs(((((-1.0)*new_r11*sj1))+(((-1.0)*cj1*x331)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*new_r11))+(((-1.0)*sj1*x331)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r11*sj1))+(((-1.0)*cj1*x331))))+IKsqr((((cj1*new_r11))+(((-1.0)*sj1*x331))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*new_r11*sj1))+(((-1.0)*cj1*x331))), (((cj1*new_r11))+(((-1.0)*sj1*x331))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x332=IKcos(j3);
IkReal x333=IKsin(j3);
IkReal x334=((1.0)*sj1);
IkReal x335=((1.0)*x332);
IkReal x336=(sj1*x333);
IkReal x337=((1.0)*x333);
IkReal x338=(sj1*x332);
IkReal x339=(cj1*x335);
evalcond[0]=(((new_r11*sj1))+((cj1*new_r01))+x333);
evalcond[1]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x335)));
evalcond[2]=(((cj1*x333))+x338+new_r01);
evalcond[3]=(x336+(((-1.0)*x339))+new_r11);
evalcond[4]=(((cj1*new_r10))+(((-1.0)*new_r00*x334))+(((-1.0)*x337)));
evalcond[5]=(((cj1*new_r11))+(((-1.0)*x335))+(((-1.0)*new_r01*x334)));
evalcond[6]=(x336+(((-1.0)*x339))+new_r00);
evalcond[7]=((((-1.0)*x332*x334))+new_r10+(((-1.0)*cj1*x337)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-1.0)*new_r01), new_r00);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x340=IKcos(j3);
IkReal x341=IKsin(j3);
IkReal x342=((1.0)*sj2);
IkReal x343=((1.0)*x340);
IkReal x344=((1.0)*x341);
evalcond[0]=(x341+new_r01);
evalcond[1]=(new_r00+(((-1.0)*x343)));
evalcond[2]=(((sj2*x340))+new_r11);
evalcond[3]=(((sj2*x341))+new_r10);
evalcond[4]=(new_r20+(((-1.0)*cj2*x344)));
evalcond[5]=(new_r21+(((-1.0)*cj2*x343)));
evalcond[6]=((((-1.0)*new_r10*x342))+((cj2*new_r20))+(((-1.0)*x344)));
evalcond[7]=((((-1.0)*new_r11*x342))+((cj2*new_r21))+(((-1.0)*x343)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(new_r01, ((-1.0)*new_r00));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x345=IKsin(j3);
IkReal x346=IKcos(j3);
IkReal x347=((1.0)*x346);
IkReal x348=((1.0)*x345);
evalcond[0]=(x345+(((-1.0)*new_r01)));
evalcond[1]=(new_r20+(((-1.0)*cj2*x348)));
evalcond[2]=(new_r21+(((-1.0)*cj2*x347)));
evalcond[3]=(new_r11+(((-1.0)*sj2*x347)));
evalcond[4]=((((-1.0)*new_r00))+(((-1.0)*x347)));
evalcond[5]=(((sj2*x345))+(((-1.0)*new_r10)));
evalcond[6]=(((new_r10*sj2))+((cj2*new_r20))+(((-1.0)*x348)));
evalcond[7]=(((new_r11*sj2))+((cj2*new_r21))+(((-1.0)*x347)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r20)+IKsqr(new_r21)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(new_r20, new_r21);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x349=IKsin(j3);
IkReal x350=IKcos(j3);
IkReal x351=((1.0)*x350);
evalcond[0]=(new_r20+(((-1.0)*x349)));
evalcond[1]=((((-1.0)*x351))+new_r21);
evalcond[2]=(((sj1*x349))+new_r11);
evalcond[3]=(((cj1*x349))+new_r01);
evalcond[4]=(new_r10+(((-1.0)*sj1*x351)));
evalcond[5]=((((-1.0)*cj1*x351))+new_r00);
evalcond[6]=(((new_r11*sj1))+((cj1*new_r01))+x349);
evalcond[7]=(((new_r10*sj1))+(((-1.0)*x351))+((cj1*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r20))+IKsqr(((-1.0)*new_r21))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-1.0)*new_r20), ((-1.0)*new_r21));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x352=IKsin(j3);
IkReal x353=IKcos(j3);
IkReal x354=((1.0)*x353);
evalcond[0]=(x352+new_r20);
evalcond[1]=(x353+new_r21);
evalcond[2]=(((sj1*x352))+new_r11);
evalcond[3]=(((cj1*x352))+new_r01);
evalcond[4]=(new_r10+(((-1.0)*sj1*x354)));
evalcond[5]=((((-1.0)*cj1*x354))+new_r00);
evalcond[6]=(((new_r11*sj1))+((cj1*new_r01))+x352);
evalcond[7]=(((new_r10*sj1))+(((-1.0)*x354))+((cj1*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j3eval[0]=IKabs(new_r22);
if( IKabs(j3eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j3]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=new_r22;
op[1]=0;
op[2]=((-1.0)*new_r22);
polyroots2(op,zeror,numroots);
IkReal j3array[2], cj3array[2], sj3array[2], tempj3array[1];
int numsolutions = 0;
for(int ij3 = 0; ij3 < numroots; ++ij3)
{
IkReal htj3 = zeror[ij3];
tempj3array[0]=((2.0)*(atan(htj3)));
for(int kj3 = 0; kj3 < 1; ++kj3)
{
j3array[numsolutions] = tempj3array[kj3];
if( j3array[numsolutions] > IKPI )
{
    j3array[numsolutions]-=IK2PI;
}
else if( j3array[numsolutions] < -IKPI )
{
    j3array[numsolutions]+=IK2PI;
}
sj3array[numsolutions] = IKsin(j3array[numsolutions]);
cj3array[numsolutions] = IKcos(j3array[numsolutions]);
numsolutions++;
}
}
bool j3valid[2]={true,true};
_nj3 = 2;
for(int ij3 = 0; ij3 < numsolutions; ++ij3)
    {
if( !j3valid[ij3] )
{
    continue;
}
    j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
htj3 = IKtan(j3/2);

_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < numsolutions; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x356=IKPowWithIntegerCheck(cj2,-1);
if(!x356.valid){
continue;
}
IkReal x355=x356.value;
CheckValue<IkReal> x357=IKPowWithIntegerCheck(sj1,-1);
if(!x357.valid){
continue;
}
CheckValue<IkReal> x358=IKPowWithIntegerCheck(sj2,-1);
if(!x358.valid){
continue;
}
if( IKabs((new_r20*x355)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x355*(x357.value)*(x358.value)*((((cj1*new_r20))+((cj2*new_r01)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r20*x355))+IKsqr((x355*(x357.value)*(x358.value)*((((cj1*new_r20))+((cj2*new_r01))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((new_r20*x355), (x355*(x357.value)*(x358.value)*((((cj1*new_r20))+((cj2*new_r01))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x359=IKsin(j3);
IkReal x360=IKcos(j3);
IkReal x361=(cj1*new_r11);
IkReal x362=((1.0)*cj2);
IkReal x363=((1.0)*sj2);
IkReal x364=((1.0)*sj1);
IkReal x365=(cj1*new_r10);
IkReal x366=(sj1*sj2);
IkReal x367=((1.0)*x360);
IkReal x368=(cj1*x359);
IkReal x369=(sj2*x359);
IkReal x370=(sj2*x360);
evalcond[0]=((((-1.0)*x359*x362))+new_r20);
evalcond[1]=((((-1.0)*x360*x362))+new_r21);
evalcond[2]=(((new_r11*sj1))+((cj1*new_r01))+x359);
evalcond[3]=(((new_r10*sj1))+(((-1.0)*x367))+((cj1*new_r00)));
evalcond[4]=(((cj1*x370))+((sj1*x359))+new_r11);
evalcond[5]=((((-1.0)*new_r00*x364))+x369+x365);
evalcond[6]=(x370+x361+(((-1.0)*new_r01*x364)));
evalcond[7]=((((-1.0)*sj1*x360*x363))+x368+new_r01);
evalcond[8]=((((-1.0)*x360*x364))+((sj2*x368))+new_r10);
evalcond[9]=((((-1.0)*cj1*x367))+(((-1.0)*sj1*x359*x363))+new_r00);
evalcond[10]=((((-1.0)*x363*x365))+((new_r00*x366))+(((-1.0)*x359))+((cj2*new_r20)));
evalcond[11]=((((-1.0)*x361*x363))+(((-1.0)*x367))+((new_r01*x366))+((cj2*new_r21)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x372=IKPowWithIntegerCheck(cj2,-1);
if(!x372.valid){
continue;
}
IkReal x371=x372.value;
CheckValue<IkReal> x373=IKPowWithIntegerCheck(sj1,-1);
if(!x373.valid){
continue;
}
if( IKabs((x371*(x373.value)*(((((-1.0)*cj1*new_r21*sj2))+(((-1.0)*cj2*new_r11)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r21*x371)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x371*(x373.value)*(((((-1.0)*cj1*new_r21*sj2))+(((-1.0)*cj2*new_r11))))))+IKsqr((new_r21*x371))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((x371*(x373.value)*(((((-1.0)*cj1*new_r21*sj2))+(((-1.0)*cj2*new_r11))))), (new_r21*x371));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x374=IKsin(j3);
IkReal x375=IKcos(j3);
IkReal x376=(cj1*new_r11);
IkReal x377=((1.0)*cj2);
IkReal x378=((1.0)*sj2);
IkReal x379=((1.0)*sj1);
IkReal x380=(cj1*new_r10);
IkReal x381=(sj1*sj2);
IkReal x382=((1.0)*x375);
IkReal x383=(cj1*x374);
IkReal x384=(sj2*x374);
IkReal x385=(sj2*x375);
evalcond[0]=((((-1.0)*x374*x377))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x375*x377)));
evalcond[2]=(((new_r11*sj1))+((cj1*new_r01))+x374);
evalcond[3]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x382)));
evalcond[4]=(((cj1*x385))+((sj1*x374))+new_r11);
evalcond[5]=((((-1.0)*new_r00*x379))+x384+x380);
evalcond[6]=(x385+x376+(((-1.0)*new_r01*x379)));
evalcond[7]=(x383+new_r01+(((-1.0)*sj1*x375*x378)));
evalcond[8]=(new_r10+(((-1.0)*x375*x379))+((sj2*x383)));
evalcond[9]=((((-1.0)*cj1*x382))+new_r00+(((-1.0)*sj1*x374*x378)));
evalcond[10]=((((-1.0)*x374))+((new_r00*x381))+((cj2*new_r20))+(((-1.0)*x378*x380)));
evalcond[11]=(((new_r01*x381))+(((-1.0)*x382))+(((-1.0)*x376*x378))+((cj2*new_r21)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x386=IKPowWithIntegerCheck(IKsign(cj2),-1);
if(!x386.valid){
continue;
}
CheckValue<IkReal> x387 = IKatan2WithCheck(IkReal(new_r20),IkReal(new_r21),IKFAST_ATAN2_MAGTHRESH);
if(!x387.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x386.value)))+(x387.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x388=IKsin(j3);
IkReal x389=IKcos(j3);
IkReal x390=(cj1*new_r11);
IkReal x391=((1.0)*cj2);
IkReal x392=((1.0)*sj2);
IkReal x393=((1.0)*sj1);
IkReal x394=(cj1*new_r10);
IkReal x395=(sj1*sj2);
IkReal x396=((1.0)*x389);
IkReal x397=(cj1*x388);
IkReal x398=(sj2*x388);
IkReal x399=(sj2*x389);
evalcond[0]=((((-1.0)*x388*x391))+new_r20);
evalcond[1]=((((-1.0)*x389*x391))+new_r21);
evalcond[2]=(((new_r11*sj1))+((cj1*new_r01))+x388);
evalcond[3]=((((-1.0)*x396))+((new_r10*sj1))+((cj1*new_r00)));
evalcond[4]=(((cj1*x399))+new_r11+((sj1*x388)));
evalcond[5]=(x394+x398+(((-1.0)*new_r00*x393)));
evalcond[6]=((((-1.0)*new_r01*x393))+x390+x399);
evalcond[7]=(x397+new_r01+(((-1.0)*sj1*x389*x392)));
evalcond[8]=((((-1.0)*x389*x393))+((sj2*x397))+new_r10);
evalcond[9]=((((-1.0)*cj1*x396))+(((-1.0)*sj1*x388*x392))+new_r00);
evalcond[10]=((((-1.0)*x388))+((new_r00*x395))+((cj2*new_r20))+(((-1.0)*x392*x394)));
evalcond[11]=((((-1.0)*x396))+((new_r01*x395))+(((-1.0)*x390*x392))+((cj2*new_r21)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x400=IKPowWithIntegerCheck(IKsign(cj2),-1);
if(!x400.valid){
continue;
}
CheckValue<IkReal> x401 = IKatan2WithCheck(IkReal(new_r02),IkReal(((-1.0)*new_r12)),IKFAST_ATAN2_MAGTHRESH);
if(!x401.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x400.value)))+(x401.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x402=IKsin(j1);
IkReal x403=IKcos(j1);
IkReal x404=((1.0)*x402);
IkReal x405=(cj2*x403);
IkReal x406=(new_r12*x403);
evalcond[0]=(x405+new_r12);
evalcond[1]=((((-1.0)*cj2*x404))+new_r02);
evalcond[2]=(((new_r12*x402))+((new_r02*x403)));
evalcond[3]=(cj2+x406+(((-1.0)*new_r02*x404)));
evalcond[4]=(((new_r20*sj2))+((new_r10*x405))+(((-1.0)*cj2*new_r00*x404)));
evalcond[5]=((((-1.0)*cj2*new_r01*x404))+((new_r11*x405))+((new_r21*sj2)));
evalcond[6]=(((new_r02*sj2*x402))+(((-1.0)*sj2*x406))+((cj2*new_r22)));
evalcond[7]=((1.0)+((new_r22*sj2))+((new_r12*x405))+(((-1.0)*cj2*new_r02*x404)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[3];
j3eval[0]=cj2;
j3eval[1]=IKsign(cj2);
j3eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
j3eval[0]=cj2;
j3eval[1]=sj1;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
j3eval[0]=cj2;
j3eval[1]=sj1;
j3eval[2]=sj2;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x407=((1.0)*cj1);
if( IKabs(((((-1.0)*new_r11*sj1))+(((-1.0)*new_r01*x407)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r01*sj1))+(((-1.0)*new_r11*x407)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r11*sj1))+(((-1.0)*new_r01*x407))))+IKsqr((((new_r01*sj1))+(((-1.0)*new_r11*x407))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*new_r11*sj1))+(((-1.0)*new_r01*x407))), (((new_r01*sj1))+(((-1.0)*new_r11*x407))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x408=IKsin(j3);
IkReal x409=IKcos(j3);
IkReal x410=((1.0)*sj1);
IkReal x411=(cj1*x408);
IkReal x412=(cj1*x409);
IkReal x413=(x409*x410);
evalcond[0]=(((new_r11*sj1))+((cj1*new_r01))+x408);
evalcond[1]=(((cj1*new_r10))+x408+(((-1.0)*new_r00*x410)));
evalcond[2]=(((cj1*new_r11))+x409+(((-1.0)*new_r01*x410)));
evalcond[3]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x409)));
evalcond[4]=(((sj1*x408))+x412+new_r11);
evalcond[5]=(x411+new_r01+(((-1.0)*x413)));
evalcond[6]=(x411+new_r10+(((-1.0)*x413)));
evalcond[7]=(new_r00+(((-1.0)*x408*x410))+(((-1.0)*x412)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x414=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj1*x414))+(((-1.0)*new_r11*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*new_r11))+(((-1.0)*sj1*x414)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj1*x414))+(((-1.0)*new_r11*sj1))))+IKsqr((((cj1*new_r11))+(((-1.0)*sj1*x414))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*cj1*x414))+(((-1.0)*new_r11*sj1))), (((cj1*new_r11))+(((-1.0)*sj1*x414))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x415=IKcos(j3);
IkReal x416=IKsin(j3);
IkReal x417=((1.0)*sj1);
IkReal x418=((1.0)*x415);
IkReal x419=(sj1*x416);
IkReal x420=((1.0)*x416);
IkReal x421=(sj1*x415);
IkReal x422=(cj1*x418);
evalcond[0]=(((new_r11*sj1))+((cj1*new_r01))+x416);
evalcond[1]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x418)));
evalcond[2]=(x421+new_r01+((cj1*x416)));
evalcond[3]=((((-1.0)*x422))+x419+new_r11);
evalcond[4]=((((-1.0)*x420))+((cj1*new_r10))+(((-1.0)*new_r00*x417)));
evalcond[5]=(((cj1*new_r11))+(((-1.0)*x418))+(((-1.0)*new_r01*x417)));
evalcond[6]=((((-1.0)*x422))+x419+new_r00);
evalcond[7]=((((-1.0)*cj1*x420))+(((-1.0)*x415*x417))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-1.0)*new_r01), new_r00);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x423=IKcos(j3);
IkReal x424=IKsin(j3);
IkReal x425=((1.0)*sj2);
IkReal x426=((1.0)*x423);
IkReal x427=((1.0)*x424);
evalcond[0]=(x424+new_r01);
evalcond[1]=((((-1.0)*x426))+new_r00);
evalcond[2]=(new_r11+((sj2*x423)));
evalcond[3]=(new_r10+((sj2*x424)));
evalcond[4]=((((-1.0)*cj2*x427))+new_r20);
evalcond[5]=((((-1.0)*cj2*x426))+new_r21);
evalcond[6]=((((-1.0)*x427))+(((-1.0)*new_r10*x425))+((cj2*new_r20)));
evalcond[7]=((((-1.0)*x426))+(((-1.0)*new_r11*x425))+((cj2*new_r21)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(new_r01, ((-1.0)*new_r00));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x428=IKsin(j3);
IkReal x429=IKcos(j3);
IkReal x430=((1.0)*x429);
IkReal x431=((1.0)*x428);
evalcond[0]=(x428+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*cj2*x431))+new_r20);
evalcond[2]=((((-1.0)*cj2*x430))+new_r21);
evalcond[3]=(new_r11+(((-1.0)*sj2*x430)));
evalcond[4]=((((-1.0)*x430))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*new_r10))+((sj2*x428)));
evalcond[6]=((((-1.0)*x431))+((new_r10*sj2))+((cj2*new_r20)));
evalcond[7]=((((-1.0)*x430))+((new_r11*sj2))+((cj2*new_r21)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r20)+IKsqr(new_r21)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(new_r20, new_r21);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x432=IKsin(j3);
IkReal x433=IKcos(j3);
IkReal x434=((1.0)*x433);
evalcond[0]=((((-1.0)*x432))+new_r20);
evalcond[1]=((((-1.0)*x434))+new_r21);
evalcond[2]=(new_r11+((sj1*x432)));
evalcond[3]=(((cj1*x432))+new_r01);
evalcond[4]=((((-1.0)*sj1*x434))+new_r10);
evalcond[5]=((((-1.0)*cj1*x434))+new_r00);
evalcond[6]=(((new_r11*sj1))+((cj1*new_r01))+x432);
evalcond[7]=((((-1.0)*x434))+((new_r10*sj1))+((cj1*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r20))+IKsqr(((-1.0)*new_r21))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-1.0)*new_r20), ((-1.0)*new_r21));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x435=IKsin(j3);
IkReal x436=IKcos(j3);
IkReal x437=((1.0)*x436);
evalcond[0]=(x435+new_r20);
evalcond[1]=(x436+new_r21);
evalcond[2]=(new_r11+((sj1*x435)));
evalcond[3]=(((cj1*x435))+new_r01);
evalcond[4]=((((-1.0)*sj1*x437))+new_r10);
evalcond[5]=((((-1.0)*cj1*x437))+new_r00);
evalcond[6]=(((new_r11*sj1))+((cj1*new_r01))+x435);
evalcond[7]=((((-1.0)*x437))+((new_r10*sj1))+((cj1*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j3eval[0]=IKabs(new_r22);
if( IKabs(j3eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j3]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=new_r22;
op[1]=0;
op[2]=((-1.0)*new_r22);
polyroots2(op,zeror,numroots);
IkReal j3array[2], cj3array[2], sj3array[2], tempj3array[1];
int numsolutions = 0;
for(int ij3 = 0; ij3 < numroots; ++ij3)
{
IkReal htj3 = zeror[ij3];
tempj3array[0]=((2.0)*(atan(htj3)));
for(int kj3 = 0; kj3 < 1; ++kj3)
{
j3array[numsolutions] = tempj3array[kj3];
if( j3array[numsolutions] > IKPI )
{
    j3array[numsolutions]-=IK2PI;
}
else if( j3array[numsolutions] < -IKPI )
{
    j3array[numsolutions]+=IK2PI;
}
sj3array[numsolutions] = IKsin(j3array[numsolutions]);
cj3array[numsolutions] = IKcos(j3array[numsolutions]);
numsolutions++;
}
}
bool j3valid[2]={true,true};
_nj3 = 2;
for(int ij3 = 0; ij3 < numsolutions; ++ij3)
    {
if( !j3valid[ij3] )
{
    continue;
}
    j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
htj3 = IKtan(j3/2);

_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < numsolutions; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x439=IKPowWithIntegerCheck(cj2,-1);
if(!x439.valid){
continue;
}
IkReal x438=x439.value;
CheckValue<IkReal> x440=IKPowWithIntegerCheck(sj1,-1);
if(!x440.valid){
continue;
}
CheckValue<IkReal> x441=IKPowWithIntegerCheck(sj2,-1);
if(!x441.valid){
continue;
}
if( IKabs((new_r20*x438)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x438*(x440.value)*(x441.value)*((((cj1*new_r20))+((cj2*new_r01)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r20*x438))+IKsqr((x438*(x440.value)*(x441.value)*((((cj1*new_r20))+((cj2*new_r01))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((new_r20*x438), (x438*(x440.value)*(x441.value)*((((cj1*new_r20))+((cj2*new_r01))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x442=IKsin(j3);
IkReal x443=IKcos(j3);
IkReal x444=(cj1*new_r11);
IkReal x445=((1.0)*cj2);
IkReal x446=((1.0)*sj2);
IkReal x447=((1.0)*sj1);
IkReal x448=(cj1*new_r10);
IkReal x449=(sj1*sj2);
IkReal x450=((1.0)*x443);
IkReal x451=(cj1*x442);
IkReal x452=(sj2*x442);
IkReal x453=(sj2*x443);
evalcond[0]=(new_r20+(((-1.0)*x442*x445)));
evalcond[1]=((((-1.0)*x443*x445))+new_r21);
evalcond[2]=(((new_r11*sj1))+((cj1*new_r01))+x442);
evalcond[3]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x450)));
evalcond[4]=(((sj1*x442))+((cj1*x453))+new_r11);
evalcond[5]=((((-1.0)*new_r00*x447))+x448+x452);
evalcond[6]=((((-1.0)*new_r01*x447))+x444+x453);
evalcond[7]=((((-1.0)*sj1*x443*x446))+x451+new_r01);
evalcond[8]=(((sj2*x451))+(((-1.0)*x443*x447))+new_r10);
evalcond[9]=((((-1.0)*sj1*x442*x446))+(((-1.0)*cj1*x450))+new_r00);
evalcond[10]=(((new_r00*x449))+(((-1.0)*x442))+((cj2*new_r20))+(((-1.0)*x446*x448)));
evalcond[11]=((((-1.0)*x444*x446))+((new_r01*x449))+(((-1.0)*x450))+((cj2*new_r21)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x455=IKPowWithIntegerCheck(cj2,-1);
if(!x455.valid){
continue;
}
IkReal x454=x455.value;
CheckValue<IkReal> x456=IKPowWithIntegerCheck(sj1,-1);
if(!x456.valid){
continue;
}
if( IKabs((x454*(x456.value)*(((((-1.0)*cj1*new_r21*sj2))+(((-1.0)*cj2*new_r11)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r21*x454)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x454*(x456.value)*(((((-1.0)*cj1*new_r21*sj2))+(((-1.0)*cj2*new_r11))))))+IKsqr((new_r21*x454))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((x454*(x456.value)*(((((-1.0)*cj1*new_r21*sj2))+(((-1.0)*cj2*new_r11))))), (new_r21*x454));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x457=IKsin(j3);
IkReal x458=IKcos(j3);
IkReal x459=(cj1*new_r11);
IkReal x460=((1.0)*cj2);
IkReal x461=((1.0)*sj2);
IkReal x462=((1.0)*sj1);
IkReal x463=(cj1*new_r10);
IkReal x464=(sj1*sj2);
IkReal x465=((1.0)*x458);
IkReal x466=(cj1*x457);
IkReal x467=(sj2*x457);
IkReal x468=(sj2*x458);
evalcond[0]=(new_r20+(((-1.0)*x457*x460)));
evalcond[1]=((((-1.0)*x458*x460))+new_r21);
evalcond[2]=(((new_r11*sj1))+((cj1*new_r01))+x457);
evalcond[3]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x465)));
evalcond[4]=(((cj1*x468))+((sj1*x457))+new_r11);
evalcond[5]=((((-1.0)*new_r00*x462))+x463+x467);
evalcond[6]=((((-1.0)*new_r01*x462))+x459+x468);
evalcond[7]=((((-1.0)*sj1*x458*x461))+x466+new_r01);
evalcond[8]=((((-1.0)*x458*x462))+new_r10+((sj2*x466)));
evalcond[9]=((((-1.0)*cj1*x465))+(((-1.0)*sj1*x457*x461))+new_r00);
evalcond[10]=(((new_r00*x464))+(((-1.0)*x457))+(((-1.0)*x461*x463))+((cj2*new_r20)));
evalcond[11]=(((new_r01*x464))+(((-1.0)*x459*x461))+(((-1.0)*x465))+((cj2*new_r21)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x469=IKPowWithIntegerCheck(IKsign(cj2),-1);
if(!x469.valid){
continue;
}
CheckValue<IkReal> x470 = IKatan2WithCheck(IkReal(new_r20),IkReal(new_r21),IKFAST_ATAN2_MAGTHRESH);
if(!x470.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x469.value)))+(x470.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x471=IKsin(j3);
IkReal x472=IKcos(j3);
IkReal x473=(cj1*new_r11);
IkReal x474=((1.0)*cj2);
IkReal x475=((1.0)*sj2);
IkReal x476=((1.0)*sj1);
IkReal x477=(cj1*new_r10);
IkReal x478=(sj1*sj2);
IkReal x479=((1.0)*x472);
IkReal x480=(cj1*x471);
IkReal x481=(sj2*x471);
IkReal x482=(sj2*x472);
evalcond[0]=((((-1.0)*x471*x474))+new_r20);
evalcond[1]=((((-1.0)*x472*x474))+new_r21);
evalcond[2]=(((new_r11*sj1))+((cj1*new_r01))+x471);
evalcond[3]=(((new_r10*sj1))+(((-1.0)*x479))+((cj1*new_r00)));
evalcond[4]=(((cj1*x482))+((sj1*x471))+new_r11);
evalcond[5]=((((-1.0)*new_r00*x476))+x481+x477);
evalcond[6]=((((-1.0)*new_r01*x476))+x482+x473);
evalcond[7]=((((-1.0)*sj1*x472*x475))+x480+new_r01);
evalcond[8]=((((-1.0)*x472*x476))+((sj2*x480))+new_r10);
evalcond[9]=((((-1.0)*sj1*x471*x475))+(((-1.0)*cj1*x479))+new_r00);
evalcond[10]=((((-1.0)*x475*x477))+((new_r00*x478))+(((-1.0)*x471))+((cj2*new_r20)));
evalcond[11]=(((new_r01*x478))+(((-1.0)*x479))+(((-1.0)*x473*x475))+((cj2*new_r21)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x483=IKPowWithIntegerCheck(IKsign(cj2),-1);
if(!x483.valid){
continue;
}
CheckValue<IkReal> x484 = IKatan2WithCheck(IkReal(new_r20),IkReal(new_r21),IKFAST_ATAN2_MAGTHRESH);
if(!x484.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x483.value)))+(x484.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[2];
IkReal x485=((1.0)*cj2);
evalcond[0]=((((-1.0)*x485*(IKsin(j3))))+new_r20);
evalcond[1]=((((-1.0)*x485*(IKcos(j3))))+new_r21);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[3];
j1eval[0]=cj2;
j1eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j1eval[2]=IKsign(cj2);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
j1eval[0]=cj2;
j1eval[1]=new_r11;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
IkReal x486=((1.0)*sj3);
IkReal x487=(((new_r10*new_r11))+((new_r00*new_r01)));
j1eval[0]=x487;
j1eval[1]=IKsign(x487);
j1eval[2]=((IKabs(((((-1.0)*new_r10*x486))+((new_r01*sj3)))))+(IKabs(((((-1.0)*new_r11*x486))+(((-1.0)*new_r00*x486))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
IkReal x488=((1.0)*sj3);
IkReal x489=((new_r01*new_r01)+(new_r11*new_r11));
j1eval[0]=x489;
j1eval[1]=((IKabs(((((-1.0)*new_r11*x488))+((cj3*new_r01)))))+(IKabs(((((-1.0)*new_r01*x488))+(((-1.0)*cj3*new_r11))))));
j1eval[2]=IKsign(x489);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
IkReal x490=(((new_r11*sj3))+((cj3*new_r01)));
j1eval[0]=x490;
j1eval[1]=((IKabs(((-1.0)+(cj3*cj3)+(new_r01*new_r01))))+(IKabs(((((-1.0)*cj3*sj3))+(((-1.0)*new_r01*new_r11))))));
j1eval[2]=IKsign(x490);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x492 = ((new_r01*new_r01)+(new_r11*new_r11));
if(IKabs(x492)==0){
continue;
}
IkReal x491=pow(x492,-0.5);
CheckValue<IkReal> x493 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x493.valid){
continue;
}
IkReal gconst82=((-1.0)*(x493.value));
IkReal gconst83=((-1.0)*new_r01*x491);
IkReal gconst84=(new_r11*x491);
CheckValue<IkReal> x494 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x494.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x494.value)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
CheckValue<IkReal> x497 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x497.valid){
continue;
}
IkReal x495=((-1.0)*(x497.value));
IkReal x496=x491;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst83;
cj3=gconst84;
j3=x495;
IkReal gconst82=x495;
IkReal gconst83=((-1.0)*new_r01*x496);
IkReal gconst84=(new_r11*x496);
IkReal x498=new_r01*new_r01;
IkReal x499=(new_r00*new_r01);
IkReal x500=(((new_r10*new_r11))+x499);
IkReal x501=x491;
IkReal x502=(new_r01*x501);
j1eval[0]=x500;
j1eval[1]=IKsign(x500);
j1eval[2]=((IKabs(((((-1.0)*x498*x501))+((new_r10*x502)))))+(IKabs((((new_r11*x502))+((x499*x501))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
CheckValue<IkReal> x505 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x505.valid){
continue;
}
IkReal x503=((-1.0)*(x505.value));
IkReal x504=x491;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst83;
cj3=gconst84;
j3=x503;
IkReal gconst82=x503;
IkReal gconst83=((-1.0)*new_r01*x504);
IkReal gconst84=(new_r11*x504);
IkReal x506=((new_r01*new_r01)+(new_r11*new_r11));
j1eval[0]=x506;
j1eval[1]=IKsign(x506);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x509 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x509.valid){
continue;
}
IkReal x507=((-1.0)*(x509.value));
IkReal x508=x491;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst83;
cj3=gconst84;
j3=x507;
IkReal gconst82=x507;
IkReal gconst83=((-1.0)*new_r01*x508);
IkReal gconst84=(new_r11*x508);
IkReal x510=new_r01*new_r01;
IkReal x511=new_r11*new_r11;
IkReal x512=((1.0)*x510);
CheckValue<IkReal> x518=IKPowWithIntegerCheck((x511+x510),-1);
if(!x518.valid){
continue;
}
IkReal x513=x518.value;
CheckValue<IkReal> x519=IKPowWithIntegerCheck(((((-1.0)*x511))+(((-1.0)*x512))),-1);
if(!x519.valid){
continue;
}
IkReal x514=x519.value;
IkReal x515=((1.0)*x514);
IkReal x516=(new_r11*x515);
IkReal x517=(new_r01*x515);
j1eval[0]=((IKabs(((((-1.0)*x516*(new_r01*new_r01*new_r01)))+(((-1.0)*new_r01*x516*(new_r11*new_r11)))+(((-1.0)*new_r01*x516)))))+(IKabs(((((-1.0)*x512*x513))+((x513*(x511*x511)))+((x510*x511*x513))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
CheckValue<IkReal> x521 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x521.valid){
continue;
}
IkReal x520=((-1.0)*(x521.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst83;
cj3=gconst84;
j3=x520;
new_r11=0;
new_r00=0;
IkReal gconst82=x520;
IkReal x522 = new_r01*new_r01;
if(IKabs(x522)==0){
continue;
}
IkReal gconst83=((-1.0)*new_r01*(pow(x522,-0.5)));
IkReal gconst84=0;
j1eval[0]=new_r01;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x524 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x524.valid){
continue;
}
IkReal x523=((-1.0)*(x524.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst83;
cj3=gconst84;
j3=x523;
new_r11=0;
new_r00=0;
IkReal gconst82=x523;
IkReal x525 = new_r01*new_r01;
if(IKabs(x525)==0){
continue;
}
IkReal gconst83=((-1.0)*new_r01*(pow(x525,-0.5)));
IkReal gconst84=0;
j1eval[0]=new_r10;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x526=IKPowWithIntegerCheck(gconst83,-1);
if(!x526.valid){
continue;
}
cj1array[0]=((-1.0)*new_r01*(x526.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x527=IKsin(j1);
IkReal x528=IKcos(j1);
evalcond[0]=(new_r10*x527);
evalcond[1]=(gconst83*x527);
evalcond[2]=((-1.0)*new_r01*x527);
evalcond[3]=(((new_r01*x528))+gconst83);
evalcond[4]=(gconst83+((new_r10*x528)));
evalcond[5]=(((gconst83*x528))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x529=IKPowWithIntegerCheck(new_r10,-1);
if(!x529.valid){
continue;
}
cj1array[0]=((-1.0)*gconst83*(x529.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x530=IKsin(j1);
IkReal x531=IKcos(j1);
IkReal x532=(gconst83*x531);
evalcond[0]=(new_r10*x530);
evalcond[1]=(gconst83*x530);
evalcond[2]=((-1.0)*new_r01*x530);
evalcond[3]=(((new_r01*x531))+gconst83);
evalcond[4]=(x532+new_r01);
evalcond[5]=(x532+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x533=IKPowWithIntegerCheck(new_r01,-1);
if(!x533.valid){
continue;
}
cj1array[0]=((-1.0)*gconst83*(x533.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x534=IKsin(j1);
IkReal x535=IKcos(j1);
IkReal x536=(gconst83*x535);
evalcond[0]=(new_r10*x534);
evalcond[1]=(gconst83*x534);
evalcond[2]=((-1.0)*new_r01*x534);
evalcond[3]=(gconst83+((new_r10*x535)));
evalcond[4]=(x536+new_r01);
evalcond[5]=(x536+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
evalcond[1]=gconst83;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
CheckValue<IkReal> x538 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x538.valid){
continue;
}
IkReal x537=((-1.0)*(x538.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst83;
cj3=gconst84;
j3=x537;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst82=x537;
IkReal gconst83=((-1.0)*new_r01);
IkReal gconst84=new_r11;
j1eval[0]=-1.0;
j1eval[1]=-1.0;
j1eval[2]=((IKabs(new_r01*new_r01))+(IKabs((new_r01*new_r11))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
CheckValue<IkReal> x540 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x540.valid){
continue;
}
IkReal x539=((-1.0)*(x540.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst83;
cj3=gconst84;
j3=x539;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst82=x539;
IkReal gconst83=((-1.0)*new_r01);
IkReal gconst84=new_r11;
j1eval[0]=-1.0;
j1eval[1]=((IKabs((new_r01*new_r11)))+(IKabs(((1.0)+(((-1.0)*(new_r01*new_r01)))))));
j1eval[2]=-1.0;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
CheckValue<IkReal> x542 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x542.valid){
continue;
}
IkReal x541=((-1.0)*(x542.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst83;
cj3=gconst84;
j3=x541;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst82=x541;
IkReal gconst83=((-1.0)*new_r01);
IkReal gconst84=new_r11;
j1eval[0]=1.0;
j1eval[1]=((((0.5)*(IKabs(((-1.0)+(((2.0)*(new_r01*new_r01))))))))+(IKabs((new_r01*new_r11))));
j1eval[2]=1.0;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x543=((1.0)*gconst83);
CheckValue<IkReal> x544 = IKatan2WithCheck(IkReal((((gconst84*new_r01))+(((-1.0)*new_r11*x543)))),IkReal(((((-1.0)*new_r01*x543))+(((-1.0)*gconst84*new_r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x544.valid){
continue;
}
CheckValue<IkReal> x545=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x545.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x544.value)+(((1.5707963267949)*(x545.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x546=IKcos(j1);
IkReal x547=IKsin(j1);
IkReal x548=(gconst83*x546);
IkReal x549=((1.0)*x547);
IkReal x550=(gconst84*x546);
IkReal x551=(gconst84*x549);
evalcond[0]=(gconst83+((new_r11*x547))+((new_r01*x546)));
evalcond[1]=(((gconst83*x547))+x550+new_r11);
evalcond[2]=((((-1.0)*x551))+x548);
evalcond[3]=(gconst84+((new_r11*x546))+(((-1.0)*new_r01*x549)));
evalcond[4]=((((-1.0)*x551))+x548+new_r01);
evalcond[5]=((((-1.0)*x550))+(((-1.0)*gconst83*x549)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x552=IKPowWithIntegerCheck(IKsign(((((-1.0)*(gconst84*gconst84)))+(((-1.0)*(gconst83*gconst83))))),-1);
if(!x552.valid){
continue;
}
CheckValue<IkReal> x553 = IKatan2WithCheck(IkReal((gconst83*new_r11)),IkReal((gconst84*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x553.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x552.value)))+(x553.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x554=IKcos(j1);
IkReal x555=IKsin(j1);
IkReal x556=(gconst83*x554);
IkReal x557=((1.0)*x555);
IkReal x558=(gconst84*x554);
IkReal x559=(gconst84*x557);
evalcond[0]=(((new_r11*x555))+gconst83+((new_r01*x554)));
evalcond[1]=(((gconst83*x555))+x558+new_r11);
evalcond[2]=((((-1.0)*x559))+x556);
evalcond[3]=(((new_r11*x554))+gconst84+(((-1.0)*new_r01*x557)));
evalcond[4]=((((-1.0)*x559))+x556+new_r01);
evalcond[5]=((((-1.0)*x558))+(((-1.0)*gconst83*x557)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x560=IKPowWithIntegerCheck(IKsign(((((-1.0)*gconst84*new_r11))+((gconst83*new_r01)))),-1);
if(!x560.valid){
continue;
}
CheckValue<IkReal> x561 = IKatan2WithCheck(IkReal((gconst83*gconst84)),IkReal(((-1.0)*(gconst83*gconst83))),IKFAST_ATAN2_MAGTHRESH);
if(!x561.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x560.value)))+(x561.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x562=IKcos(j1);
IkReal x563=IKsin(j1);
IkReal x564=(gconst83*x562);
IkReal x565=((1.0)*x563);
IkReal x566=(gconst84*x562);
IkReal x567=(gconst84*x565);
evalcond[0]=(gconst83+((new_r01*x562))+((new_r11*x563)));
evalcond[1]=(x566+((gconst83*x563))+new_r11);
evalcond[2]=(x564+(((-1.0)*x567)));
evalcond[3]=(gconst84+((new_r11*x562))+(((-1.0)*new_r01*x565)));
evalcond[4]=(x564+new_r01+(((-1.0)*x567)));
evalcond[5]=((((-1.0)*gconst83*x565))+(((-1.0)*x566)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x568=IKPowWithIntegerCheck(gconst84,-1);
if(!x568.valid){
continue;
}
cj1array[0]=(new_r00*(x568.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x569=IKsin(j1);
IkReal x570=IKcos(j1);
IkReal x571=((-1.0)*x569);
evalcond[0]=(new_r11*x569);
evalcond[1]=(new_r00*x571);
evalcond[2]=(gconst84*x571);
evalcond[3]=(((gconst84*x570))+new_r11);
evalcond[4]=(((new_r11*x570))+gconst84);
evalcond[5]=(((new_r00*x570))+(((-1.0)*gconst84)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
CheckValue<IkReal> x573 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x573.valid){
continue;
}
IkReal x572=((-1.0)*(x573.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst83;
cj3=gconst84;
j3=x572;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst82=x572;
IkReal gconst83=0;
IkReal x574 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x574)==0){
continue;
}
IkReal gconst84=(new_r11*(pow(x574,-0.5)));
j1eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x576 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x576.valid){
continue;
}
IkReal x575=((-1.0)*(x576.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst83;
cj3=gconst84;
j3=x575;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst82=x575;
IkReal gconst83=0;
IkReal x577 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x577)==0){
continue;
}
IkReal gconst84=(new_r11*(pow(x577,-0.5)));
j1eval[0]=new_r11;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x579 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x579.valid){
continue;
}
IkReal x578=((-1.0)*(x579.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst83;
cj3=gconst84;
j3=x578;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst82=x578;
IkReal gconst83=0;
IkReal x580 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x580)==0){
continue;
}
IkReal gconst84=(new_r11*(pow(x580,-0.5)));
j1eval[0]=new_r10;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x581=IKPowWithIntegerCheck(new_r10,-1);
if(!x581.valid){
continue;
}
CheckValue<IkReal> x582=IKPowWithIntegerCheck(gconst84,-1);
if(!x582.valid){
continue;
}
if( IKabs((gconst84*(x581.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11*(x582.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((gconst84*(x581.value)))+IKsqr(((-1.0)*new_r11*(x582.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((gconst84*(x581.value)), ((-1.0)*new_r11*(x582.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x583=IKsin(j1);
IkReal x584=IKcos(j1);
IkReal x585=((1.0)*gconst84);
IkReal x586=((-1.0)*gconst84);
evalcond[0]=(new_r11*x583);
evalcond[1]=(new_r10*x584);
evalcond[2]=(x583*x586);
evalcond[3]=(x584*x586);
evalcond[4]=(((gconst84*x584))+new_r11);
evalcond[5]=(gconst84+((new_r11*x584)));
evalcond[6]=((((-1.0)*x583*x585))+new_r10);
evalcond[7]=((((-1.0)*x585))+((new_r10*x583)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x587=IKPowWithIntegerCheck(gconst84,-1);
if(!x587.valid){
continue;
}
CheckValue<IkReal> x588=IKPowWithIntegerCheck(new_r11,-1);
if(!x588.valid){
continue;
}
if( IKabs((new_r10*(x587.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst84*(x588.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x587.value)))+IKsqr(((-1.0)*gconst84*(x588.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((new_r10*(x587.value)), ((-1.0)*gconst84*(x588.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x589=IKsin(j1);
IkReal x590=IKcos(j1);
IkReal x591=((1.0)*gconst84);
IkReal x592=((-1.0)*gconst84);
evalcond[0]=(new_r11*x589);
evalcond[1]=(new_r10*x590);
evalcond[2]=(x589*x592);
evalcond[3]=(x590*x592);
evalcond[4]=(((gconst84*x590))+new_r11);
evalcond[5]=(((new_r11*x590))+gconst84);
evalcond[6]=((((-1.0)*x589*x591))+new_r10);
evalcond[7]=((((-1.0)*x591))+((new_r10*x589)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x593 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x593.valid){
continue;
}
CheckValue<IkReal> x594=IKPowWithIntegerCheck(IKsign(gconst84),-1);
if(!x594.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x593.value)+(((1.5707963267949)*(x594.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x595=IKsin(j1);
IkReal x596=IKcos(j1);
IkReal x597=((1.0)*gconst84);
IkReal x598=((-1.0)*gconst84);
evalcond[0]=(new_r11*x595);
evalcond[1]=(new_r10*x596);
evalcond[2]=(x595*x598);
evalcond[3]=(x596*x598);
evalcond[4]=(((gconst84*x596))+new_r11);
evalcond[5]=(((new_r11*x596))+gconst84);
evalcond[6]=((((-1.0)*x595*x597))+new_r10);
evalcond[7]=(((new_r10*x595))+(((-1.0)*x597)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r01);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
CheckValue<IkReal> x600 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x600.valid){
continue;
}
IkReal x599=((-1.0)*(x600.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst83;
cj3=gconst84;
j3=x599;
new_r01=0;
IkReal gconst82=x599;
IkReal gconst83=0;
IkReal x601 = new_r11*new_r11;
if(IKabs(x601)==0){
continue;
}
IkReal gconst84=(new_r11*(pow(x601,-0.5)));
j1eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x603 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x603.valid){
continue;
}
IkReal x602=((-1.0)*(x603.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst83;
cj3=gconst84;
j3=x602;
new_r01=0;
IkReal gconst82=x602;
IkReal gconst83=0;
IkReal x604 = new_r11*new_r11;
if(IKabs(x604)==0){
continue;
}
IkReal gconst84=(new_r11*(pow(x604,-0.5)));
j1eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x606 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x606.valid){
continue;
}
IkReal x605=((-1.0)*(x606.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst83;
cj3=gconst84;
j3=x605;
new_r01=0;
IkReal gconst82=x605;
IkReal gconst83=0;
IkReal x607 = new_r11*new_r11;
if(IKabs(x607)==0){
continue;
}
IkReal gconst84=(new_r11*(pow(x607,-0.5)));
j1eval[0]=new_r11;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x608=IKPowWithIntegerCheck(gconst84,-1);
if(!x608.valid){
continue;
}
CheckValue<IkReal> x609=IKPowWithIntegerCheck(new_r11,-1);
if(!x609.valid){
continue;
}
if( IKabs((new_r10*(x608.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst84*(x609.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x608.value)))+IKsqr(((-1.0)*gconst84*(x609.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((new_r10*(x608.value)), ((-1.0)*gconst84*(x609.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x610=IKsin(j1);
IkReal x611=IKcos(j1);
IkReal x612=((1.0)*gconst84);
evalcond[0]=(new_r11*x610);
evalcond[1]=((-1.0)*gconst84*x610);
evalcond[2]=(((gconst84*x611))+new_r11);
evalcond[3]=(gconst84+((new_r11*x611)));
evalcond[4]=((((-1.0)*x610*x612))+new_r10);
evalcond[5]=((((-1.0)*x611*x612))+new_r00);
evalcond[6]=(((new_r10*x611))+(((-1.0)*new_r00*x610)));
evalcond[7]=(((new_r10*x610))+(((-1.0)*x612))+((new_r00*x611)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x613 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x613.valid){
continue;
}
CheckValue<IkReal> x614=IKPowWithIntegerCheck(IKsign(gconst84),-1);
if(!x614.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x613.value)+(((1.5707963267949)*(x614.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x615=IKsin(j1);
IkReal x616=IKcos(j1);
IkReal x617=((1.0)*gconst84);
evalcond[0]=(new_r11*x615);
evalcond[1]=((-1.0)*gconst84*x615);
evalcond[2]=(((gconst84*x616))+new_r11);
evalcond[3]=(gconst84+((new_r11*x616)));
evalcond[4]=(new_r10+(((-1.0)*x615*x617)));
evalcond[5]=(new_r00+(((-1.0)*x616*x617)));
evalcond[6]=(((new_r10*x616))+(((-1.0)*new_r00*x615)));
evalcond[7]=(((new_r10*x615))+(((-1.0)*x617))+((new_r00*x616)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x618=IKPowWithIntegerCheck(IKsign(gconst84),-1);
if(!x618.valid){
continue;
}
CheckValue<IkReal> x619 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x619.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x618.value)))+(x619.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x620=IKsin(j1);
IkReal x621=IKcos(j1);
IkReal x622=((1.0)*gconst84);
evalcond[0]=(new_r11*x620);
evalcond[1]=((-1.0)*gconst84*x620);
evalcond[2]=(((gconst84*x621))+new_r11);
evalcond[3]=(gconst84+((new_r11*x621)));
evalcond[4]=((((-1.0)*x620*x622))+new_r10);
evalcond[5]=((((-1.0)*x621*x622))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x620))+((new_r10*x621)));
evalcond[7]=((((-1.0)*x622))+((new_r00*x621))+((new_r10*x620)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x623=((1.0)*new_r11);
CheckValue<IkReal> x624=IKPowWithIntegerCheck(IKsign(((((-1.0)*gconst84*x623))+((gconst83*new_r01)))),-1);
if(!x624.valid){
continue;
}
CheckValue<IkReal> x625 = IKatan2WithCheck(IkReal(((((-1.0)*new_r01*x623))+((gconst83*gconst84)))),IkReal(((((-1.0)*(gconst83*gconst83)))+(new_r11*new_r11))),IKFAST_ATAN2_MAGTHRESH);
if(!x625.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x624.value)))+(x625.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x626=IKcos(j1);
IkReal x627=IKsin(j1);
IkReal x628=((1.0)*gconst84);
IkReal x629=(gconst83*x626);
IkReal x630=((1.0)*x627);
IkReal x631=(x627*x628);
evalcond[0]=(gconst83+((new_r01*x626))+((new_r11*x627)));
evalcond[1]=(((gconst83*x627))+((gconst84*x626))+new_r11);
evalcond[2]=((((-1.0)*new_r00*x630))+gconst83+((new_r10*x626)));
evalcond[3]=((((-1.0)*new_r01*x630))+gconst84+((new_r11*x626)));
evalcond[4]=((((-1.0)*x631))+x629+new_r01);
evalcond[5]=((((-1.0)*x631))+x629+new_r10);
evalcond[6]=((((-1.0)*x628))+((new_r00*x626))+((new_r10*x627)));
evalcond[7]=((((-1.0)*gconst83*x630))+(((-1.0)*x626*x628))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x632=((1.0)*gconst83);
CheckValue<IkReal> x633 = IKatan2WithCheck(IkReal((((gconst84*new_r01))+(((-1.0)*new_r11*x632)))),IkReal(((((-1.0)*new_r01*x632))+(((-1.0)*gconst84*new_r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x633.valid){
continue;
}
CheckValue<IkReal> x634=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x634.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x633.value)+(((1.5707963267949)*(x634.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x635=IKcos(j1);
IkReal x636=IKsin(j1);
IkReal x637=((1.0)*gconst84);
IkReal x638=(gconst83*x635);
IkReal x639=((1.0)*x636);
IkReal x640=(x636*x637);
evalcond[0]=(gconst83+((new_r01*x635))+((new_r11*x636)));
evalcond[1]=(((gconst83*x636))+((gconst84*x635))+new_r11);
evalcond[2]=((((-1.0)*new_r00*x639))+gconst83+((new_r10*x635)));
evalcond[3]=((((-1.0)*new_r01*x639))+gconst84+((new_r11*x635)));
evalcond[4]=((((-1.0)*x640))+x638+new_r01);
evalcond[5]=((((-1.0)*x640))+x638+new_r10);
evalcond[6]=((((-1.0)*x637))+((new_r00*x635))+((new_r10*x636)));
evalcond[7]=((((-1.0)*x635*x637))+(((-1.0)*gconst83*x639))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x641=((1.0)*gconst83);
CheckValue<IkReal> x642 = IKatan2WithCheck(IkReal(((((-1.0)*new_r10*x641))+((gconst83*new_r01)))),IkReal(((((-1.0)*new_r11*x641))+(((-1.0)*new_r00*x641)))),IKFAST_ATAN2_MAGTHRESH);
if(!x642.valid){
continue;
}
CheckValue<IkReal> x643=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x643.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x642.value)+(((1.5707963267949)*(x643.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x644=IKcos(j1);
IkReal x645=IKsin(j1);
IkReal x646=((1.0)*gconst84);
IkReal x647=(gconst83*x644);
IkReal x648=((1.0)*x645);
IkReal x649=(x645*x646);
evalcond[0]=(gconst83+((new_r11*x645))+((new_r01*x644)));
evalcond[1]=(((gconst83*x645))+new_r11+((gconst84*x644)));
evalcond[2]=(gconst83+((new_r10*x644))+(((-1.0)*new_r00*x648)));
evalcond[3]=(gconst84+((new_r11*x644))+(((-1.0)*new_r01*x648)));
evalcond[4]=((((-1.0)*x649))+x647+new_r01);
evalcond[5]=((((-1.0)*x649))+x647+new_r10);
evalcond[6]=((((-1.0)*x646))+((new_r10*x645))+((new_r00*x644)));
evalcond[7]=((((-1.0)*x644*x646))+(((-1.0)*gconst83*x648))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x651 = ((new_r01*new_r01)+(new_r11*new_r11));
if(IKabs(x651)==0){
continue;
}
IkReal x650=pow(x651,-0.5);
CheckValue<IkReal> x652 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x652.valid){
continue;
}
IkReal gconst85=((3.14159265358979)+(((-1.0)*(x652.value))));
IkReal gconst86=((1.0)*new_r01*x650);
IkReal gconst87=((-1.0)*new_r11*x650);
CheckValue<IkReal> x653 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x653.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x653.value)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
CheckValue<IkReal> x656 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x656.valid){
continue;
}
IkReal x654=((1.0)*(x656.value));
IkReal x655=x650;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst86;
cj3=gconst87;
j3=((3.14159265)+(((-1.0)*x654)));
IkReal gconst85=((3.14159265358979)+(((-1.0)*x654)));
IkReal gconst86=((1.0)*new_r01*x655);
IkReal gconst87=((-1.0)*new_r11*x655);
IkReal x657=new_r01*new_r01;
IkReal x658=(((new_r10*new_r11))+((new_r00*new_r01)));
IkReal x659=x650;
IkReal x660=((1.0)*new_r01*x659);
j1eval[0]=x658;
j1eval[1]=IKsign(x658);
j1eval[2]=((IKabs(((((-1.0)*new_r10*x660))+((x657*x659)))))+(IKabs(((((-1.0)*new_r11*x660))+(((-1.0)*new_r00*x660))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
CheckValue<IkReal> x663 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x663.valid){
continue;
}
IkReal x661=((1.0)*(x663.value));
IkReal x662=x650;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst86;
cj3=gconst87;
j3=((3.14159265)+(((-1.0)*x661)));
IkReal gconst85=((3.14159265358979)+(((-1.0)*x661)));
IkReal gconst86=((1.0)*new_r01*x662);
IkReal gconst87=((-1.0)*new_r11*x662);
IkReal x664=((new_r01*new_r01)+(new_r11*new_r11));
j1eval[0]=x664;
j1eval[1]=IKsign(x664);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x667 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x667.valid){
continue;
}
IkReal x665=((1.0)*(x667.value));
IkReal x666=x650;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst86;
cj3=gconst87;
j3=((3.14159265)+(((-1.0)*x665)));
IkReal gconst85=((3.14159265358979)+(((-1.0)*x665)));
IkReal gconst86=((1.0)*new_r01*x666);
IkReal gconst87=((-1.0)*new_r11*x666);
IkReal x668=new_r01*new_r01;
IkReal x669=new_r11*new_r11;
IkReal x670=((1.0)*x668);
CheckValue<IkReal> x676=IKPowWithIntegerCheck((x669+x668),-1);
if(!x676.valid){
continue;
}
IkReal x671=x676.value;
CheckValue<IkReal> x677=IKPowWithIntegerCheck(((((-1.0)*x669))+(((-1.0)*x670))),-1);
if(!x677.valid){
continue;
}
IkReal x672=x677.value;
IkReal x673=((1.0)*x672);
IkReal x674=(new_r11*x673);
IkReal x675=(new_r01*x673);
j1eval[0]=((IKabs((((x668*x669*x671))+(((-1.0)*x670*x671))+((x671*(x669*x669))))))+(IKabs(((((-1.0)*new_r01*x674))+(((-1.0)*new_r01*x674*(new_r11*new_r11)))+(((-1.0)*x674*(new_r01*new_r01*new_r01)))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
CheckValue<IkReal> x679 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x679.valid){
continue;
}
IkReal x678=((1.0)*(x679.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst86;
cj3=gconst87;
j3=((3.14159265)+(((-1.0)*x678)));
new_r11=0;
new_r00=0;
IkReal gconst85=((3.14159265358979)+(((-1.0)*x678)));
IkReal x680 = new_r01*new_r01;
if(IKabs(x680)==0){
continue;
}
IkReal gconst86=((1.0)*new_r01*(pow(x680,-0.5)));
IkReal gconst87=0;
j1eval[0]=new_r01;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x682 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x682.valid){
continue;
}
IkReal x681=((1.0)*(x682.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst86;
cj3=gconst87;
j3=((3.14159265)+(((-1.0)*x681)));
new_r11=0;
new_r00=0;
IkReal gconst85=((3.14159265358979)+(((-1.0)*x681)));
IkReal x683 = new_r01*new_r01;
if(IKabs(x683)==0){
continue;
}
IkReal gconst86=((1.0)*new_r01*(pow(x683,-0.5)));
IkReal gconst87=0;
j1eval[0]=new_r10;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x684=IKPowWithIntegerCheck(gconst86,-1);
if(!x684.valid){
continue;
}
cj1array[0]=((-1.0)*new_r01*(x684.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x685=IKsin(j1);
IkReal x686=IKcos(j1);
evalcond[0]=(new_r10*x685);
evalcond[1]=(gconst86*x685);
evalcond[2]=((-1.0)*new_r01*x685);
evalcond[3]=(gconst86+((new_r01*x686)));
evalcond[4]=(gconst86+((new_r10*x686)));
evalcond[5]=(new_r10+((gconst86*x686)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x687=IKPowWithIntegerCheck(new_r10,-1);
if(!x687.valid){
continue;
}
cj1array[0]=((-1.0)*gconst86*(x687.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x688=IKsin(j1);
IkReal x689=IKcos(j1);
IkReal x690=(gconst86*x689);
evalcond[0]=(new_r10*x688);
evalcond[1]=(gconst86*x688);
evalcond[2]=((-1.0)*new_r01*x688);
evalcond[3]=(gconst86+((new_r01*x689)));
evalcond[4]=(x690+new_r01);
evalcond[5]=(x690+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x691=IKPowWithIntegerCheck(new_r01,-1);
if(!x691.valid){
continue;
}
cj1array[0]=((-1.0)*gconst86*(x691.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x692=IKsin(j1);
IkReal x693=IKcos(j1);
IkReal x694=(gconst86*x693);
evalcond[0]=(new_r10*x692);
evalcond[1]=(gconst86*x692);
evalcond[2]=((-1.0)*new_r01*x692);
evalcond[3]=(gconst86+((new_r10*x693)));
evalcond[4]=(x694+new_r01);
evalcond[5]=(x694+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
evalcond[1]=gconst86;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[4];
CheckValue<IkReal> x696 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x696.valid){
continue;
}
IkReal x695=((1.0)*(x696.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst86;
cj3=gconst87;
j3=((3.14159265)+(((-1.0)*x695)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst85=((3.14159265358979)+(((-1.0)*x695)));
IkReal gconst86=((1.0)*new_r01);
IkReal gconst87=((-1.0)*new_r11);
j1eval[0]=1.0;
j1eval[1]=new_r01;
j1eval[2]=1.0;
j1eval[3]=1.0;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  || IKabs(j1eval[3]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
CheckValue<IkReal> x698 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x698.valid){
continue;
}
IkReal x697=((1.0)*(x698.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst86;
cj3=gconst87;
j3=((3.14159265)+(((-1.0)*x697)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst85=((3.14159265358979)+(((-1.0)*x697)));
IkReal gconst86=((1.0)*new_r01);
IkReal gconst87=((-1.0)*new_r11);
j1eval[0]=-1.0;
j1eval[1]=((IKabs(((-1.0)+(new_r01*new_r01))))+(IKabs(((1.0)*new_r01*new_r11))));
j1eval[2]=-1.0;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
CheckValue<IkReal> x700 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x700.valid){
continue;
}
IkReal x699=((1.0)*(x700.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst86;
cj3=gconst87;
j3=((3.14159265)+(((-1.0)*x699)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst85=((3.14159265358979)+(((-1.0)*x699)));
IkReal gconst86=((1.0)*new_r01);
IkReal gconst87=((-1.0)*new_r11);
j1eval[0]=1.0;
j1eval[1]=((IKabs(((2.0)*new_r01*new_r11)))+(IKabs(((1.0)+(((-2.0)*(new_r01*new_r01)))))));
j1eval[2]=1.0;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x701=((1.0)*gconst86);
CheckValue<IkReal> x702 = IKatan2WithCheck(IkReal((((gconst87*new_r01))+(((-1.0)*new_r11*x701)))),IkReal(((((-1.0)*gconst87*new_r11))+(((-1.0)*new_r01*x701)))),IKFAST_ATAN2_MAGTHRESH);
if(!x702.valid){
continue;
}
CheckValue<IkReal> x703=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x703.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x702.value)+(((1.5707963267949)*(x703.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x704=IKsin(j1);
IkReal x705=IKcos(j1);
IkReal x706=(gconst86*x705);
IkReal x707=((1.0)*x704);
IkReal x708=(gconst87*x705);
IkReal x709=(gconst87*x707);
evalcond[0]=(((new_r01*x705))+gconst86+((new_r11*x704)));
evalcond[1]=(((gconst86*x704))+x708+new_r11);
evalcond[2]=((((-1.0)*x709))+x706);
evalcond[3]=(gconst87+((new_r11*x705))+(((-1.0)*new_r01*x707)));
evalcond[4]=((((-1.0)*x709))+x706+new_r01);
evalcond[5]=((((-1.0)*x708))+(((-1.0)*gconst86*x707)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x710=IKPowWithIntegerCheck(IKsign(((((-1.0)*(gconst86*gconst86)))+(((-1.0)*(gconst87*gconst87))))),-1);
if(!x710.valid){
continue;
}
CheckValue<IkReal> x711 = IKatan2WithCheck(IkReal((gconst86*new_r11)),IkReal((gconst87*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x711.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x710.value)))+(x711.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x712=IKsin(j1);
IkReal x713=IKcos(j1);
IkReal x714=(gconst86*x713);
IkReal x715=((1.0)*x712);
IkReal x716=(gconst87*x713);
IkReal x717=(gconst87*x715);
evalcond[0]=(((new_r01*x713))+gconst86+((new_r11*x712)));
evalcond[1]=(((gconst86*x712))+x716+new_r11);
evalcond[2]=((((-1.0)*x717))+x714);
evalcond[3]=(gconst87+((new_r11*x713))+(((-1.0)*new_r01*x715)));
evalcond[4]=((((-1.0)*x717))+x714+new_r01);
evalcond[5]=((((-1.0)*x716))+(((-1.0)*gconst86*x715)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x718=IKPowWithIntegerCheck(IKsign(((((-1.0)*gconst87*new_r11))+((gconst86*new_r01)))),-1);
if(!x718.valid){
continue;
}
CheckValue<IkReal> x719 = IKatan2WithCheck(IkReal((gconst86*gconst87)),IkReal(((-1.0)*(gconst86*gconst86))),IKFAST_ATAN2_MAGTHRESH);
if(!x719.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x718.value)))+(x719.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x720=IKsin(j1);
IkReal x721=IKcos(j1);
IkReal x722=(gconst86*x721);
IkReal x723=((1.0)*x720);
IkReal x724=(gconst87*x721);
IkReal x725=(gconst87*x723);
evalcond[0]=(gconst86+((new_r01*x721))+((new_r11*x720)));
evalcond[1]=(((gconst86*x720))+x724+new_r11);
evalcond[2]=((((-1.0)*x725))+x722);
evalcond[3]=(gconst87+((new_r11*x721))+(((-1.0)*new_r01*x723)));
evalcond[4]=((((-1.0)*x725))+x722+new_r01);
evalcond[5]=((((-1.0)*gconst86*x723))+(((-1.0)*x724)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x726=IKPowWithIntegerCheck(gconst87,-1);
if(!x726.valid){
continue;
}
cj1array[0]=(new_r00*(x726.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x727=IKsin(j1);
IkReal x728=IKcos(j1);
IkReal x729=((-1.0)*x727);
evalcond[0]=(new_r11*x727);
evalcond[1]=(new_r00*x729);
evalcond[2]=(gconst87*x729);
evalcond[3]=(((gconst87*x728))+new_r11);
evalcond[4]=(gconst87+((new_r11*x728)));
evalcond[5]=(((new_r00*x728))+(((-1.0)*gconst87)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
CheckValue<IkReal> x731 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x731.valid){
continue;
}
IkReal x730=((1.0)*(x731.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst86;
cj3=gconst87;
j3=((3.14159265)+(((-1.0)*x730)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst85=((3.14159265358979)+(((-1.0)*x730)));
IkReal gconst86=0;
IkReal x732 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x732)==0){
continue;
}
IkReal gconst87=((-1.0)*new_r11*(pow(x732,-0.5)));
j1eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x734 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x734.valid){
continue;
}
IkReal x733=((1.0)*(x734.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst86;
cj3=gconst87;
j3=((3.14159265)+(((-1.0)*x733)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst85=((3.14159265358979)+(((-1.0)*x733)));
IkReal gconst86=0;
IkReal x735 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x735)==0){
continue;
}
IkReal gconst87=((-1.0)*new_r11*(pow(x735,-0.5)));
j1eval[0]=new_r11;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x737 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x737.valid){
continue;
}
IkReal x736=((1.0)*(x737.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst86;
cj3=gconst87;
j3=((3.14159265)+(((-1.0)*x736)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst85=((3.14159265358979)+(((-1.0)*x736)));
IkReal gconst86=0;
IkReal x738 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x738)==0){
continue;
}
IkReal gconst87=((-1.0)*new_r11*(pow(x738,-0.5)));
j1eval[0]=new_r10;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x739=IKPowWithIntegerCheck(new_r10,-1);
if(!x739.valid){
continue;
}
CheckValue<IkReal> x740=IKPowWithIntegerCheck(gconst87,-1);
if(!x740.valid){
continue;
}
if( IKabs((gconst87*(x739.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11*(x740.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((gconst87*(x739.value)))+IKsqr(((-1.0)*new_r11*(x740.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((gconst87*(x739.value)), ((-1.0)*new_r11*(x740.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x741=IKsin(j1);
IkReal x742=IKcos(j1);
IkReal x743=(gconst87*x741);
IkReal x744=(gconst87*x742);
evalcond[0]=(new_r11*x741);
evalcond[1]=(new_r10*x742);
evalcond[2]=((-1.0)*x743);
evalcond[3]=((-1.0)*x744);
evalcond[4]=(x744+new_r11);
evalcond[5]=(gconst87+((new_r11*x742)));
evalcond[6]=((((-1.0)*x743))+new_r10);
evalcond[7]=((((-1.0)*gconst87))+((new_r10*x741)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x745=IKPowWithIntegerCheck(gconst87,-1);
if(!x745.valid){
continue;
}
CheckValue<IkReal> x746=IKPowWithIntegerCheck(new_r11,-1);
if(!x746.valid){
continue;
}
if( IKabs((new_r10*(x745.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst87*(x746.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x745.value)))+IKsqr(((-1.0)*gconst87*(x746.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((new_r10*(x745.value)), ((-1.0)*gconst87*(x746.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x747=IKsin(j1);
IkReal x748=IKcos(j1);
IkReal x749=(gconst87*x747);
IkReal x750=(gconst87*x748);
evalcond[0]=(new_r11*x747);
evalcond[1]=(new_r10*x748);
evalcond[2]=((-1.0)*x749);
evalcond[3]=((-1.0)*x750);
evalcond[4]=(x750+new_r11);
evalcond[5]=(gconst87+((new_r11*x748)));
evalcond[6]=((((-1.0)*x749))+new_r10);
evalcond[7]=((((-1.0)*gconst87))+((new_r10*x747)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x751 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x751.valid){
continue;
}
CheckValue<IkReal> x752=IKPowWithIntegerCheck(IKsign(gconst87),-1);
if(!x752.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x751.value)+(((1.5707963267949)*(x752.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x753=IKsin(j1);
IkReal x754=IKcos(j1);
IkReal x755=(gconst87*x753);
IkReal x756=(gconst87*x754);
evalcond[0]=(new_r11*x753);
evalcond[1]=(new_r10*x754);
evalcond[2]=((-1.0)*x755);
evalcond[3]=((-1.0)*x756);
evalcond[4]=(x756+new_r11);
evalcond[5]=(gconst87+((new_r11*x754)));
evalcond[6]=((((-1.0)*x755))+new_r10);
evalcond[7]=((((-1.0)*gconst87))+((new_r10*x753)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r01);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
CheckValue<IkReal> x758 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x758.valid){
continue;
}
IkReal x757=((1.0)*(x758.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst86;
cj3=gconst87;
j3=((3.14159265)+(((-1.0)*x757)));
new_r01=0;
IkReal gconst85=((3.14159265358979)+(((-1.0)*x757)));
IkReal gconst86=0;
IkReal x759 = new_r11*new_r11;
if(IKabs(x759)==0){
continue;
}
IkReal gconst87=((-1.0)*new_r11*(pow(x759,-0.5)));
j1eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x761 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x761.valid){
continue;
}
IkReal x760=((1.0)*(x761.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst86;
cj3=gconst87;
j3=((3.14159265)+(((-1.0)*x760)));
new_r01=0;
IkReal gconst85=((3.14159265358979)+(((-1.0)*x760)));
IkReal gconst86=0;
IkReal x762 = new_r11*new_r11;
if(IKabs(x762)==0){
continue;
}
IkReal gconst87=((-1.0)*new_r11*(pow(x762,-0.5)));
j1eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x764 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x764.valid){
continue;
}
IkReal x763=((1.0)*(x764.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst86;
cj3=gconst87;
j3=((3.14159265)+(((-1.0)*x763)));
new_r01=0;
IkReal gconst85=((3.14159265358979)+(((-1.0)*x763)));
IkReal gconst86=0;
IkReal x765 = new_r11*new_r11;
if(IKabs(x765)==0){
continue;
}
IkReal gconst87=((-1.0)*new_r11*(pow(x765,-0.5)));
j1eval[0]=new_r11;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x766=IKPowWithIntegerCheck(gconst87,-1);
if(!x766.valid){
continue;
}
CheckValue<IkReal> x767=IKPowWithIntegerCheck(new_r11,-1);
if(!x767.valid){
continue;
}
if( IKabs((new_r10*(x766.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst87*(x767.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x766.value)))+IKsqr(((-1.0)*gconst87*(x767.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((new_r10*(x766.value)), ((-1.0)*gconst87*(x767.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x768=IKsin(j1);
IkReal x769=IKcos(j1);
IkReal x770=((1.0)*gconst87);
evalcond[0]=(new_r11*x768);
evalcond[1]=((-1.0)*gconst87*x768);
evalcond[2]=(((gconst87*x769))+new_r11);
evalcond[3]=(((new_r11*x769))+gconst87);
evalcond[4]=((((-1.0)*x768*x770))+new_r10);
evalcond[5]=((((-1.0)*x769*x770))+new_r00);
evalcond[6]=(((new_r10*x769))+(((-1.0)*new_r00*x768)));
evalcond[7]=(((new_r10*x768))+((new_r00*x769))+(((-1.0)*x770)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x771 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x771.valid){
continue;
}
CheckValue<IkReal> x772=IKPowWithIntegerCheck(IKsign(gconst87),-1);
if(!x772.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x771.value)+(((1.5707963267949)*(x772.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x773=IKsin(j1);
IkReal x774=IKcos(j1);
IkReal x775=((1.0)*gconst87);
evalcond[0]=(new_r11*x773);
evalcond[1]=((-1.0)*gconst87*x773);
evalcond[2]=(((gconst87*x774))+new_r11);
evalcond[3]=(gconst87+((new_r11*x774)));
evalcond[4]=((((-1.0)*x773*x775))+new_r10);
evalcond[5]=((((-1.0)*x774*x775))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x773))+((new_r10*x774)));
evalcond[7]=(((new_r00*x774))+((new_r10*x773))+(((-1.0)*x775)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x776 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x776.valid){
continue;
}
CheckValue<IkReal> x777=IKPowWithIntegerCheck(IKsign(gconst87),-1);
if(!x777.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x776.value)+(((1.5707963267949)*(x777.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x778=IKsin(j1);
IkReal x779=IKcos(j1);
IkReal x780=((1.0)*gconst87);
evalcond[0]=(new_r11*x778);
evalcond[1]=((-1.0)*gconst87*x778);
evalcond[2]=(((gconst87*x779))+new_r11);
evalcond[3]=(gconst87+((new_r11*x779)));
evalcond[4]=(new_r10+(((-1.0)*x778*x780)));
evalcond[5]=(new_r00+(((-1.0)*x779*x780)));
evalcond[6]=((((-1.0)*new_r00*x778))+((new_r10*x779)));
evalcond[7]=((((-1.0)*x780))+((new_r00*x779))+((new_r10*x778)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x781=((1.0)*new_r11);
CheckValue<IkReal> x782 = IKatan2WithCheck(IkReal(((((-1.0)*new_r01*x781))+((gconst86*gconst87)))),IkReal(((((-1.0)*(gconst86*gconst86)))+(new_r11*new_r11))),IKFAST_ATAN2_MAGTHRESH);
if(!x782.valid){
continue;
}
CheckValue<IkReal> x783=IKPowWithIntegerCheck(IKsign((((gconst86*new_r01))+(((-1.0)*gconst87*x781)))),-1);
if(!x783.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x782.value)+(((1.5707963267949)*(x783.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x784=IKsin(j1);
IkReal x785=IKcos(j1);
IkReal x786=((1.0)*gconst87);
IkReal x787=(gconst86*x785);
IkReal x788=(gconst86*x784);
IkReal x789=((1.0)*x784);
IkReal x790=(x784*x786);
evalcond[0]=(((new_r11*x784))+gconst86+((new_r01*x785)));
evalcond[1]=(x788+new_r11+((gconst87*x785)));
evalcond[2]=(((new_r10*x785))+gconst86+(((-1.0)*new_r00*x789)));
evalcond[3]=((((-1.0)*new_r01*x789))+((new_r11*x785))+gconst87);
evalcond[4]=((((-1.0)*x790))+x787+new_r01);
evalcond[5]=((((-1.0)*x790))+x787+new_r10);
evalcond[6]=(((new_r10*x784))+(((-1.0)*x786))+((new_r00*x785)));
evalcond[7]=((((-1.0)*x788))+new_r00+(((-1.0)*x785*x786)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x791=((1.0)*gconst86);
CheckValue<IkReal> x792 = IKatan2WithCheck(IkReal((((gconst87*new_r01))+(((-1.0)*new_r11*x791)))),IkReal(((((-1.0)*gconst87*new_r11))+(((-1.0)*new_r01*x791)))),IKFAST_ATAN2_MAGTHRESH);
if(!x792.valid){
continue;
}
CheckValue<IkReal> x793=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x793.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x792.value)+(((1.5707963267949)*(x793.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x794=IKsin(j1);
IkReal x795=IKcos(j1);
IkReal x796=((1.0)*gconst87);
IkReal x797=(gconst86*x795);
IkReal x798=(gconst86*x794);
IkReal x799=((1.0)*x794);
IkReal x800=(x794*x796);
evalcond[0]=(((new_r11*x794))+gconst86+((new_r01*x795)));
evalcond[1]=(x798+new_r11+((gconst87*x795)));
evalcond[2]=(((new_r10*x795))+gconst86+(((-1.0)*new_r00*x799)));
evalcond[3]=((((-1.0)*new_r01*x799))+((new_r11*x795))+gconst87);
evalcond[4]=(x797+new_r01+(((-1.0)*x800)));
evalcond[5]=(x797+new_r10+(((-1.0)*x800)));
evalcond[6]=((((-1.0)*x796))+((new_r10*x794))+((new_r00*x795)));
evalcond[7]=((((-1.0)*x795*x796))+(((-1.0)*x798))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x801=((1.0)*gconst86);
CheckValue<IkReal> x802 = IKatan2WithCheck(IkReal((((gconst86*new_r01))+(((-1.0)*new_r10*x801)))),IkReal(((((-1.0)*new_r00*x801))+(((-1.0)*new_r11*x801)))),IKFAST_ATAN2_MAGTHRESH);
if(!x802.valid){
continue;
}
CheckValue<IkReal> x803=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x803.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x802.value)+(((1.5707963267949)*(x803.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x804=IKsin(j1);
IkReal x805=IKcos(j1);
IkReal x806=((1.0)*gconst87);
IkReal x807=(gconst86*x805);
IkReal x808=(gconst86*x804);
IkReal x809=((1.0)*x804);
IkReal x810=(x804*x806);
evalcond[0]=(gconst86+((new_r11*x804))+((new_r01*x805)));
evalcond[1]=(((gconst87*x805))+new_r11+x808);
evalcond[2]=((((-1.0)*new_r00*x809))+gconst86+((new_r10*x805)));
evalcond[3]=((((-1.0)*new_r01*x809))+gconst87+((new_r11*x805)));
evalcond[4]=((((-1.0)*x810))+new_r01+x807);
evalcond[5]=((((-1.0)*x810))+new_r10+x807);
evalcond[6]=(((new_r00*x805))+((new_r10*x804))+(((-1.0)*x806)));
evalcond[7]=((((-1.0)*x808))+(((-1.0)*x805*x806))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((new_r01*new_r01)+(new_r11*new_r11));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
new_r01=0;
new_r11=0;
j1eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x812 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x812.valid){
continue;
}
IkReal x811=x812.value;
j1array[0]=((-1.0)*x811);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x811)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r00*(IKsin(j1))))+((new_r10*(IKcos(j1)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x813=IKcos(j1);
IkReal x814=IKsin(j1);
IkReal x815=((1.0)*x814);
evalcond[0]=(new_r11+x813);
evalcond[1]=((((-1.0)*x815))+new_r01);
evalcond[2]=((((-1.0)*x815))+new_r10);
evalcond[3]=((((-1.0)*x813))+new_r00);
evalcond[4]=(((new_r11*x814))+((new_r01*x813)));
evalcond[5]=((-1.0)+((new_r00*x813))+((new_r10*x814)));
evalcond[6]=(((new_r10*x813))+(((-1.0)*new_r00*x815)));
evalcond[7]=((1.0)+((new_r11*x813))+(((-1.0)*new_r01*x815)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((-1.0)*new_r01), ((-1.0)*new_r00));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x816=IKsin(j1);
IkReal x817=IKcos(j1);
IkReal x818=((1.0)*x816);
evalcond[0]=(new_r01+x816);
evalcond[1]=(new_r10+x816);
evalcond[2]=(new_r00+x817);
evalcond[3]=((((-1.0)*x817))+new_r11);
evalcond[4]=(((new_r11*x816))+((new_r01*x817)));
evalcond[5]=((1.0)+((new_r00*x817))+((new_r10*x816)));
evalcond[6]=(((new_r10*x817))+(((-1.0)*new_r00*x818)));
evalcond[7]=((-1.0)+((new_r11*x817))+(((-1.0)*new_r01*x818)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
new_r11=0;
new_r00=0;
j1eval[0]=new_r01;
j1eval[1]=((IKabs(cj3))+(IKabs(sj3)));
j1eval[2]=IKsign(new_r01);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
new_r11=0;
new_r00=0;
j1eval[0]=new_r01;
j1eval[1]=new_r10;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x819=IKPowWithIntegerCheck(new_r01,-1);
if(!x819.valid){
continue;
}
CheckValue<IkReal> x820=IKPowWithIntegerCheck(new_r10,-1);
if(!x820.valid){
continue;
}
if( IKabs((cj3*(x819.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*sj3*(x820.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((cj3*(x819.value)))+IKsqr(((-1.0)*sj3*(x820.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((cj3*(x819.value)), ((-1.0)*sj3*(x820.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[7];
IkReal x821=IKcos(j1);
IkReal x822=IKsin(j1);
IkReal x823=(sj3*x821);
IkReal x824=((1.0)*x822);
IkReal x825=(cj3*x824);
evalcond[0]=(sj3+((new_r01*x821)));
evalcond[1]=(sj3+((new_r10*x821)));
evalcond[2]=(cj3+(((-1.0)*new_r01*x824)));
evalcond[3]=(((new_r10*x822))+(((-1.0)*cj3)));
evalcond[4]=(((sj3*x822))+((cj3*x821)));
evalcond[5]=((((-1.0)*x825))+new_r01+x823);
evalcond[6]=((((-1.0)*x825))+new_r10+x823);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x826=IKPowWithIntegerCheck(IKsign(new_r01),-1);
if(!x826.valid){
continue;
}
CheckValue<IkReal> x827 = IKatan2WithCheck(IkReal(cj3),IkReal(((-1.0)*sj3)),IKFAST_ATAN2_MAGTHRESH);
if(!x827.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x826.value)))+(x827.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[7];
IkReal x828=IKcos(j1);
IkReal x829=IKsin(j1);
IkReal x830=(sj3*x828);
IkReal x831=((1.0)*x829);
IkReal x832=(cj3*x831);
evalcond[0]=(sj3+((new_r01*x828)));
evalcond[1]=(sj3+((new_r10*x828)));
evalcond[2]=(cj3+(((-1.0)*new_r01*x831)));
evalcond[3]=(((new_r10*x829))+(((-1.0)*cj3)));
evalcond[4]=(((sj3*x829))+((cj3*x828)));
evalcond[5]=((((-1.0)*x832))+new_r01+x830);
evalcond[6]=((((-1.0)*x832))+new_r10+x830);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
new_r11=0;
new_r01=0;
new_r22=0;
new_r20=0;
j1eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x834 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x834.valid){
continue;
}
IkReal x833=x834.value;
j1array[0]=((-1.0)*x833);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x833)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r00*(IKsin(j1))))+((new_r10*(IKcos(j1)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
j1eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x836 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x836.valid){
continue;
}
IkReal x835=x836.value;
j1array[0]=((-1.0)*x835);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x835)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
evalcond[0]=(((new_r11*(IKcos(j1))))+(((-1.0)*new_r01*(IKsin(j1)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
new_r01=0;
new_r10=0;
j1eval[0]=new_r11;
j1eval[1]=IKsign(new_r11);
j1eval[2]=((IKabs(cj3))+(IKabs(sj3)));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
new_r01=0;
new_r10=0;
j1eval[0]=new_r00;
j1eval[1]=new_r11;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
new_r01=0;
new_r10=0;
j1eval[0]=new_r11;
j1eval[1]=cj3;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
sj1array[0]=new_r00;
if( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x837=IKcos(j1);
IkReal x838=IKsin(j1);
evalcond[0]=x837;
evalcond[1]=(new_r00*x837);
evalcond[2]=(new_r11+x838);
evalcond[3]=(new_r11*x837);
evalcond[4]=((1.0)+((new_r11*x838)));
evalcond[5]=((1.0)+(((-1.0)*new_r00*x838)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
sj1array[0]=new_r11;
if( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x839=IKcos(j1);
IkReal x840=IKsin(j1);
evalcond[0]=(new_r00*x839);
evalcond[1]=(new_r11*x839);
evalcond[2]=((-1.0)*x839);
evalcond[3]=(new_r00+x840);
evalcond[4]=((-1.0)+((new_r11*x840)));
evalcond[5]=((-1.0)+(((-1.0)*new_r00*x840)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x842=IKPowWithIntegerCheck(new_r11,-1);
if(!x842.valid){
continue;
}
IkReal x841=x842.value;
CheckValue<IkReal> x843=IKPowWithIntegerCheck(cj3,-1);
if(!x843.valid){
continue;
}
CheckValue<IkReal> x844=IKPowWithIntegerCheck(x841,-2);
if(!x844.valid){
continue;
}
if( IKabs(((-1.0)*sj3*x841)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x841*(x843.value)*(((1.0)+(((-1.0)*(cj3*cj3)))+(((-1.0)*(x844.value))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*sj3*x841))+IKsqr((x841*(x843.value)*(((1.0)+(((-1.0)*(cj3*cj3)))+(((-1.0)*(x844.value)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((-1.0)*sj3*x841), (x841*(x843.value)*(((1.0)+(((-1.0)*(cj3*cj3)))+(((-1.0)*(x844.value)))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[7];
IkReal x845=IKsin(j1);
IkReal x846=IKcos(j1);
IkReal x847=((1.0)*cj3);
IkReal x848=(sj3*x845);
IkReal x849=(cj3*x846);
evalcond[0]=(sj3+((new_r11*x845)));
evalcond[1]=(cj3+((new_r11*x846)));
evalcond[2]=(sj3+(((-1.0)*new_r00*x845)));
evalcond[3]=(((new_r00*x846))+(((-1.0)*x847)));
evalcond[4]=(new_r11+x849+x848);
evalcond[5]=((((-1.0)*x845*x847))+((sj3*x846)));
evalcond[6]=((((-1.0)*x846*x847))+(((-1.0)*x848))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x850=IKPowWithIntegerCheck(new_r00,-1);
if(!x850.valid){
continue;
}
CheckValue<IkReal> x851=IKPowWithIntegerCheck(new_r11,-1);
if(!x851.valid){
continue;
}
if( IKabs((sj3*(x850.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*cj3*(x851.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((sj3*(x850.value)))+IKsqr(((-1.0)*cj3*(x851.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((sj3*(x850.value)), ((-1.0)*cj3*(x851.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[7];
IkReal x852=IKsin(j1);
IkReal x853=IKcos(j1);
IkReal x854=((1.0)*cj3);
IkReal x855=(sj3*x852);
IkReal x856=(cj3*x853);
evalcond[0]=(sj3+((new_r11*x852)));
evalcond[1]=(cj3+((new_r11*x853)));
evalcond[2]=(sj3+(((-1.0)*new_r00*x852)));
evalcond[3]=((((-1.0)*x854))+((new_r00*x853)));
evalcond[4]=(new_r11+x856+x855);
evalcond[5]=((((-1.0)*x852*x854))+((sj3*x853)));
evalcond[6]=((((-1.0)*x853*x854))+(((-1.0)*x855))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x857 = IKatan2WithCheck(IkReal(((-1.0)*sj3)),IkReal(((-1.0)*cj3)),IKFAST_ATAN2_MAGTHRESH);
if(!x857.valid){
continue;
}
CheckValue<IkReal> x858=IKPowWithIntegerCheck(IKsign(new_r11),-1);
if(!x858.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x857.value)+(((1.5707963267949)*(x858.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[7];
IkReal x859=IKsin(j1);
IkReal x860=IKcos(j1);
IkReal x861=((1.0)*cj3);
IkReal x862=(sj3*x859);
IkReal x863=(cj3*x860);
evalcond[0]=(sj3+((new_r11*x859)));
evalcond[1]=(cj3+((new_r11*x860)));
evalcond[2]=(sj3+(((-1.0)*new_r00*x859)));
evalcond[3]=((((-1.0)*x861))+((new_r00*x860)));
evalcond[4]=(new_r11+x863+x862);
evalcond[5]=(((sj3*x860))+(((-1.0)*x859*x861)));
evalcond[6]=((((-1.0)*x862))+(((-1.0)*x860*x861))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x864 = IKatan2WithCheck(IkReal(((-1.0)+(cj3*cj3)+(new_r01*new_r01))),IkReal(((((-1.0)*cj3*sj3))+(((-1.0)*new_r01*new_r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x864.valid){
continue;
}
CheckValue<IkReal> x865=IKPowWithIntegerCheck(IKsign((((new_r11*sj3))+((cj3*new_r01)))),-1);
if(!x865.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x864.value)+(((1.5707963267949)*(x865.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x866=IKcos(j1);
IkReal x867=IKsin(j1);
IkReal x868=(sj3*x866);
IkReal x869=((1.0)*x867);
IkReal x870=(cj3*x866);
IkReal x871=(cj3*x869);
evalcond[0]=(((new_r01*x866))+sj3+((new_r11*x867)));
evalcond[1]=(((sj3*x867))+new_r11+x870);
evalcond[2]=(sj3+(((-1.0)*new_r00*x869))+((new_r10*x866)));
evalcond[3]=(cj3+(((-1.0)*new_r01*x869))+((new_r11*x866)));
evalcond[4]=(new_r01+x868+(((-1.0)*x871)));
evalcond[5]=(new_r10+x868+(((-1.0)*x871)));
evalcond[6]=(((new_r00*x866))+((new_r10*x867))+(((-1.0)*cj3)));
evalcond[7]=((((-1.0)*x870))+(((-1.0)*sj3*x869))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x872=((1.0)*sj3);
CheckValue<IkReal> x873 = IKatan2WithCheck(IkReal(((((-1.0)*new_r11*x872))+((cj3*new_r01)))),IkReal(((((-1.0)*new_r01*x872))+(((-1.0)*cj3*new_r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x873.valid){
continue;
}
CheckValue<IkReal> x874=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x874.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x873.value)+(((1.5707963267949)*(x874.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x875=IKcos(j1);
IkReal x876=IKsin(j1);
IkReal x877=(sj3*x875);
IkReal x878=((1.0)*x876);
IkReal x879=(cj3*x875);
IkReal x880=(cj3*x878);
evalcond[0]=(((new_r01*x875))+sj3+((new_r11*x876)));
evalcond[1]=(((sj3*x876))+new_r11+x879);
evalcond[2]=(sj3+(((-1.0)*new_r00*x878))+((new_r10*x875)));
evalcond[3]=(cj3+(((-1.0)*new_r01*x878))+((new_r11*x875)));
evalcond[4]=((((-1.0)*x880))+new_r01+x877);
evalcond[5]=((((-1.0)*x880))+new_r10+x877);
evalcond[6]=(((new_r00*x875))+((new_r10*x876))+(((-1.0)*cj3)));
evalcond[7]=((((-1.0)*x879))+(((-1.0)*sj3*x878))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x881=((1.0)*sj3);
CheckValue<IkReal> x882 = IKatan2WithCheck(IkReal(((((-1.0)*new_r10*x881))+((new_r01*sj3)))),IkReal(((((-1.0)*new_r11*x881))+(((-1.0)*new_r00*x881)))),IKFAST_ATAN2_MAGTHRESH);
if(!x882.valid){
continue;
}
CheckValue<IkReal> x883=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x883.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x882.value)+(((1.5707963267949)*(x883.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x884=IKcos(j1);
IkReal x885=IKsin(j1);
IkReal x886=(sj3*x884);
IkReal x887=((1.0)*x885);
IkReal x888=(cj3*x884);
IkReal x889=(cj3*x887);
evalcond[0]=(sj3+((new_r01*x884))+((new_r11*x885)));
evalcond[1]=(((sj3*x885))+new_r11+x888);
evalcond[2]=(sj3+((new_r10*x884))+(((-1.0)*new_r00*x887)));
evalcond[3]=(cj3+((new_r11*x884))+(((-1.0)*new_r01*x887)));
evalcond[4]=((((-1.0)*x889))+new_r01+x886);
evalcond[5]=((((-1.0)*x889))+new_r10+x886);
evalcond[6]=(((new_r10*x885))+((new_r00*x884))+(((-1.0)*cj3)));
evalcond[7]=((((-1.0)*x888))+new_r00+(((-1.0)*sj3*x887)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x890=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj3*x890))+(((-1.0)*new_r11*sj3)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj3*new_r11))+(((-1.0)*sj3*x890)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj3*x890))+(((-1.0)*new_r11*sj3))))+IKsqr((((cj3*new_r11))+(((-1.0)*sj3*x890))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((-1.0)*cj3*x890))+(((-1.0)*new_r11*sj3))), (((cj3*new_r11))+(((-1.0)*sj3*x890))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x891=IKsin(j1);
IkReal x892=IKcos(j1);
IkReal x893=((1.0)*cj3);
IkReal x894=((1.0)*sj3);
IkReal x895=(sj3*x891);
IkReal x896=((1.0)*x891);
IkReal x897=(x892*x893);
evalcond[0]=(sj3+((new_r11*x891))+((new_r01*x892)));
evalcond[1]=(((cj3*x891))+((sj3*x892))+new_r01);
evalcond[2]=((((-1.0)*x897))+new_r11+x895);
evalcond[3]=((((-1.0)*x897))+new_r00+x895);
evalcond[4]=(((new_r00*x892))+((new_r10*x891))+(((-1.0)*x893)));
evalcond[5]=((((-1.0)*x892*x894))+new_r10+(((-1.0)*x891*x893)));
evalcond[6]=(((new_r10*x892))+(((-1.0)*x894))+(((-1.0)*new_r00*x896)));
evalcond[7]=(((new_r11*x892))+(((-1.0)*x893))+(((-1.0)*new_r01*x896)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j1eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j1eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j1eval[0]=((IKabs((new_r10*new_r22)))+(IKabs((new_r00*new_r22))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x899 = IKatan2WithCheck(IkReal((new_r10*new_r22)),IkReal(((-1.0)*new_r00*new_r22)),IKFAST_ATAN2_MAGTHRESH);
if(!x899.valid){
continue;
}
IkReal x898=x899.value;
j1array[0]=((-1.0)*x898);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x898)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x900=IKcos(j1);
IkReal x901=IKsin(j1);
IkReal x902=(new_r11*x900);
IkReal x903=((1.0)*new_r01*x901);
evalcond[0]=(((new_r11*x901))+((new_r01*x900)));
evalcond[1]=(((new_r10*x901))+((new_r00*x900)));
evalcond[2]=(((new_r10*x900))+(((-1.0)*new_r00*x901)));
evalcond[3]=((((-1.0)*x903))+x902);
evalcond[4]=(((new_r22*x902))+(((-1.0)*new_r22*x903)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x905 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x905.valid){
continue;
}
IkReal x904=x905.value;
j1array[0]=((-1.0)*x904);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x904)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x906=IKcos(j1);
IkReal x907=IKsin(j1);
IkReal x908=(new_r22*x906);
IkReal x909=((1.0)*new_r01*x907);
IkReal x910=((1.0)*new_r00*x907);
evalcond[0]=(((new_r11*x907))+((new_r01*x906)));
evalcond[1]=((((-1.0)*x910))+((new_r10*x906)));
evalcond[2]=((((-1.0)*x909))+((new_r11*x906)));
evalcond[3]=((((-1.0)*new_r22*x910))+((new_r10*x908)));
evalcond[4]=(((new_r11*x908))+(((-1.0)*new_r22*x909)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x912 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x912.valid){
continue;
}
IkReal x911=x912.value;
j1array[0]=((-1.0)*x911);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x911)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x913=IKcos(j1);
IkReal x914=IKsin(j1);
IkReal x915=(new_r10*x913);
IkReal x916=(new_r11*x913);
IkReal x917=((1.0)*new_r01*x914);
IkReal x918=((1.0)*new_r00*x914);
evalcond[0]=(((new_r10*x914))+((new_r00*x913)));
evalcond[1]=((((-1.0)*x918))+x915);
evalcond[2]=((((-1.0)*x917))+x916);
evalcond[3]=((((-1.0)*new_r22*x918))+((new_r22*x915)));
evalcond[4]=((((-1.0)*new_r22*x917))+((new_r22*x916)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x920=IKPowWithIntegerCheck(cj2,-1);
if(!x920.valid){
continue;
}
IkReal x919=x920.value;
CheckValue<IkReal> x921=IKPowWithIntegerCheck(new_r11,-1);
if(!x921.valid){
continue;
}
if( IKabs((x919*(x921.value)*(((((-1.0)*cj2*sj3))+((new_r01*new_r12)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r12*x919)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x919*(x921.value)*(((((-1.0)*cj2*sj3))+((new_r01*new_r12))))))+IKsqr(((-1.0)*new_r12*x919))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((x919*(x921.value)*(((((-1.0)*cj2*sj3))+((new_r01*new_r12))))), ((-1.0)*new_r12*x919));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[18];
IkReal x922=IKsin(j1);
IkReal x923=IKcos(j1);
IkReal x924=((1.0)*cj3);
IkReal x925=((1.0)*sj2);
IkReal x926=(sj2*sj3);
IkReal x927=(cj3*sj2);
IkReal x928=((1.0)*x922);
IkReal x929=(new_r10*x923);
IkReal x930=(new_r12*x923);
IkReal x931=(sj2*x922);
IkReal x932=(new_r11*x923);
evalcond[0]=(((cj2*x923))+new_r12);
evalcond[1]=((((-1.0)*cj2*x928))+new_r02);
evalcond[2]=(((new_r02*x923))+((new_r12*x922)));
evalcond[3]=(sj3+((new_r01*x923))+((new_r11*x922)));
evalcond[4]=(cj2+(((-1.0)*new_r02*x928))+x930);
evalcond[5]=(((x923*x927))+new_r11+((sj3*x922)));
evalcond[6]=((((-1.0)*x924))+((new_r00*x923))+((new_r10*x922)));
evalcond[7]=((((-1.0)*x924*x931))+new_r01+((sj3*x923)));
evalcond[8]=(((x923*x926))+new_r10+(((-1.0)*x922*x924)));
evalcond[9]=((((-1.0)*new_r00*x928))+x929+x926);
evalcond[10]=((((-1.0)*new_r01*x928))+x932+x927);
evalcond[11]=(new_r00+(((-1.0)*sj3*x922*x925))+(((-1.0)*x923*x924)));
evalcond[12]=(((new_r20*sj2))+((cj2*x929))+(((-1.0)*cj2*new_r00*x928)));
evalcond[13]=((((-1.0)*cj2*new_r01*x928))+((cj2*x932))+((new_r21*sj2)));
evalcond[14]=(((new_r02*x931))+(((-1.0)*x925*x930))+((cj2*new_r22)));
evalcond[15]=((1.0)+(((-1.0)*cj2*new_r02*x928))+((new_r22*sj2))+((cj2*x930)));
evalcond[16]=((((-1.0)*x925*x929))+(((-1.0)*sj3))+((new_r00*x931))+((cj2*new_r20)));
evalcond[17]=((((-1.0)*x924))+(((-1.0)*x925*x932))+((new_r01*x931))+((cj2*new_r21)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x933=IKPowWithIntegerCheck(IKsign(cj2),-1);
if(!x933.valid){
continue;
}
CheckValue<IkReal> x934 = IKatan2WithCheck(IkReal(new_r02),IkReal(((-1.0)*new_r12)),IKFAST_ATAN2_MAGTHRESH);
if(!x934.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x933.value)))+(x934.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[18];
IkReal x935=IKsin(j1);
IkReal x936=IKcos(j1);
IkReal x937=((1.0)*cj3);
IkReal x938=((1.0)*sj2);
IkReal x939=(sj2*sj3);
IkReal x940=(cj3*sj2);
IkReal x941=((1.0)*x935);
IkReal x942=(new_r10*x936);
IkReal x943=(new_r12*x936);
IkReal x944=(sj2*x935);
IkReal x945=(new_r11*x936);
evalcond[0]=(((cj2*x936))+new_r12);
evalcond[1]=((((-1.0)*cj2*x941))+new_r02);
evalcond[2]=(((new_r02*x936))+((new_r12*x935)));
evalcond[3]=(sj3+((new_r01*x936))+((new_r11*x935)));
evalcond[4]=(cj2+(((-1.0)*new_r02*x941))+x943);
evalcond[5]=(((x936*x940))+new_r11+((sj3*x935)));
evalcond[6]=(((new_r00*x936))+((new_r10*x935))+(((-1.0)*x937)));
evalcond[7]=(new_r01+(((-1.0)*x937*x944))+((sj3*x936)));
evalcond[8]=((((-1.0)*x935*x937))+((x936*x939))+new_r10);
evalcond[9]=((((-1.0)*new_r00*x941))+x939+x942);
evalcond[10]=((((-1.0)*new_r01*x941))+x940+x945);
evalcond[11]=((((-1.0)*sj3*x935*x938))+(((-1.0)*x936*x937))+new_r00);
evalcond[12]=(((new_r20*sj2))+((cj2*x942))+(((-1.0)*cj2*new_r00*x941)));
evalcond[13]=(((cj2*x945))+((new_r21*sj2))+(((-1.0)*cj2*new_r01*x941)));
evalcond[14]=(((new_r02*x944))+(((-1.0)*x938*x943))+((cj2*new_r22)));
evalcond[15]=((1.0)+((cj2*x943))+((new_r22*sj2))+(((-1.0)*cj2*new_r02*x941)));
evalcond[16]=((((-1.0)*sj3))+((new_r00*x944))+(((-1.0)*x938*x942))+((cj2*new_r20)));
evalcond[17]=(((new_r01*x944))+(((-1.0)*x938*x945))+((cj2*new_r21))+(((-1.0)*x937)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - pluto (f062fdcdb6418b7e8787c840778b4dd3)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x1000004a"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
