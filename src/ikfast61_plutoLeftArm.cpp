/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x1000004a generated on 2021-10-23 19:32:37.020937
/// Generated using solver transform6d
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x1000004a);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40;
x0=IKcos(j[0]);
x1=IKsin(j[0]);
x2=IKsin(j[2]);
x3=IKcos(j[2]);
x4=IKsin(j[1]);
x5=IKsin(j[4]);
x6=IKcos(j[4]);
x7=IKcos(j[3]);
x8=IKcos(j[1]);
x9=IKsin(j[3]);
x10=IKcos(j[5]);
x11=IKsin(j[5]);
x12=((1.0)*x7);
x13=((0.029)*x1);
x14=((1.0)*x5);
x15=((1.0)*x6);
x16=((0.1075)*x1);
x17=((0.029)*x9);
x18=((1.0)*x1);
x19=((1.0)*x2);
x20=((1.0)*x9);
x21=((1.0)*x0);
x22=(x0*x2);
x23=(x7*x8);
x24=((-1.0)*x9);
x25=(x3*x8);
x26=(x3*x4);
x27=(x8*x9);
x28=(x4*x9);
x29=(x0*x26);
x30=(x18*x26);
x31=(x18*x27);
x32=(((x22*x4))+(((-1.0)*x18*x3)));
x33=(((x0*x3))+((x1*x2*x4)));
x34=((((-1.0)*x19*x27))+((x12*x4)));
x35=(((x18*x2))+((x21*x26)));
x36=(x32*x9);
x37=((((-1.0)*x20*x32))+(((-1.0)*x0*x12*x8)));
x38=((((-1.0)*x20*x33))+(((-1.0)*x1*x12*x8)));
x39=((((-1.0)*x14*x25))+(((-1.0)*x15*x34)));
x40=(((x14*(((((-1.0)*x30))+((x0*x19))))))+(((-1.0)*x15*x38)));
eerot[0]=((((-1.0)*x35*x6))+((x37*x5)));
eerot[1]=(((x10*((((x0*x24*x8))+((x32*x7))))))+((x11*(((((-1.0)*x14*x35))+(((-1.0)*x15*x37)))))));
eerot[2]=((((-1.0)*x10*(((((1.0)*x35*x5))+(((1.0)*x6*(((((-1.0)*x0*x23))+((x24*x32))))))))))+((x11*(((((-1.0)*x12*x32))+((x0*x20*x8)))))));
IkReal x41=((1.0)*x2);
eetrans[0]=((((-0.0775)*x1))+((x6*(((((-0.029)*x29))+(((-1.0)*x13*x41))))))+((x5*(((((-1.0)*x17*x32))+(((-0.029)*x0*x23))))))+(((-0.1075)*x29))+(((-1.0)*x16*x41)));
eerot[3]=(((x38*x5))+((x6*(((((-1.0)*x30))+x22)))));
eerot[4]=(((x10*(((((-1.0)*x31))+((x33*x7))))))+((x11*x40)));
eerot[5]=(((x10*x40))+((x11*(((((-1.0)*x12*x33))+x31)))));
IkReal x42=((1.0)*x13);
eetrans[1]=(((x5*(((((-1.0)*x23*x42))+(((-1.0)*x17*x33))))))+(((0.0775)*x0))+(((-1.0)*x16*x26))+(((0.1075)*x22))+((x6*(((((0.029)*x22))+(((-1.0)*x26*x42)))))));
eerot[6]=((((-1.0)*x15*x25))+((x34*x5)));
eerot[7]=(((x10*((((x2*x23))+x28))))+((x11*x39)));
eerot[8]=(((x10*x39))+((x11*(((((-1.0)*x12*x2*x8))+(((-1.0)*x20*x4)))))));
eetrans[2]=((0.372)+((x5*(((((-1.0)*x17*x2*x8))+(((0.029)*x4*x7))))))+(((-0.1075)*x25))+(((-0.029)*x25*x6)));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API int* GetFreeParameters() { return NULL; }
IKFAST_API int GetNumJoints() { return 6; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=((-1.0)*r02);
new_r01=r01;
new_r02=r00;
new_px=((((-0.029)*r00))+px);
new_r10=((-1.0)*r12);
new_r11=r11;
new_r12=r10;
new_py=((((-0.029)*r10))+py);
new_r20=((-1.0)*r22);
new_r21=r21;
new_r22=r20;
new_pz=((-0.372)+(((-0.029)*r20))+pz);
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x43=((1.0)*px);
IkReal x44=((1.0)*pz);
IkReal x45=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x45))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x44)));
rxp0_2=((((-1.0)*r10*x43))+((py*r00)));
rxp1_0=((((-1.0)*r21*x45))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x44)));
rxp1_2=((((-1.0)*r11*x43))+((py*r01)));
rxp2_0=((((-1.0)*r22*x45))+((pz*r12)));
rxp2_1=((((-1.0)*r02*x44))+((px*r22)));
rxp2_2=((((-1.0)*r12*x43))+((py*r02)));
{
IkReal j0eval[2];
j0eval[0]=((px*px)+(py*py));
j0eval[1]=(pp+(((-1.0)*(pz*pz))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((px*px)+(py*py));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
IkReal x46=((0.1075)*r22);
IkReal x47=((1.0)*pz);
IkReal x48=(pz*r22);
IkReal x49=((0.215)*x48);
IkReal x50=((-0.0111)+(((-1.0)*x49)));
IkReal x51=((((-1.0)*x47))+x46);
IkReal x52=((-1.0)*pz);
IkReal x53=((-0.0111)+x49);
IkReal x54=((((-1.0)*x47))+(((-1.0)*x46)));
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=x48;
rxp0_0=(pz*r10);
rxp0_1=(r00*x52);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x52);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x52);
rxp2_2=0;
IkReal gconst0=x53;
IkReal gconst1=x50;
IkReal gconst2=x51;
IkReal gconst3=x54;
IkReal gconst4=x53;
IkReal gconst5=x50;
IkReal gconst6=x51;
IkReal gconst7=x54;
IkReal gconst8=x53;
IkReal gconst9=x50;
IkReal gconst10=x51;
IkReal gconst11=x54;
IkReal gconst12=x53;
IkReal gconst13=x50;
IkReal gconst14=x51;
IkReal gconst15=x54;
IkReal x55=pz*pz;
IkReal x56=r21*r21;
IkReal x57=r22*r22;
IkReal x58=pz*pz*pz*pz;
IkReal x59=r20*r20;
IkReal x60=(r20*r21);
IkReal x61=((0.7396)*x58);
IkReal x62=((0.00820956)*x55);
IkReal x63=(x55*x57);
IkReal x64=(x58*x59);
IkReal x65=(x55*x59);
IkReal x66=(x57*x58);
IkReal x67=(x60*x62);
IkReal x68=(((x60*x61))+(((2.2781529e-5)*x60)));
j5eval[0]=((IKabs(((((-1.0)*x56*x61))+((x57*x62))+((x56*x62))+(((-2.2781529e-5)*x56))+(((-2.2781529e-5)*x57))+(((-1.0)*x57*x61)))))+(IKabs((x67+(((-1.0)*x68)))))+(((0.5)*(IKabs(((((-5.69538225e-6)*x57))+(((-5.69538225e-6)*x59))+(((0.00205239)*x65))+(((0.00205239)*x63))+(((-0.1849)*x66))+(((-0.1849)*x64)))))))+(((0.5)*(IKabs(((((0.01641912)*x55*x56))+(((0.01231434)*x63))+(((-1.1094)*x66))+(((-4.5563058e-5)*x56))+(((-3.41722935e-5)*x57))+(((1.13907645e-5)*x59))+(((-0.00410478)*x65))+(((-1.4792)*x56*x58))+(((0.3698)*x64)))))))+(IKabs((x68+(((-1.0)*x67))))));
if( IKabs(j5eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j0, j4, j5]

} else
{
IkReal op[8+1], zeror[8];
int numroots;
IkReal x69=r20*r20;
IkReal x70=pz*pz;
IkReal x71=r21*r21;
IkReal x72=((0.09245)*gconst12);
IkReal x73=(gconst0*gconst11);
IkReal x74=(gconst5*gconst6);
IkReal x75=((1.0)*gconst12);
IkReal x76=(gconst13*gconst14);
IkReal x77=(gconst14*gconst5);
IkReal x78=(gconst1*pz);
IkReal x79=((1.0)*gconst2);
IkReal x80=(r20*r21);
IkReal x81=(gconst7*gconst8);
IkReal x82=(gconst4*pz);
IkReal x83=(gconst15*gconst3);
IkReal x84=(gconst13*gconst6);
IkReal x85=((1.0)*gconst4);
IkReal x86=(gconst1*gconst10);
IkReal x87=(gconst12*gconst7);
IkReal x88=((0.046225)*gconst4);
IkReal x89=(gconst15*gconst4);
IkReal x90=(gconst11*gconst8);
IkReal x91=((0.1849)*pz);
IkReal x92=((0.046225)*gconst12);
IkReal x93=(gconst9*pz);
IkReal x94=(gconst4*gconst7);
IkReal x95=(gconst2*gconst9);
IkReal x96=(gconst12*pz);
IkReal x97=(gconst10*gconst9);
IkReal x98=(gconst0*gconst3);
IkReal x99=((0.09245)*gconst4);
IkReal x100=(gconst1*gconst2);
IkReal x101=(gconst3*gconst8);
IkReal x102=(gconst12*gconst15);
IkReal x103=(gconst3*x69);
IkReal x104=(gconst14*x70);
IkReal x105=((0.3698)*x71);
IkReal x106=(gconst6*x69);
IkReal x107=(gconst6*x70);
IkReal x108=((0.7396)*x71);
IkReal x109=(gconst9*x69);
IkReal x110=((1.0)*x86);
IkReal x111=(gconst1*x69);
IkReal x112=(gconst11*x69);
IkReal x113=(gconst14*x69);
IkReal x114=(gconst11*x70);
IkReal x115=((0.1849)*gconst12*x71);
IkReal x116=((0.1849)*gconst4*x71);
IkReal x117=(x109*x92);
IkReal x118=((0.00820956)*x70*x80);
IkReal x119=(x109*x88);
IkReal x120=(x111*x92);
IkReal x121=(x111*x88);
IkReal x122=((0.09245)*x113*x93);
IkReal x123=(pz*x112*x72);
IkReal x124=((0.09245)*x112*x82);
IkReal x125=(pz*x103*x72);
IkReal x126=((0.09245)*x106*x93);
IkReal x127=((0.09245)*x113*x78);
IkReal x128=((0.09245)*x103*x82);
IkReal x129=((0.09245)*x106*x78);
IkReal x130=((0.1849)*x104*x112);
IkReal x131=((0.1849)*x103*x104);
IkReal x132=((0.1849)*x106*x114);
IkReal x133=((0.1849)*x103*x107);
IkReal x134=((((0.7396)*x80*(x70*x70)))+(((2.2781529e-5)*x80)));
IkReal x135=(x118+(((-1.0)*x134)));
IkReal x136=((((-1.0)*x118))+x134);
IkReal x137=(x133+x121);
IkReal x138=(x128+x129);
IkReal x139=(x122+x123);
IkReal x140=(x130+x117);
IkReal x141=(x126+x127+x124+x125);
IkReal x142=(x131+x132+x120+x119);
op[0]=((((-1.0)*x140))+(((-1.0)*gconst15*x75*x90))+((x102*x97))+x139+(((-1.0)*x76*x97))+((x76*x90)));
op[1]=x135;
op[2]=((((-1.0)*x142))+((x87*x97))+(((-1.0)*gconst14*x109*x91))+(((-1.0)*gconst9*x76*x79))+((x89*x97))+((x102*x86))+(((-1.0)*x84*x97))+((x102*x95))+(((-1.0)*gconst11*x75*x81))+((x101*x76))+x141+(((-1.0)*x77*x97))+(((-1.0)*gconst11*x104*x108))+(((-1.0)*gconst9*x115))+(((-1.0)*gconst8*x75*x83))+(((-1.0)*gconst12*x112*x91))+((x109*x72))+(((0.3698)*x104*x112))+(((-1.0)*gconst15*x73*x75))+((gconst14*x105*x93))+((x73*x76))+(((-1.0)*x110*x76))+((gconst11*x105*x96))+(((-1.0)*gconst15*x85*x90))+((x84*x90))+((x77*x90)));
op[3]=x135;
op[4]=((((-1.0)*x140))+(((-1.0)*gconst1*x76*x79))+((x87*x95))+((x111*x72))+(((-0.1849)*x112*x82))+((x89*x95))+(((-1.0)*gconst7*x73*x75))+(((-1.0)*gconst3*x75*x81))+((x101*x84))+(((-0.1849)*x113*x78))+(((-1.0)*gconst9*x79*x84))+((gconst14*x105*x78))+((x86*x89))+((x86*x87))+(((-1.0)*gconst15*x73*x85))+(((-1.0)*gconst1*x115))+((x101*x77))+x139+x138+((x74*x90))+((x73*x84))+(((-1.0)*x137))+(((-1.0)*gconst0*x75*x83))+(((-1.0)*gconst3*x104*x108))+(((-1.0)*gconst11*x81*x85))+(((-1.0)*x110*x84))+(((-1.0)*gconst12*x103*x91))+(((0.3698)*x106*x114))+(((0.3698)*x103*x104))+(((-1.0)*gconst9*x116))+((x76*x98))+(((-1.0)*x74*x97))+(((-1.0)*gconst9*x106*x91))+((x109*x99))+((x73*x77))+((gconst6*x105*x93))+(((-1.0)*gconst8*x83*x85))+(((-1.0)*x110*x77))+(((-1.0)*gconst11*x107*x108))+(((-1.0)*gconst9*x77*x79))+((x94*x97))+((gconst11*x105*x82))+((x100*x102))+((gconst3*x105*x96)));
op[5]=x136;
op[6]=((((-1.0)*gconst1*x79*x84))+(((-1.0)*x142))+((x100*x87))+((x100*x89))+(((-1.0)*gconst3*x81*x85))+(((-1.0)*gconst9*x74*x79))+((x86*x94))+(((-1.0)*gconst0*x83*x85))+(((-1.0)*gconst1*x116))+((x101*x74))+x141+(((-1.0)*gconst1*x77*x79))+(((-1.0)*gconst7*x73*x85))+(((-1.0)*gconst7*x75*x98))+(((0.3698)*x103*x107))+((x111*x99))+((gconst6*x105*x78))+((x73*x74))+(((-0.1849)*x103*x82))+(((-1.0)*gconst3*x107*x108))+(((-0.1849)*x106*x78))+(((-1.0)*x110*x74))+((gconst3*x105*x82))+((x94*x95))+((x84*x98))+((x77*x98)));
op[7]=x136;
op[8]=((((-1.0)*gconst7*x85*x98))+((x100*x94))+x138+((x74*x98))+(((-1.0)*gconst1*x74*x79))+(((-1.0)*x137)));
polyroots8(op,zeror,numroots);
IkReal j5array[8], cj5array[8], sj5array[8], tempj5array[1];
int numsolutions = 0;
for(int ij5 = 0; ij5 < numroots; ++ij5)
{
IkReal htj5 = zeror[ij5];
tempj5array[0]=((2.0)*(atan(htj5)));
for(int kj5 = 0; kj5 < 1; ++kj5)
{
j5array[numsolutions] = tempj5array[kj5];
if( j5array[numsolutions] > IKPI )
{
    j5array[numsolutions]-=IK2PI;
}
else if( j5array[numsolutions] < -IKPI )
{
    j5array[numsolutions]+=IK2PI;
}
sj5array[numsolutions] = IKsin(j5array[numsolutions]);
cj5array[numsolutions] = IKcos(j5array[numsolutions]);
numsolutions++;
}
}
bool j5valid[8]={true,true,true,true,true,true,true,true};
_nj5 = 8;
for(int ij5 = 0; ij5 < numsolutions; ++ij5)
    {
if( !j5valid[ij5] )
{
    continue;
}
    j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
htj5 = IKtan(j5/2);

_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < numsolutions; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
{
IkReal j4eval[2];
IkReal x143=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x143);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x143);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x143);
rxp2_2=0;
IkReal x144=(cj5*r20);
IkReal x145=(r21*sj5);
j4eval[0]=((r22*r22)+(((-2.0)*x144*x145))+(x145*x145)+(x144*x144));
j4eval[1]=((((9.30232558139535)*(IKabs(((((0.1075)*x145))+(((-0.1075)*x144)))))))+(IKabs(r22)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
IkReal x146=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x146);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x146);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x146);
rxp2_2=0;
IkReal x147=pz*pz;
IkReal x148=(cj5*r20);
IkReal x149=(r21*sj5);
j4eval[0]=((IKabs((((pz*x149))+(((-1.0)*pz*x148)))))+(IKabs((pz*r22))));
j4eval[1]=((((-2.0)*x147*x148*x149))+((x147*(x149*x149)))+((x147*(x148*x148)))+((x147*(r22*r22))));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
IkReal x150=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x150);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x150);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x150);
rxp2_2=0;
IkReal x151=cj5*cj5;
IkReal x152=sj5*sj5;
IkReal x153=((0.0775)*cj5);
IkReal x154=(r00*sj5);
IkReal x155=((2.0)*cj5);
IkReal x156=(r10*sj5);
j0eval[0]=((IKabs(((((-0.0775)*x154))+(((-1.0)*r01*x153)))))+(IKabs(((((0.0775)*x156))+((r11*x153))))));
j0eval[1]=(((x151*(r11*r11)))+((x152*(r10*r10)))+((x152*(r00*r00)))+((r11*x155*x156))+((r01*x154*x155))+((x151*(r01*r01))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(pz);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j4eval[0]=((IKabs(r22))+(((9.30232558139535)*(IKabs(((((0.1075)*r21*sj5))+(((-0.1075)*cj5*r20))))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
IkReal x157=((0.0775)*cj5);
IkReal x158=((0.0775)*sj5);
j0eval[0]=((IKabs((((r11*x157))+((r10*x158)))))+(IKabs(((((-1.0)*r00*x158))+(((-1.0)*r01*x157))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x159=((0.0775)*cj5);
IkReal x160=((0.0775)*sj5);
CheckValue<IkReal> x162 = IKatan2WithCheck(IkReal((((r10*x160))+((r11*x159)))),IkReal(((((-1.0)*r00*x160))+(((-1.0)*r01*x159)))),IKFAST_ATAN2_MAGTHRESH);
if(!x162.valid){
continue;
}
IkReal x161=x162.value;
j0array[0]=((-1.0)*x161);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x161)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal j4eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j4eval[0]=(((r21*sj5))+(((-1.0)*cj5*r20)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j4eval[0]=(((r01*sj5))+(((-1.0)*cj5*r00)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j4eval[0]=((((-1.0)*cj5*r10))+((r11*sj5)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x163=((31.0)*cj0);
IkReal x164=(r02*sj0);
CheckValue<IkReal> x165=IKPowWithIntegerCheck(((((-43.0)*cj5*r10))+(((43.0)*r11*sj5))),-1);
if(!x165.valid){
continue;
}
if( IKabs(((x165.value)*((((x163*(r12*r12)))+(((-1.0)*x163))+(((-31.0)*r12*x164)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-0.720930232558139)*cj0*r12))+(((0.720930232558139)*x164)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x165.value)*((((x163*(r12*r12)))+(((-1.0)*x163))+(((-31.0)*r12*x164))))))+IKsqr(((((-0.720930232558139)*cj0*r12))+(((0.720930232558139)*x164))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x165.value)*((((x163*(r12*r12)))+(((-1.0)*x163))+(((-31.0)*r12*x164))))), ((((-0.720930232558139)*cj0*r12))+(((0.720930232558139)*x164))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x166=IKcos(j4);
IkReal x167=IKsin(j4);
IkReal x168=(cj5*r00);
IkReal x169=(r11*sj5);
IkReal x170=(r01*sj5);
IkReal x171=((0.0775)*cj0);
IkReal x172=(cj5*r10);
IkReal x173=((0.0775)*sj0);
IkReal x174=((0.1075)*x166);
IkReal x175=((0.1075)*x167);
evalcond[0]=((((-1.0)*r02*x173))+x174+((r12*x171)));
evalcond[1]=(((r22*x174))+(((-1.0)*cj5*r20*x175))+((r21*sj5*x175)));
evalcond[2]=((((-1.0)*x173))+((x170*x175))+(((-1.0)*x168*x175))+((r02*x174)));
evalcond[3]=(((x169*x175))+x171+((r12*x174))+(((-1.0)*x172*x175)));
evalcond[4]=((((-1.0)*x175))+((x171*x172))+((x170*x173))+(((-1.0)*x168*x173))+(((-1.0)*x169*x171)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x947=(cj0*r12);
IkReal x948=((31.0)*sj0);
CheckValue<IkReal> x949=IKPowWithIntegerCheck(((((43.0)*r01*sj5))+(((-43.0)*cj5*r00))),-1);
if(!x949.valid){
continue;
}
if( IKabs(((x949.value)*(((((31.0)*r02*x947))+(((-1.0)*x948*(r02*r02)))+x948)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((0.720930232558139)*r02*sj0))+(((-0.720930232558139)*x947)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x949.value)*(((((31.0)*r02*x947))+(((-1.0)*x948*(r02*r02)))+x948))))+IKsqr(((((0.720930232558139)*r02*sj0))+(((-0.720930232558139)*x947))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x949.value)*(((((31.0)*r02*x947))+(((-1.0)*x948*(r02*r02)))+x948))), ((((0.720930232558139)*r02*sj0))+(((-0.720930232558139)*x947))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x950=IKcos(j4);
IkReal x951=IKsin(j4);
IkReal x952=(cj5*r00);
IkReal x953=(r11*sj5);
IkReal x954=(r01*sj5);
IkReal x955=((0.0775)*cj0);
IkReal x956=(cj5*r10);
IkReal x957=((0.0775)*sj0);
IkReal x958=((0.1075)*x950);
IkReal x959=((0.1075)*x951);
evalcond[0]=(((r12*x955))+x958+(((-1.0)*r02*x957)));
evalcond[1]=(((r22*x958))+(((-1.0)*cj5*r20*x959))+((r21*sj5*x959)));
evalcond[2]=(((r02*x958))+(((-1.0)*x957))+(((-1.0)*x952*x959))+((x954*x959)));
evalcond[3]=((((-1.0)*x956*x959))+((r12*x958))+((x953*x959))+x955);
evalcond[4]=(((x955*x956))+(((-1.0)*x953*x955))+(((-1.0)*x959))+(((-1.0)*x952*x957))+((x954*x957)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x960=((0.0775)*r22);
IkReal x961=(r02*sj0);
IkReal x962=(cj0*r12);
CheckValue<IkReal> x963=IKPowWithIntegerCheck(((((0.1075)*r21*sj5))+(((-0.1075)*cj5*r20))),-1);
if(!x963.valid){
continue;
}
if( IKabs(((x963.value)*(((((-1.0)*x960*x961))+((x960*x962)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((0.720930232558139)*x961))+(((-0.720930232558139)*x962)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x963.value)*(((((-1.0)*x960*x961))+((x960*x962))))))+IKsqr(((((0.720930232558139)*x961))+(((-0.720930232558139)*x962))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x963.value)*(((((-1.0)*x960*x961))+((x960*x962))))), ((((0.720930232558139)*x961))+(((-0.720930232558139)*x962))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x964=IKcos(j4);
IkReal x965=IKsin(j4);
IkReal x966=(cj5*r00);
IkReal x967=(r11*sj5);
IkReal x968=(r01*sj5);
IkReal x969=((0.0775)*cj0);
IkReal x970=(cj5*r10);
IkReal x971=((0.0775)*sj0);
IkReal x972=((0.1075)*x964);
IkReal x973=((0.1075)*x965);
evalcond[0]=((((-1.0)*r02*x971))+((r12*x969))+x972);
evalcond[1]=(((r21*sj5*x973))+((r22*x972))+(((-1.0)*cj5*r20*x973)));
evalcond[2]=((((-1.0)*x966*x973))+((x968*x973))+((r02*x972))+(((-1.0)*x971)));
evalcond[3]=((((-1.0)*x970*x973))+((r12*x972))+((x967*x973))+x969);
evalcond[4]=(((x969*x970))+(((-1.0)*x967*x969))+(((-1.0)*x966*x971))+((x968*x971))+(((-1.0)*x973)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x975 = IKatan2WithCheck(IkReal(((0.1075)*r22)),IkReal(((((0.1075)*r21*sj5))+(((-0.1075)*cj5*r20)))),IKFAST_ATAN2_MAGTHRESH);
if(!x975.valid){
continue;
}
IkReal x974=x975.value;
j4array[0]=((-1.0)*x974);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x974)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

{
IkReal j0eval[3];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
IkReal x976=(cj4*sj5);
IkReal x977=(r21*sj5);
IkReal x978=(cj5*r20);
IkReal x979=(cj4*cj5);
j0eval[0]=((((-1.0)*x978))+x977);
j0eval[1]=IKsign(((((2.4025)*x977))+(((-2.4025)*x978))));
j0eval[2]=((IKabs((((r10*x976))+((r11*x979)))))+(IKabs((((r01*x979))+((r00*x976))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
IkReal x980=((1333.0)*sj4);
IkReal x981=(r20*sj5);
IkReal x982=(cj5*r21);
IkReal x983=((1333.0)*cj4*sj5);
IkReal x984=((1333.0)*cj4*cj5);
j0eval[0]=(x981+x982);
j0eval[1]=((IKabs((((r12*x980))+((r10*x984))+(((-1.0)*r11*x983)))))+(IKabs(((((-1.0)*r01*x983))+((r00*x984))+((r02*x980))))));
j0eval[2]=IKsign(((((961.0)*x981))+(((961.0)*x982))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j0eval[0]=r12;
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x985=((1.38709677419355)*sj4);
IkReal x986=(cj5*r00);
IkReal x987=(r01*sj5);
IkReal x988=((43.0)*cj4);
IkReal x989=((43.0)*r02*sj4);
CheckValue<IkReal> x990=IKPowWithIntegerCheck(r12,-1);
if(!x990.valid){
continue;
}
if( IKabs(((((1.38709677419355)*cj4*r02))+((x985*x987))+(((-1.0)*x985*x986)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.032258064516129)*(x990.value)*(((((-1.0)*x988))+((x988*(r02*r02)))+(((-1.0)*x986*x989))+((x987*x989)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((1.38709677419355)*cj4*r02))+((x985*x987))+(((-1.0)*x985*x986))))+IKsqr(((0.032258064516129)*(x990.value)*(((((-1.0)*x988))+((x988*(r02*r02)))+(((-1.0)*x986*x989))+((x987*x989))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(((((1.38709677419355)*cj4*r02))+((x985*x987))+(((-1.0)*x985*x986))), ((0.032258064516129)*(x990.value)*(((((-1.0)*x988))+((x988*(r02*r02)))+(((-1.0)*x986*x989))+((x987*x989))))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x991=IKsin(j0);
IkReal x992=IKcos(j0);
IkReal x993=((0.1075)*cj4);
IkReal x994=(r11*sj5);
IkReal x995=(r01*sj5);
IkReal x996=((0.1075)*sj4);
IkReal x997=((0.0775)*x992);
IkReal x998=(cj5*x996);
IkReal x999=((0.0775)*x991);
evalcond[0]=(((r12*x997))+(((-1.0)*r02*x999))+x993);
evalcond[1]=(((r02*x993))+(((-1.0)*x999))+(((-1.0)*r00*x998))+((x995*x996)));
evalcond[2]=(((r12*x993))+((x994*x996))+(((-1.0)*r10*x998))+x997);
evalcond[3]=(((cj5*r11*x997))+(((-1.0)*r00*sj5*x999))+((r10*sj5*x997))+(((-1.0)*cj5*r01*x999)));
evalcond[4]=((((-1.0)*x994*x997))+((cj5*r10*x997))+(((-1.0)*x996))+((x995*x999))+(((-1.0)*cj5*r00*x999)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1000=((1333.0)*sj4);
IkReal x1001=((1333.0)*cj4*sj5);
IkReal x1002=((1333.0)*cj4*cj5);
CheckValue<IkReal> x1003 = IKatan2WithCheck(IkReal(((((-1.0)*r11*x1001))+((r12*x1000))+((r10*x1002)))),IkReal((((r02*x1000))+(((-1.0)*r01*x1001))+((r00*x1002)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1003.valid){
continue;
}
CheckValue<IkReal> x1004=IKPowWithIntegerCheck(IKsign(((((961.0)*cj5*r21))+(((961.0)*r20*sj5)))),-1);
if(!x1004.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x1003.value)+(((1.5707963267949)*(x1004.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1005=IKsin(j0);
IkReal x1006=IKcos(j0);
IkReal x1007=((0.1075)*cj4);
IkReal x1008=(r11*sj5);
IkReal x1009=(r01*sj5);
IkReal x1010=((0.1075)*sj4);
IkReal x1011=((0.0775)*x1006);
IkReal x1012=(cj5*x1010);
IkReal x1013=((0.0775)*x1005);
evalcond[0]=(x1007+(((-1.0)*r02*x1013))+((r12*x1011)));
evalcond[1]=(((x1009*x1010))+((r02*x1007))+(((-1.0)*x1013))+(((-1.0)*r00*x1012)));
evalcond[2]=(x1011+((r12*x1007))+((x1008*x1010))+(((-1.0)*r10*x1012)));
evalcond[3]=((((-1.0)*r00*sj5*x1013))+((r10*sj5*x1011))+((cj5*r11*x1011))+(((-1.0)*cj5*r01*x1013)));
evalcond[4]=(((x1009*x1013))+(((-1.0)*x1010))+(((-1.0)*x1008*x1011))+((cj5*r10*x1011))+(((-1.0)*cj5*r00*x1013)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1014=((3.3325)*cj4*cj5);
IkReal x1015=((3.3325)*cj4*sj5);
CheckValue<IkReal> x1016 = IKatan2WithCheck(IkReal((((r10*x1015))+((r11*x1014)))),IkReal((((r01*x1014))+((r00*x1015)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1016.valid){
continue;
}
CheckValue<IkReal> x1017=IKPowWithIntegerCheck(IKsign(((((-2.4025)*cj5*r20))+(((2.4025)*r21*sj5)))),-1);
if(!x1017.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x1016.value)+(((1.5707963267949)*(x1017.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1018=IKsin(j0);
IkReal x1019=IKcos(j0);
IkReal x1020=((0.1075)*cj4);
IkReal x1021=(r11*sj5);
IkReal x1022=(r01*sj5);
IkReal x1023=((0.1075)*sj4);
IkReal x1024=((0.0775)*x1019);
IkReal x1025=(cj5*x1023);
IkReal x1026=((0.0775)*x1018);
evalcond[0]=(x1020+((r12*x1024))+(((-1.0)*r02*x1026)));
evalcond[1]=((((-1.0)*x1026))+((x1022*x1023))+(((-1.0)*r00*x1025))+((r02*x1020)));
evalcond[2]=(x1024+((r12*x1020))+((x1021*x1023))+(((-1.0)*r10*x1025)));
evalcond[3]=((((-1.0)*r00*sj5*x1026))+((r10*sj5*x1024))+((cj5*r11*x1024))+(((-1.0)*cj5*r01*x1026)));
evalcond[4]=(((cj5*r10*x1024))+(((-1.0)*x1021*x1024))+(((-1.0)*x1023))+((x1022*x1026))+(((-1.0)*cj5*r00*x1026)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x1027=((0.0775)*cj5);
IkReal x1028=((1.0)*pz);
IkReal x1029=((0.0775)*sj5);
IkReal x1030=(((r11*x1027))+((r10*x1029)));
IkReal x1031=((((-1.0)*r00*x1029))+(((-1.0)*r01*x1027)));
CheckValue<IkReal> x1034 = IKatan2WithCheck(IkReal(x1030),IkReal(x1031),IKFAST_ATAN2_MAGTHRESH);
if(!x1034.valid){
continue;
}
IkReal x1032=((1.0)*(x1034.value));
if((((x1030*x1030)+(x1031*x1031))) < -0.00001)
continue;
CheckValue<IkReal> x1035=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1030*x1030)+(x1031*x1031)))),-1);
if(!x1035.valid){
continue;
}
if( (((-1.0)*(x1035.value)*(((((-1.0)*cj5*r21*x1028))+(((-1.0)*r20*sj5*x1028)))))) < -1-IKFAST_SINCOS_THRESH || (((-1.0)*(x1035.value)*(((((-1.0)*cj5*r21*x1028))+(((-1.0)*r20*sj5*x1028)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1033=((-1.0)*(IKasin(((-1.0)*(x1035.value)*(((((-1.0)*cj5*r21*x1028))+(((-1.0)*r20*sj5*x1028))))))));
j0array[0]=((((-1.0)*x1033))+(((-1.0)*x1032)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1032))+(((1.0)*x1033)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal j4eval[1];
IkReal x1036=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1036);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1036);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1036);
rxp2_2=0;
j4eval[0]=(((r21*sj5))+(((-1.0)*cj5*r20)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
IkReal x1037=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1037);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1037);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1037);
rxp2_2=0;
j4eval[0]=(((r01*sj5))+(((-1.0)*cj5*r00)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
IkReal x1038=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1038);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1038);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1038);
rxp2_2=0;
j4eval[0]=((((-1.0)*cj5*r10))+((r11*sj5)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r10))+(IKabs(r11)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
IkReal x1039=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=0;
rxp0_0=0;
rxp0_1=(r00*x1039);
rxp0_2=0;
rxp1_0=0;
rxp1_1=(r01*x1039);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=0;
rxp2_2=0;
r10=0;
r11=0;
r22=0;
r02=0;
j4eval[0]=(((r21*sj5))+(((-1.0)*cj5*r20)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
IkReal x1040=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=0;
rxp0_0=0;
rxp0_1=(r00*x1040);
rxp0_2=0;
rxp1_0=0;
rxp1_1=(r01*x1040);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=0;
rxp2_2=0;
r10=0;
r11=0;
r22=0;
r02=0;
j4eval[0]=(((r01*sj5))+(((-1.0)*cj5*r00)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
IkReal x1041=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=0;
rxp0_0=0;
rxp0_1=(r00*x1041);
rxp0_2=0;
rxp1_0=0;
rxp1_1=(r01*x1041);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=0;
rxp2_2=0;
r10=0;
r11=0;
r22=0;
r02=0;
j4eval[0]=(((pz*r21*sj5))+(((-1.0)*cj5*pz*r20)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1042=((2150.0)*pz);
CheckValue<IkReal> x1043=IKPowWithIntegerCheck(((((-1.0)*cj5*r20*x1042))+((r21*sj5*x1042))),-1);
if(!x1043.valid){
continue;
}
if( IKabs(((111.0)*(x1043.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.720930232558139)*cj0*r12)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((111.0)*(x1043.value)))+IKsqr(((-0.720930232558139)*cj0*r12))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((111.0)*(x1043.value)), ((-0.720930232558139)*cj0*r12));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1044=IKcos(j4);
IkReal x1045=IKsin(j4);
IkReal x1046=((1.0)*pz);
IkReal x1047=((0.215)*pz);
IkReal x1048=((0.0775)*sj0);
IkReal x1049=(r01*sj5);
IkReal x1050=((0.0775)*cj0);
IkReal x1051=(r21*sj5);
IkReal x1052=(cj5*x1045);
IkReal x1053=((0.1075)*x1044);
IkReal x1054=((0.1075)*x1045);
evalcond[0]=(((r12*x1050))+x1053);
evalcond[1]=(((r12*x1053))+x1050);
evalcond[2]=(((x1051*x1054))+(((-0.1075)*r20*x1052))+(((-1.0)*x1046)));
evalcond[3]=((-0.0111)+(((-1.0)*r20*x1047*x1052))+((x1045*x1047*x1051)));
evalcond[4]=((((-0.1075)*r00*x1052))+((x1049*x1054))+(((-1.0)*x1048)));
evalcond[5]=((((-1.0)*x1054))+(((-1.0)*cj5*r20*x1046))+((pz*x1051))+(((-1.0)*cj5*r00*x1048))+((x1048*x1049)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x1055=IKPowWithIntegerCheck(((((43.0)*r01*sj5))+(((-43.0)*cj5*r00))),-1);
if(!x1055.valid){
continue;
}
if( IKabs(((31.0)*sj0*(x1055.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.720930232558139)*cj0*r12)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((31.0)*sj0*(x1055.value)))+IKsqr(((-0.720930232558139)*cj0*r12))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((31.0)*sj0*(x1055.value)), ((-0.720930232558139)*cj0*r12));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1056=IKcos(j4);
IkReal x1057=IKsin(j4);
IkReal x1058=((1.0)*pz);
IkReal x1059=((0.215)*pz);
IkReal x1060=((0.0775)*sj0);
IkReal x1061=(r01*sj5);
IkReal x1062=((0.0775)*cj0);
IkReal x1063=(r21*sj5);
IkReal x1064=(cj5*x1057);
IkReal x1065=((0.1075)*x1056);
IkReal x1066=((0.1075)*x1057);
evalcond[0]=(((r12*x1062))+x1065);
evalcond[1]=(((r12*x1065))+x1062);
evalcond[2]=((((-1.0)*x1058))+((x1063*x1066))+(((-0.1075)*r20*x1064)));
evalcond[3]=((-0.0111)+(((-1.0)*r20*x1059*x1064))+((x1057*x1059*x1063)));
evalcond[4]=(((x1061*x1066))+(((-0.1075)*r00*x1064))+(((-1.0)*x1060)));
evalcond[5]=(((x1060*x1061))+(((-1.0)*cj5*r20*x1058))+((pz*x1063))+(((-1.0)*cj5*r00*x1060))+(((-1.0)*x1066)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x1067=IKPowWithIntegerCheck(((((0.1075)*r21*sj5))+(((-0.1075)*cj5*r20))),-1);
if(!x1067.valid){
continue;
}
if( IKabs((pz*(x1067.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.720930232558139)*cj0*r12)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((pz*(x1067.value)))+IKsqr(((-0.720930232558139)*cj0*r12))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((pz*(x1067.value)), ((-0.720930232558139)*cj0*r12));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1068=IKcos(j4);
IkReal x1069=IKsin(j4);
IkReal x1070=((1.0)*pz);
IkReal x1071=((0.215)*pz);
IkReal x1072=((0.0775)*sj0);
IkReal x1073=(r01*sj5);
IkReal x1074=((0.0775)*cj0);
IkReal x1075=(r21*sj5);
IkReal x1076=(cj5*x1069);
IkReal x1077=((0.1075)*x1068);
IkReal x1078=((0.1075)*x1069);
evalcond[0]=(x1077+((r12*x1074)));
evalcond[1]=(x1074+((r12*x1077)));
evalcond[2]=(((x1075*x1078))+(((-0.1075)*r20*x1076))+(((-1.0)*x1070)));
evalcond[3]=((-0.0111)+(((-1.0)*r20*x1071*x1076))+((x1069*x1071*x1075)));
evalcond[4]=((((-0.1075)*r00*x1076))+((x1073*x1078))+(((-1.0)*x1072)));
evalcond[5]=(((pz*x1075))+(((-1.0)*cj5*r20*x1070))+(((-1.0)*cj5*r00*x1072))+((x1072*x1073))+(((-1.0)*x1078)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r21))+(IKabs(r20)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
IkReal x1079=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1079);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1079);
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
r20=0;
r21=0;
r02=0;
r12=0;
j4eval[0]=(((r01*sj5))+(((-1.0)*cj5*r00)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
IkReal x1080=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1080);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1080);
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
r20=0;
r21=0;
r02=0;
r12=0;
j4eval[0]=((((-1.0)*cj5*r10))+((r11*sj5)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
IkReal x1081=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1081);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1081);
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
r20=0;
r21=0;
r02=0;
r12=0;
j4eval[0]=(((r01*sj5))+(((-1.0)*cj5*r00)));
j4eval[1]=pz;
j4eval[2]=r22;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x1082=IKPowWithIntegerCheck(((((43.0)*r01*sj5))+(((-43.0)*cj5*r00))),-1);
if(!x1082.valid){
continue;
}
CheckValue<IkReal> x1083=IKPowWithIntegerCheck(pz,-1);
if(!x1083.valid){
continue;
}
CheckValue<IkReal> x1084=IKPowWithIntegerCheck(r22,-1);
if(!x1084.valid){
continue;
}
if( IKabs(((31.0)*sj0*(x1082.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.0516279069767442)*(x1083.value)*(x1084.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((31.0)*sj0*(x1082.value)))+IKsqr(((0.0516279069767442)*(x1083.value)*(x1084.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((31.0)*sj0*(x1082.value)), ((0.0516279069767442)*(x1083.value)*(x1084.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1085=IKcos(j4);
IkReal x1086=IKsin(j4);
IkReal x1087=(r11*sj5);
IkReal x1088=(cj5*r00);
IkReal x1089=((1.0)*pz);
IkReal x1090=(r01*sj5);
IkReal x1091=((0.0775)*cj0);
IkReal x1092=(cj5*r10);
IkReal x1093=((0.0775)*sj0);
IkReal x1094=(r22*x1085);
IkReal x1095=((0.1075)*x1086);
evalcond[0]=((-0.0111)+(((0.215)*pz*x1094)));
evalcond[1]=((((0.1075)*x1085))+(((-1.0)*r22*x1089)));
evalcond[2]=((((0.1075)*x1094))+(((-1.0)*x1089)));
evalcond[3]=((((-1.0)*x1088*x1095))+(((-1.0)*x1093))+((x1090*x1095)));
evalcond[4]=(((x1087*x1095))+x1091+(((-1.0)*x1092*x1095)));
evalcond[5]=((((-1.0)*x1088*x1093))+(((-1.0)*x1095))+(((-1.0)*x1087*x1091))+((x1091*x1092))+((x1090*x1093)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x1096=IKPowWithIntegerCheck(((((-43.0)*cj5*r10))+(((43.0)*r11*sj5))),-1);
if(!x1096.valid){
continue;
}
if( IKabs(((-31.0)*cj0*(x1096.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((9.30232558139535)*pz*r22)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-31.0)*cj0*(x1096.value)))+IKsqr(((9.30232558139535)*pz*r22))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-31.0)*cj0*(x1096.value)), ((9.30232558139535)*pz*r22));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1097=IKcos(j4);
IkReal x1098=IKsin(j4);
IkReal x1099=(r11*sj5);
IkReal x1100=(cj5*r00);
IkReal x1101=((1.0)*pz);
IkReal x1102=(r01*sj5);
IkReal x1103=((0.0775)*cj0);
IkReal x1104=(cj5*r10);
IkReal x1105=((0.0775)*sj0);
IkReal x1106=(r22*x1097);
IkReal x1107=((0.1075)*x1098);
evalcond[0]=((-0.0111)+(((0.215)*pz*x1106)));
evalcond[1]=((((-1.0)*r22*x1101))+(((0.1075)*x1097)));
evalcond[2]=((((0.1075)*x1106))+(((-1.0)*x1101)));
evalcond[3]=(((x1102*x1107))+(((-1.0)*x1100*x1107))+(((-1.0)*x1105)));
evalcond[4]=(x1103+((x1099*x1107))+(((-1.0)*x1104*x1107)));
evalcond[5]=(((x1102*x1105))+(((-1.0)*x1099*x1103))+(((-1.0)*x1100*x1105))+(((-1.0)*x1107))+((x1103*x1104)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x1108=IKPowWithIntegerCheck(((((43.0)*r01*sj5))+(((-43.0)*cj5*r00))),-1);
if(!x1108.valid){
continue;
}
if( IKabs(((31.0)*sj0*(x1108.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((9.30232558139535)*pz*r22)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((31.0)*sj0*(x1108.value)))+IKsqr(((9.30232558139535)*pz*r22))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((31.0)*sj0*(x1108.value)), ((9.30232558139535)*pz*r22));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1109=IKcos(j4);
IkReal x1110=IKsin(j4);
IkReal x1111=(r11*sj5);
IkReal x1112=(cj5*r00);
IkReal x1113=((1.0)*pz);
IkReal x1114=(r01*sj5);
IkReal x1115=((0.0775)*cj0);
IkReal x1116=(cj5*r10);
IkReal x1117=((0.0775)*sj0);
IkReal x1118=(r22*x1109);
IkReal x1119=((0.1075)*x1110);
evalcond[0]=((-0.0111)+(((0.215)*pz*x1118)));
evalcond[1]=((((0.1075)*x1109))+(((-1.0)*r22*x1113)));
evalcond[2]=((((0.1075)*x1118))+(((-1.0)*x1113)));
evalcond[3]=(((x1114*x1119))+(((-1.0)*x1112*x1119))+(((-1.0)*x1117)));
evalcond[4]=(x1115+((x1111*x1119))+(((-1.0)*x1116*x1119)));
evalcond[5]=(((x1114*x1117))+(((-1.0)*x1112*x1117))+(((-1.0)*x1119))+((x1115*x1116))+(((-1.0)*x1111*x1115)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1120=((31.0)*cj0);
IkReal x1121=(pz*r22);
IkReal x1122=(r02*sj0);
CheckValue<IkReal> x1123=IKPowWithIntegerCheck(((((-43.0)*cj5*r10))+(((43.0)*r11*sj5))),-1);
if(!x1123.valid){
continue;
}
if( IKabs(((x1123.value)*((((x1120*(r12*r12)))+(((-400.0)*r12*x1121))+(((-31.0)*r12*x1122))+(((-1.0)*x1120)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-0.720930232558139)*cj0*r12))+(((0.720930232558139)*x1122))+(((9.30232558139535)*x1121)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1123.value)*((((x1120*(r12*r12)))+(((-400.0)*r12*x1121))+(((-31.0)*r12*x1122))+(((-1.0)*x1120))))))+IKsqr(((((-0.720930232558139)*cj0*r12))+(((0.720930232558139)*x1122))+(((9.30232558139535)*x1121))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1123.value)*((((x1120*(r12*r12)))+(((-400.0)*r12*x1121))+(((-31.0)*r12*x1122))+(((-1.0)*x1120))))), ((((-0.720930232558139)*cj0*r12))+(((0.720930232558139)*x1122))+(((9.30232558139535)*x1121))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1124=IKcos(j4);
IkReal x1125=IKsin(j4);
IkReal x1126=(cj5*r00);
IkReal x1127=(r01*sj5);
IkReal x1128=((1.0)*pz);
IkReal x1129=(cj5*r20);
IkReal x1130=((0.0775)*cj0);
IkReal x1131=(cj5*r10);
IkReal x1132=((0.0775)*sj0);
IkReal x1133=((0.215)*pz);
IkReal x1134=(r21*sj5);
IkReal x1135=(r11*sj5);
IkReal x1136=((0.1075)*x1125);
IkReal x1137=((0.1075)*x1124);
evalcond[0]=(x1137+(((-1.0)*r22*x1128))+((r12*x1130))+(((-1.0)*r02*x1132)));
evalcond[1]=(((x1134*x1136))+((r22*x1137))+(((-1.0)*x1128))+(((-1.0)*x1129*x1136)));
evalcond[2]=((((-1.0)*x1126*x1136))+(((-1.0)*x1132))+((r02*x1137))+((x1127*x1136)));
evalcond[3]=(x1130+(((-1.0)*x1131*x1136))+((x1135*x1136))+((r12*x1137)));
evalcond[4]=((-0.0111)+(((-1.0)*x1125*x1129*x1133))+((r22*x1124*x1133))+((x1125*x1133*x1134)));
evalcond[5]=(((x1130*x1131))+(((-1.0)*x1130*x1135))+(((-1.0)*x1126*x1132))+((pz*x1134))+(((-1.0)*x1136))+(((-1.0)*x1128*x1129))+((x1127*x1132)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1138=(pz*r22);
IkReal x1139=(cj0*r12);
IkReal x1140=((31.0)*sj0);
CheckValue<IkReal> x1141=IKPowWithIntegerCheck(((((43.0)*r01*sj5))+(((-43.0)*cj5*r00))),-1);
if(!x1141.valid){
continue;
}
if( IKabs(((x1141.value)*((x1140+(((-1.0)*x1140*(r02*r02)))+(((31.0)*r02*x1139))+(((-400.0)*r02*x1138)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((0.720930232558139)*r02*sj0))+(((9.30232558139535)*x1138))+(((-0.720930232558139)*x1139)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1141.value)*((x1140+(((-1.0)*x1140*(r02*r02)))+(((31.0)*r02*x1139))+(((-400.0)*r02*x1138))))))+IKsqr(((((0.720930232558139)*r02*sj0))+(((9.30232558139535)*x1138))+(((-0.720930232558139)*x1139))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1141.value)*((x1140+(((-1.0)*x1140*(r02*r02)))+(((31.0)*r02*x1139))+(((-400.0)*r02*x1138))))), ((((0.720930232558139)*r02*sj0))+(((9.30232558139535)*x1138))+(((-0.720930232558139)*x1139))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1142=IKcos(j4);
IkReal x1143=IKsin(j4);
IkReal x1144=(cj5*r00);
IkReal x1145=(r01*sj5);
IkReal x1146=((1.0)*pz);
IkReal x1147=(cj5*r20);
IkReal x1148=((0.0775)*cj0);
IkReal x1149=(cj5*r10);
IkReal x1150=((0.0775)*sj0);
IkReal x1151=((0.215)*pz);
IkReal x1152=(r21*sj5);
IkReal x1153=(r11*sj5);
IkReal x1154=((0.1075)*x1143);
IkReal x1155=((0.1075)*x1142);
evalcond[0]=(x1155+(((-1.0)*r02*x1150))+(((-1.0)*r22*x1146))+((r12*x1148)));
evalcond[1]=(((r22*x1155))+(((-1.0)*x1146))+((x1152*x1154))+(((-1.0)*x1147*x1154)));
evalcond[2]=((((-1.0)*x1144*x1154))+(((-1.0)*x1150))+((r02*x1155))+((x1145*x1154)));
evalcond[3]=(x1148+(((-1.0)*x1149*x1154))+((r12*x1155))+((x1153*x1154)));
evalcond[4]=((-0.0111)+((r22*x1142*x1151))+(((-1.0)*x1143*x1147*x1151))+((x1143*x1151*x1152)));
evalcond[5]=((((-1.0)*x1144*x1150))+((pz*x1152))+(((-1.0)*x1154))+(((-1.0)*x1146*x1147))+(((-1.0)*x1148*x1153))+((x1148*x1149))+((x1145*x1150)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1156=((0.0775)*r22);
IkReal x1157=(r02*sj0);
IkReal x1158=(cj0*r12);
CheckValue<IkReal> x1159=IKPowWithIntegerCheck(((((0.1075)*r21*sj5))+(((-0.1075)*cj5*r20))),-1);
if(!x1159.valid){
continue;
}
if( IKabs(((x1159.value)*(((((-1.0)*pz*(r22*r22)))+(((-1.0)*x1156*x1157))+pz+((x1156*x1158)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((0.720930232558139)*x1157))+(((9.30232558139535)*pz*r22))+(((-0.720930232558139)*x1158)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1159.value)*(((((-1.0)*pz*(r22*r22)))+(((-1.0)*x1156*x1157))+pz+((x1156*x1158))))))+IKsqr(((((0.720930232558139)*x1157))+(((9.30232558139535)*pz*r22))+(((-0.720930232558139)*x1158))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1159.value)*(((((-1.0)*pz*(r22*r22)))+(((-1.0)*x1156*x1157))+pz+((x1156*x1158))))), ((((0.720930232558139)*x1157))+(((9.30232558139535)*pz*r22))+(((-0.720930232558139)*x1158))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1160=IKcos(j4);
IkReal x1161=IKsin(j4);
IkReal x1162=(cj5*r00);
IkReal x1163=(r01*sj5);
IkReal x1164=((1.0)*pz);
IkReal x1165=(cj5*r20);
IkReal x1166=((0.0775)*cj0);
IkReal x1167=(cj5*r10);
IkReal x1168=((0.0775)*sj0);
IkReal x1169=((0.215)*pz);
IkReal x1170=(r21*sj5);
IkReal x1171=(r11*sj5);
IkReal x1172=((0.1075)*x1161);
IkReal x1173=((0.1075)*x1160);
evalcond[0]=(x1173+(((-1.0)*r02*x1168))+((r12*x1166))+(((-1.0)*r22*x1164)));
evalcond[1]=((((-1.0)*x1165*x1172))+((r22*x1173))+(((-1.0)*x1164))+((x1170*x1172)));
evalcond[2]=(((r02*x1173))+((x1163*x1172))+(((-1.0)*x1162*x1172))+(((-1.0)*x1168)));
evalcond[3]=(x1166+((r12*x1173))+(((-1.0)*x1167*x1172))+((x1171*x1172)));
evalcond[4]=((-0.0111)+(((-1.0)*x1161*x1165*x1169))+((r22*x1160*x1169))+((x1161*x1169*x1170)));
evalcond[5]=(((x1163*x1168))+(((-1.0)*x1162*x1168))+((x1166*x1167))+((pz*x1170))+(((-1.0)*x1172))+(((-1.0)*x1164*x1165))+(((-1.0)*x1166*x1171)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
IkReal x1174=((0.215)*pz);
IkReal x1175=((((-1.0)*cj5*r20*x1174))+((r21*sj5*x1174)));
CheckValue<IkReal> x1178 = IKatan2WithCheck(IkReal((r22*x1174)),IkReal(x1175),IKFAST_ATAN2_MAGTHRESH);
if(!x1178.valid){
continue;
}
IkReal x1176=((1.0)*(x1178.value));
if((((x1175*x1175)+(((0.046225)*(pz*pz)*(r22*r22))))) < -0.00001)
continue;
CheckValue<IkReal> x1179=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1175*x1175)+(((0.046225)*(pz*pz)*(r22*r22)))))),-1);
if(!x1179.valid){
continue;
}
if( (((0.0111)*(x1179.value))) < -1-IKFAST_SINCOS_THRESH || (((0.0111)*(x1179.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1177=IKasin(((0.0111)*(x1179.value)));
j4array[0]=(x1177+(((-1.0)*x1176)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x1176))+(((-1.0)*x1177)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
IkReal x1180=IKsin(j4);
IkReal x1181=((0.1075)*x1180);
evalcond[0]=((((-1.0)*cj5*r20*x1181))+(((0.1075)*r22*(IKcos(j4))))+(((-1.0)*pz))+((r21*sj5*x1181)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1182=((1.38709677419355)*sj4);
IkReal x1183=((1.38709677419355)*cj4);
if( IKabs((((r02*x1183))+(((-1.0)*cj5*r00*x1182))+((r01*sj5*x1182)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r11*sj5*x1182))+((cj5*r10*x1182))+(((-1.0)*r12*x1183)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r02*x1183))+(((-1.0)*cj5*r00*x1182))+((r01*sj5*x1182))))+IKsqr(((((-1.0)*r11*sj5*x1182))+((cj5*r10*x1182))+(((-1.0)*r12*x1183))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2((((r02*x1183))+(((-1.0)*cj5*r00*x1182))+((r01*sj5*x1182))), ((((-1.0)*r11*sj5*x1182))+((cj5*r10*x1182))+(((-1.0)*r12*x1183))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1184=IKsin(j0);
IkReal x1185=IKcos(j0);
IkReal x1186=((0.0775)*sj5);
IkReal x1187=((0.0775)*cj5);
IkReal x1188=((1.0)*pz);
IkReal x1189=((0.1075)*sj4);
IkReal x1190=((0.1075)*cj4);
IkReal x1191=(r10*x1185);
IkReal x1192=(r01*x1184);
IkReal x1193=((0.0775)*x1184);
IkReal x1194=(r11*x1185);
IkReal x1195=(r00*x1184);
IkReal x1196=((0.0775)*x1185);
evalcond[0]=(x1190+(((-1.0)*r22*x1188))+((r12*x1196))+(((-1.0)*r02*x1193)));
evalcond[1]=((((-1.0)*x1193))+((r02*x1190))+(((-1.0)*cj5*r00*x1189))+((r01*sj5*x1189)));
evalcond[2]=(x1196+(((-1.0)*cj5*r10*x1189))+((r11*sj5*x1189))+((r12*x1190)));
evalcond[3]=(((x1187*x1194))+((x1186*x1191))+(((-1.0)*cj5*r21*x1188))+(((-1.0)*x1186*x1195))+(((-1.0)*x1187*x1192))+(((-1.0)*r20*sj5*x1188)));
evalcond[4]=(((x1187*x1191))+((x1186*x1192))+(((-1.0)*cj5*r20*x1188))+(((-1.0)*x1186*x1194))+(((-1.0)*x1187*x1195))+(((-1.0)*x1189))+((pz*r21*sj5)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
IkReal x1197=((((0.1075)*r21*sj5))+(((-0.1075)*cj5*r20)));
CheckValue<IkReal> x1200 = IKatan2WithCheck(IkReal(((0.1075)*r22)),IkReal(x1197),IKFAST_ATAN2_MAGTHRESH);
if(!x1200.valid){
continue;
}
IkReal x1198=((1.0)*(x1200.value));
if((((((0.01155625)*(r22*r22)))+(x1197*x1197))) < -0.00001)
continue;
CheckValue<IkReal> x1201=IKPowWithIntegerCheck(IKabs(IKsqrt(((((0.01155625)*(r22*r22)))+(x1197*x1197)))),-1);
if(!x1201.valid){
continue;
}
if( ((pz*(x1201.value))) < -1-IKFAST_SINCOS_THRESH || ((pz*(x1201.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1199=IKasin((pz*(x1201.value)));
j4array[0]=(x1199+(((-1.0)*x1198)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x1198))+(((-1.0)*x1199)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
IkReal x1202=IKsin(j4);
IkReal x1203=((0.215)*pz);
evalcond[0]=((-0.0111)+((r22*x1203*(IKcos(j4))))+((r21*sj5*x1202*x1203))+(((-1.0)*cj5*r20*x1202*x1203)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1204=((1.38709677419355)*sj4);
IkReal x1205=((1.38709677419355)*cj4);
if( IKabs(((((-1.0)*cj5*r00*x1204))+((r01*sj5*x1204))+((r02*x1205)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj5*r10*x1204))+(((-1.0)*r11*sj5*x1204))+(((-1.0)*r12*x1205)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj5*r00*x1204))+((r01*sj5*x1204))+((r02*x1205))))+IKsqr((((cj5*r10*x1204))+(((-1.0)*r11*sj5*x1204))+(((-1.0)*r12*x1205))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(((((-1.0)*cj5*r00*x1204))+((r01*sj5*x1204))+((r02*x1205))), (((cj5*r10*x1204))+(((-1.0)*r11*sj5*x1204))+(((-1.0)*r12*x1205))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1206=IKsin(j0);
IkReal x1207=IKcos(j0);
IkReal x1208=((0.0775)*sj5);
IkReal x1209=((0.0775)*cj5);
IkReal x1210=((1.0)*pz);
IkReal x1211=((0.1075)*sj4);
IkReal x1212=((0.1075)*cj4);
IkReal x1213=(r10*x1207);
IkReal x1214=(r01*x1206);
IkReal x1215=((0.0775)*x1206);
IkReal x1216=(r11*x1207);
IkReal x1217=(r00*x1206);
IkReal x1218=((0.0775)*x1207);
evalcond[0]=(((r12*x1218))+x1212+(((-1.0)*r02*x1215))+(((-1.0)*r22*x1210)));
evalcond[1]=(((r02*x1212))+(((-1.0)*cj5*r00*x1211))+((r01*sj5*x1211))+(((-1.0)*x1215)));
evalcond[2]=(((r12*x1212))+x1218+(((-1.0)*cj5*r10*x1211))+((r11*sj5*x1211)));
evalcond[3]=((((-1.0)*x1209*x1214))+(((-1.0)*x1208*x1217))+(((-1.0)*cj5*r21*x1210))+(((-1.0)*r20*sj5*x1210))+((x1209*x1216))+((x1208*x1213)));
evalcond[4]=((((-1.0)*x1209*x1217))+(((-1.0)*x1208*x1216))+(((-1.0)*cj5*r20*x1210))+((pz*r21*sj5))+(((-1.0)*x1211))+((x1209*x1213))+((x1208*x1214)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
IkReal x1219=((0.1075)*r22);
IkReal x1220=((1.0)*pz);
IkReal x1221=(pz*r22);
IkReal x1222=((0.215)*x1221);
IkReal x1223=((-0.0111)+(((-1.0)*x1222)));
IkReal x1224=(x1219+(((-1.0)*x1220)));
IkReal x1225=((-1.0)*pz);
IkReal x1226=((-0.0111)+x1222);
IkReal x1227=((((-1.0)*x1220))+(((-1.0)*x1219)));
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=x1221;
rxp0_0=(pz*r10);
rxp0_1=(r00*x1225);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1225);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1225);
rxp2_2=0;
IkReal gconst32=x1226;
IkReal gconst33=x1223;
IkReal gconst34=x1224;
IkReal gconst35=x1227;
IkReal gconst36=x1226;
IkReal gconst37=x1223;
IkReal gconst38=x1224;
IkReal gconst39=x1227;
IkReal gconst40=x1226;
IkReal gconst41=x1223;
IkReal gconst42=x1224;
IkReal gconst43=x1227;
IkReal gconst44=x1226;
IkReal gconst45=x1223;
IkReal gconst46=x1224;
IkReal gconst47=x1227;
IkReal x1228=pz*pz;
IkReal x1229=r21*r21;
IkReal x1230=r22*r22;
IkReal x1231=pz*pz*pz*pz;
IkReal x1232=r20*r20;
IkReal x1233=(r20*r21);
IkReal x1234=((0.7396)*x1231);
IkReal x1235=((0.00820956)*x1228);
IkReal x1236=(x1228*x1230);
IkReal x1237=(x1231*x1232);
IkReal x1238=(x1228*x1232);
IkReal x1239=(x1230*x1231);
IkReal x1240=(x1233*x1235);
IkReal x1241=((((2.2781529e-5)*x1233))+((x1233*x1234)));
j5eval[0]=((((0.5)*(IKabs(((((0.01641912)*x1228*x1229))+(((-0.00410478)*x1238))+(((-4.5563058e-5)*x1229))+(((0.3698)*x1237))+(((-1.4792)*x1229*x1231))+(((1.13907645e-5)*x1232))+(((-1.1094)*x1239))+(((0.01231434)*x1236))+(((-3.41722935e-5)*x1230)))))))+(IKabs(((((-1.0)*x1230*x1234))+(((-2.2781529e-5)*x1230))+(((-2.2781529e-5)*x1229))+(((-1.0)*x1229*x1234))+((x1230*x1235))+((x1229*x1235)))))+(IKabs((x1241+(((-1.0)*x1240)))))+(IKabs((x1240+(((-1.0)*x1241)))))+(((0.5)*(IKabs(((((0.00205239)*x1236))+(((0.00205239)*x1238))+(((-0.1849)*x1239))+(((-0.1849)*x1237))+(((-5.69538225e-6)*x1230))+(((-5.69538225e-6)*x1232))))))));
if( IKabs(j5eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j0, j4, j5]

} else
{
IkReal op[8+1], zeror[8];
int numroots;
IkReal x1242=r20*r20;
IkReal x1243=pz*pz;
IkReal x1244=r21*r21;
IkReal x1245=(gconst32*gconst36);
IkReal x1246=(gconst33*gconst38);
IkReal x1247=(r20*r21);
IkReal x1248=(gconst35*gconst40);
IkReal x1249=(gconst45*gconst46);
IkReal x1250=(gconst40*gconst44);
IkReal x1251=(gconst37*gconst38);
IkReal x1252=(gconst32*gconst43);
IkReal x1253=((1.0)*gconst42);
IkReal x1254=(gconst38*gconst41);
IkReal x1255=(gconst37*gconst46);
IkReal x1256=(gconst44*pz);
IkReal x1257=(gconst33*gconst34);
IkReal x1258=(gconst36*gconst39);
IkReal x1259=(gconst36*gconst41);
IkReal x1260=((1.0)*gconst34);
IkReal x1261=(gconst32*gconst44);
IkReal x1262=(gconst36*pz);
IkReal x1263=(gconst33*gconst44);
IkReal x1264=(gconst40*gconst43);
IkReal x1265=(gconst41*gconst44);
IkReal x1266=(gconst34*gconst47);
IkReal x1267=(gconst33*gconst36);
IkReal x1268=(gconst32*gconst35);
IkReal x1269=((1.0)*gconst47);
IkReal x1270=(gconst39*gconst44);
IkReal x1271=(gconst38*gconst45);
IkReal x1272=(gconst42*gconst47);
IkReal x1273=(gconst33*gconst46*pz);
IkReal x1274=((0.3698)*x1244);
IkReal x1275=((0.7396)*x1244);
IkReal x1276=((0.1849)*x1242);
IkReal x1277=(gconst33*x1272);
IkReal x1278=((1.0)*gconst39*gconst43);
IkReal x1279=(gconst39*x1265);
IkReal x1280=(gconst36*x1269);
IkReal x1281=((0.1849)*x1244);
IkReal x1282=((0.3698)*x1242);
IkReal x1283=((1.0)*gconst35*gconst39);
IkReal x1284=((0.09245)*x1242);
IkReal x1285=((0.046225)*x1242);
IkReal x1286=(gconst41*gconst46*pz);
IkReal x1287=(gconst35*gconst38*x1243);
IkReal x1288=(gconst43*gconst46*x1243);
IkReal x1289=(gconst35*x1284);
IkReal x1290=(gconst35*gconst46*x1243);
IkReal x1291=(gconst38*gconst43*x1243);
IkReal x1292=(x1265*x1285);
IkReal x1293=((0.00820956)*x1243*x1247);
IkReal x1294=(x1263*x1285);
IkReal x1295=(x1259*x1285);
IkReal x1296=(x1267*x1285);
IkReal x1297=(gconst43*x1256*x1284);
IkReal x1298=(x1284*x1286);
IkReal x1299=(gconst43*x1262*x1284);
IkReal x1300=(pz*x1254*x1284);
IkReal x1301=(x1273*x1284);
IkReal x1302=(x1256*x1289);
IkReal x1303=(x1262*x1289);
IkReal x1304=(pz*x1246*x1284);
IkReal x1305=(x1276*x1288);
IkReal x1306=(x1276*x1290);
IkReal x1307=(x1276*x1291);
IkReal x1308=(x1276*x1287);
IkReal x1309=((((0.7396)*x1247*(x1243*x1243)))+(((2.2781529e-5)*x1247)));
IkReal x1310=(x1293+(((-1.0)*x1309)));
IkReal x1311=(x1309+(((-1.0)*x1293)));
IkReal x1312=(x1308+x1296);
IkReal x1313=(x1305+x1292);
IkReal x1314=(x1304+x1303);
IkReal x1315=(x1298+x1297);
IkReal x1316=(x1306+x1307+x1294+x1295);
IkReal x1317=(x1300+x1301+x1302+x1299);
op[0]=(x1315+((x1265*x1272))+(((-1.0)*x1313))+(((-1.0)*gconst43*x1250*x1269))+(((-1.0)*gconst41*x1249*x1253))+((x1249*x1264)));
op[1]=x1310;
op[2]=(x1317+((gconst43*x1256*x1274))+((x1264*x1271))+(((-1.0)*x1276*x1286))+(((-1.0)*gconst44*x1248*x1269))+(((-1.0)*x1264*x1280))+(((-1.0)*x1275*x1288))+((gconst42*x1279))+((x1259*x1272))+(((-1.0)*x1316))+(((-1.0)*gconst41*x1253*x1255))+((x1265*x1284))+((x1248*x1249))+(((-1.0)*x1250*x1278))+((x1255*x1264))+(((-1.0)*gconst33*x1249*x1253))+((x1263*x1272))+(((-1.0)*gconst44*x1252*x1269))+(((-1.0)*gconst43*x1256*x1276))+(((-1.0)*gconst45*x1253*x1254))+((x1282*x1288))+((x1274*x1286))+(((-1.0)*gconst41*x1249*x1260))+((x1249*x1252))+((x1265*x1266))+(((-1.0)*x1265*x1281)));
op[3]=x1310;
op[4]=((((-1.0)*gconst41*x1251*x1253))+x1315+x1314+((gconst43*x1262*x1274))+((x1263*x1284))+(((-1.0)*gconst43*x1262*x1276))+(((-1.0)*gconst33*x1253*x1255))+((gconst44*gconst47*x1257))+(((-1.0)*gconst41*x1255*x1260))+((gconst39*gconst42*x1263))+((pz*x1254*x1274))+(((-1.0)*gconst45*x1246*x1253))+((x1282*x1291))+((x1282*x1290))+(((-1.0)*x1312))+(((-1.0)*x1313))+((x1273*x1274))+(((-1.0)*gconst43*x1245*x1269))+(((-1.0)*x1263*x1281))+(((-1.0)*gconst45*x1254*x1260))+(((-1.0)*gconst35*x1261*x1269))+((x1267*x1272))+((x1259*x1266))+(((-1.0)*x1273*x1276))+(((-1.0)*x1249*x1257))+(((-1.0)*pz*x1254*x1276))+((x1252*x1255))+(((-1.0)*gconst35*x1256*x1276))+((gconst35*x1256*x1274))+((x1252*x1271))+((x1259*x1284))+((x1248*x1271))+(((-1.0)*x1248*x1270))+((x1251*x1264))+((gconst41*gconst42*x1258))+(((-1.0)*x1275*x1291))+(((-1.0)*x1275*x1290))+((gconst34*x1279))+((x1249*x1268))+(((-1.0)*x1259*x1281))+((x1248*x1255))+(((-1.0)*x1252*x1270))+(((-1.0)*x1258*x1264))+(((-1.0)*x1248*x1280)));
op[5]=x1311;
op[6]=(x1317+((gconst36*gconst47*x1257))+(((-1.0)*gconst35*x1245*x1269))+((pz*x1246*x1274))+(((-1.0)*x1261*x1283))+(((-1.0)*gconst45*x1246*x1260))+(((-1.0)*x1275*x1287))+(((-1.0)*x1267*x1281))+(((-1.0)*x1316))+(((-1.0)*x1245*x1278))+((gconst34*gconst41*x1258))+(((-1.0)*gconst37*x1246*x1253))+((x1255*x1268))+((x1257*x1270))+(((-1.0)*x1248*x1258))+((gconst33*gconst42*x1258))+((x1268*x1271))+(((-1.0)*pz*x1246*x1276))+(((-1.0)*gconst35*x1262*x1276))+((x1251*x1252))+((gconst35*x1262*x1274))+((x1267*x1284))+((x1282*x1287))+((x1248*x1251))+(((-1.0)*gconst41*x1251*x1260))+(((-1.0)*x1255*x1257)));
op[7]=x1311;
op[8]=(x1314+(((-1.0)*x1245*x1283))+(((-1.0)*x1312))+(((-1.0)*gconst37*x1246*x1260))+((x1257*x1258))+((x1251*x1268)));
polyroots8(op,zeror,numroots);
IkReal j5array[8], cj5array[8], sj5array[8], tempj5array[1];
int numsolutions = 0;
for(int ij5 = 0; ij5 < numroots; ++ij5)
{
IkReal htj5 = zeror[ij5];
tempj5array[0]=((2.0)*(atan(htj5)));
for(int kj5 = 0; kj5 < 1; ++kj5)
{
j5array[numsolutions] = tempj5array[kj5];
if( j5array[numsolutions] > IKPI )
{
    j5array[numsolutions]-=IK2PI;
}
else if( j5array[numsolutions] < -IKPI )
{
    j5array[numsolutions]+=IK2PI;
}
sj5array[numsolutions] = IKsin(j5array[numsolutions]);
cj5array[numsolutions] = IKcos(j5array[numsolutions]);
numsolutions++;
}
}
bool j5valid[8]={true,true,true,true,true,true,true,true};
_nj5 = 8;
for(int ij5 = 0; ij5 < numsolutions; ++ij5)
    {
if( !j5valid[ij5] )
{
    continue;
}
    j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
htj5 = IKtan(j5/2);

_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < numsolutions; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
{
IkReal j4eval[2];
IkReal x1318=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1318);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1318);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1318);
rxp2_2=0;
IkReal x1319=(cj5*r20);
IkReal x1320=(r21*sj5);
j4eval[0]=((r22*r22)+(x1319*x1319)+(x1320*x1320)+(((-2.0)*x1319*x1320)));
j4eval[1]=((((9.30232558139535)*(IKabs(((((-0.1075)*x1319))+(((0.1075)*x1320)))))))+(IKabs(r22)));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
IkReal x1321=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1321);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1321);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1321);
rxp2_2=0;
IkReal x1322=pz*pz;
IkReal x1323=(cj5*r20);
IkReal x1324=(r21*sj5);
j4eval[0]=((IKabs((pz*r22)))+(IKabs((((pz*x1324))+(((-1.0)*pz*x1323))))));
j4eval[1]=(((x1322*(r22*r22)))+((x1322*(x1324*x1324)))+(((-2.0)*x1322*x1323*x1324))+((x1322*(x1323*x1323))));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
IkReal x1325=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1325);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1325);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1325);
rxp2_2=0;
IkReal x1326=cj5*cj5;
IkReal x1327=sj5*sj5;
IkReal x1328=((0.0775)*cj5);
IkReal x1329=(r00*sj5);
IkReal x1330=((2.0)*cj5);
IkReal x1331=(r10*sj5);
j0eval[0]=((IKabs(((((-1.0)*r01*x1328))+(((-0.0775)*x1329)))))+(IKabs((((r11*x1328))+(((0.0775)*x1331))))));
j0eval[1]=(((r11*x1330*x1331))+((x1327*(r10*r10)))+((x1327*(r00*r00)))+((r01*x1329*x1330))+((x1326*(r01*r01)))+((x1326*(r11*r11))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(pz);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j4eval[0]=((IKabs(r22))+(((9.30232558139535)*(IKabs(((((0.1075)*r21*sj5))+(((-0.1075)*cj5*r20))))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
IkReal x1332=((0.0775)*cj5);
IkReal x1333=((0.0775)*sj5);
j0eval[0]=((IKabs((((r11*x1332))+((r10*x1333)))))+(IKabs(((((-1.0)*r00*x1333))+(((-1.0)*r01*x1332))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0, j4]

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x1334=((0.0775)*cj5);
IkReal x1335=((0.0775)*sj5);
CheckValue<IkReal> x1337 = IKatan2WithCheck(IkReal((((r11*x1334))+((r10*x1335)))),IkReal(((((-1.0)*r00*x1335))+(((-1.0)*r01*x1334)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1337.valid){
continue;
}
IkReal x1336=x1337.value;
j0array[0]=((-1.0)*x1336);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x1336)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal j4eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j4eval[0]=(((r21*sj5))+(((-1.0)*cj5*r20)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j4eval[0]=(((r01*sj5))+(((-1.0)*cj5*r00)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j4eval[0]=((((-1.0)*cj5*r10))+((r11*sj5)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r10))+(IKabs(r11)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
cj4array[0]=((-0.720930232558139)*cj0*r12);
if( cj4array[0] >= -1-IKFAST_SINCOS_THRESH && cj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKacos(cj4array[0]);
    sj4array[0] = IKsin(j4array[0]);
    cj4array[1] = cj4array[0];
    j4array[1] = -j4array[0];
    sj4array[1] = -sj4array[0];
}
else if( isnan(cj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x1338=IKsin(j4);
IkReal x1339=((0.1075)*x1338);
evalcond[0]=((-0.1075)*x1338);
evalcond[1]=((((0.1075)*r12*(IKcos(j4))))+(((0.0775)*cj0)));
evalcond[2]=(((r21*sj5*x1339))+(((-1.0)*cj5*r20*x1339)));
evalcond[3]=((((-1.0)*cj5*r00*x1339))+((r01*sj5*x1339)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r21))+(IKabs(r20)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
IkReal x1340=((0.720930232558139)*cj5);
IkReal x1341=((0.720930232558139)*sj5);
sj4array[0]=(((r01*sj0*x1341))+(((-1.0)*cj0*r11*x1341))+(((-1.0)*r00*sj0*x1340))+((cj0*r10*x1340)));
if( sj4array[0] >= -1-IKFAST_SINCOS_THRESH && sj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKasin(sj4array[0]);
    cj4array[0] = IKcos(j4array[0]);
    sj4array[1] = sj4array[0];
    j4array[1] = j4array[0] > 0 ? (IKPI-j4array[0]) : (-IKPI-j4array[0]);
    cj4array[1] = -cj4array[0];
}
else if( isnan(sj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x1342=IKcos(j4);
IkReal x1343=IKsin(j4);
IkReal x1344=((0.1075)*x1342);
IkReal x1345=((0.1075)*x1343);
evalcond[0]=x1344;
evalcond[1]=(r22*x1344);
evalcond[2]=((((-0.0775)*sj0))+((r01*sj5*x1345))+(((-1.0)*cj5*r00*x1345)));
evalcond[3]=(((r11*sj5*x1345))+(((-1.0)*cj5*r10*x1345))+(((0.0775)*cj0)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1346=((31.0)*cj0);
IkReal x1347=(r02*sj0);
CheckValue<IkReal> x1348=IKPowWithIntegerCheck(((((-43.0)*cj5*r10))+(((43.0)*r11*sj5))),-1);
if(!x1348.valid){
continue;
}
if( IKabs(((x1348.value)*(((((-1.0)*x1346))+((x1346*(r12*r12)))+(((-31.0)*r12*x1347)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-0.720930232558139)*cj0*r12))+(((0.720930232558139)*x1347)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1348.value)*(((((-1.0)*x1346))+((x1346*(r12*r12)))+(((-31.0)*r12*x1347))))))+IKsqr(((((-0.720930232558139)*cj0*r12))+(((0.720930232558139)*x1347))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1348.value)*(((((-1.0)*x1346))+((x1346*(r12*r12)))+(((-31.0)*r12*x1347))))), ((((-0.720930232558139)*cj0*r12))+(((0.720930232558139)*x1347))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x1349=IKcos(j4);
IkReal x1350=IKsin(j4);
IkReal x1351=(cj5*r00);
IkReal x1352=(r11*sj5);
IkReal x1353=(r01*sj5);
IkReal x1354=((0.0775)*cj0);
IkReal x1355=(cj5*r10);
IkReal x1356=((0.0775)*sj0);
IkReal x1357=((0.1075)*x1349);
IkReal x1358=((0.1075)*x1350);
evalcond[0]=(x1357+(((-1.0)*r02*x1356))+((r12*x1354)));
evalcond[1]=(((r22*x1357))+((r21*sj5*x1358))+(((-1.0)*cj5*r20*x1358)));
evalcond[2]=((((-1.0)*x1356))+((r02*x1357))+(((-1.0)*x1351*x1358))+((x1353*x1358)));
evalcond[3]=(x1354+(((-1.0)*x1355*x1358))+((r12*x1357))+((x1352*x1358)));
evalcond[4]=((((-1.0)*x1358))+(((-1.0)*x1352*x1354))+((x1354*x1355))+(((-1.0)*x1351*x1356))+((x1353*x1356)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1359=(cj0*r12);
IkReal x1360=((31.0)*sj0);
CheckValue<IkReal> x1361=IKPowWithIntegerCheck(((((43.0)*r01*sj5))+(((-43.0)*cj5*r00))),-1);
if(!x1361.valid){
continue;
}
if( IKabs(((x1361.value)*((x1360+(((31.0)*r02*x1359))+(((-1.0)*x1360*(r02*r02))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((0.720930232558139)*r02*sj0))+(((-0.720930232558139)*x1359)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1361.value)*((x1360+(((31.0)*r02*x1359))+(((-1.0)*x1360*(r02*r02)))))))+IKsqr(((((0.720930232558139)*r02*sj0))+(((-0.720930232558139)*x1359))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1361.value)*((x1360+(((31.0)*r02*x1359))+(((-1.0)*x1360*(r02*r02)))))), ((((0.720930232558139)*r02*sj0))+(((-0.720930232558139)*x1359))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x1362=IKcos(j4);
IkReal x1363=IKsin(j4);
IkReal x1364=(cj5*r00);
IkReal x1365=(r11*sj5);
IkReal x1366=(r01*sj5);
IkReal x1367=((0.0775)*cj0);
IkReal x1368=(cj5*r10);
IkReal x1369=((0.0775)*sj0);
IkReal x1370=((0.1075)*x1362);
IkReal x1371=((0.1075)*x1363);
evalcond[0]=(x1370+(((-1.0)*r02*x1369))+((r12*x1367)));
evalcond[1]=(((r21*sj5*x1371))+((r22*x1370))+(((-1.0)*cj5*r20*x1371)));
evalcond[2]=(((x1366*x1371))+(((-1.0)*x1364*x1371))+((r02*x1370))+(((-1.0)*x1369)));
evalcond[3]=(((x1365*x1371))+x1367+((r12*x1370))+(((-1.0)*x1368*x1371)));
evalcond[4]=((((-1.0)*x1364*x1369))+((x1367*x1368))+((x1366*x1369))+(((-1.0)*x1371))+(((-1.0)*x1365*x1367)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1372=((0.0775)*r22);
IkReal x1373=(r02*sj0);
IkReal x1374=(cj0*r12);
CheckValue<IkReal> x1375=IKPowWithIntegerCheck(((((0.1075)*r21*sj5))+(((-0.1075)*cj5*r20))),-1);
if(!x1375.valid){
continue;
}
if( IKabs(((x1375.value)*((((x1372*x1374))+(((-1.0)*x1372*x1373)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-0.720930232558139)*x1374))+(((0.720930232558139)*x1373)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1375.value)*((((x1372*x1374))+(((-1.0)*x1372*x1373))))))+IKsqr(((((-0.720930232558139)*x1374))+(((0.720930232558139)*x1373))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1375.value)*((((x1372*x1374))+(((-1.0)*x1372*x1373))))), ((((-0.720930232558139)*x1374))+(((0.720930232558139)*x1373))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x1376=IKcos(j4);
IkReal x1377=IKsin(j4);
IkReal x1378=(cj5*r00);
IkReal x1379=(r11*sj5);
IkReal x1380=(r01*sj5);
IkReal x1381=((0.0775)*cj0);
IkReal x1382=(cj5*r10);
IkReal x1383=((0.0775)*sj0);
IkReal x1384=((0.1075)*x1376);
IkReal x1385=((0.1075)*x1377);
evalcond[0]=(x1384+(((-1.0)*r02*x1383))+((r12*x1381)));
evalcond[1]=((((-1.0)*cj5*r20*x1385))+((r21*sj5*x1385))+((r22*x1384)));
evalcond[2]=((((-1.0)*x1383))+((x1380*x1385))+(((-1.0)*x1378*x1385))+((r02*x1384)));
evalcond[3]=(x1381+(((-1.0)*x1382*x1385))+((x1379*x1385))+((r12*x1384)));
evalcond[4]=((((-1.0)*x1385))+((x1380*x1383))+((x1381*x1382))+(((-1.0)*x1378*x1383))+(((-1.0)*x1379*x1381)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x1387 = IKatan2WithCheck(IkReal(((0.1075)*r22)),IkReal(((((0.1075)*r21*sj5))+(((-0.1075)*cj5*r20)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1387.valid){
continue;
}
IkReal x1386=x1387.value;
j4array[0]=((-1.0)*x1386);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x1386)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

{
IkReal j0eval[3];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
IkReal x1388=(cj4*sj5);
IkReal x1389=(r21*sj5);
IkReal x1390=(cj5*r20);
IkReal x1391=(cj4*cj5);
j0eval[0]=(x1389+(((-1.0)*x1390)));
j0eval[1]=IKsign(((((2.4025)*x1389))+(((-2.4025)*x1390))));
j0eval[2]=((IKabs((((r01*x1391))+((r00*x1388)))))+(IKabs((((r10*x1388))+((r11*x1391))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
IkReal x1392=((1333.0)*sj4);
IkReal x1393=(r20*sj5);
IkReal x1394=(cj5*r21);
IkReal x1395=((1333.0)*cj4*sj5);
IkReal x1396=((1333.0)*cj4*cj5);
j0eval[0]=(x1394+x1393);
j0eval[1]=((IKabs(((((-1.0)*r01*x1395))+((r00*x1396))+((r02*x1392)))))+(IKabs((((r10*x1396))+((r12*x1392))+(((-1.0)*r11*x1395))))));
j0eval[2]=IKsign(((((961.0)*x1394))+(((961.0)*x1393))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
px=0;
py=0;
pp=0;
npx=0;
npy=0;
npz=0;
rxp0_0=0;
rxp0_1=0;
rxp0_2=0;
rxp1_0=0;
rxp1_1=0;
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
pz=0;
j0eval[0]=r12;
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1397=((1.38709677419355)*cj5);
IkReal x1398=((1.38709677419355)*sj5);
if( IKabs(((((-1.0)*r00*x1397))+((r01*x1398)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r10*x1397))+(((-1.0)*r11*x1398)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r00*x1397))+((r01*x1398))))+IKsqr((((r10*x1397))+(((-1.0)*r11*x1398))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2(((((-1.0)*r00*x1397))+((r01*x1398))), (((r10*x1397))+(((-1.0)*r11*x1398))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1399=IKsin(j0);
IkReal x1400=IKcos(j0);
IkReal x1401=(r01*sj5);
IkReal x1402=(cj5*r10);
IkReal x1403=(cj5*r00);
IkReal x1404=((0.0775)*x1399);
IkReal x1405=((0.0775)*x1400);
IkReal x1406=(sj5*x1405);
evalcond[0]=(((r12*x1405))+(((-1.0)*r02*x1404)));
evalcond[1]=((((-0.1075)*x1403))+(((-1.0)*x1404))+(((0.1075)*x1401)));
evalcond[2]=((((-0.1075)*x1402))+x1405+(((0.1075)*r11*sj5)));
evalcond[3]=((((-1.0)*cj5*r01*x1404))+((cj5*r11*x1405))+(((-1.0)*r00*sj5*x1404))+((r10*x1406)));
evalcond[4]=((-0.1075)+(((-1.0)*r11*x1406))+((x1402*x1405))+(((-1.0)*x1403*x1404))+((x1401*x1404)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1407=((1.38709677419355)*cj5);
IkReal x1408=((1.38709677419355)*sj5);
if( IKabs((((r00*x1407))+(((-1.0)*r01*x1408)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r11*x1408))+(((-1.0)*r10*x1407)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r00*x1407))+(((-1.0)*r01*x1408))))+IKsqr((((r11*x1408))+(((-1.0)*r10*x1407))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2((((r00*x1407))+(((-1.0)*r01*x1408))), (((r11*x1408))+(((-1.0)*r10*x1407))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1409=IKsin(j0);
IkReal x1410=IKcos(j0);
IkReal x1411=(r01*sj5);
IkReal x1412=(cj5*r10);
IkReal x1413=(cj5*r00);
IkReal x1414=((0.0775)*x1409);
IkReal x1415=((0.0775)*x1410);
IkReal x1416=(sj5*x1415);
evalcond[0]=((((-1.0)*r02*x1414))+((r12*x1415)));
evalcond[1]=((((-1.0)*x1414))+(((0.1075)*x1413))+(((-0.1075)*x1411)));
evalcond[2]=((((-0.1075)*r11*sj5))+x1415+(((0.1075)*x1412)));
evalcond[3]=((((-1.0)*cj5*r01*x1414))+((cj5*r11*x1415))+(((-1.0)*r00*sj5*x1414))+((r10*x1416)));
evalcond[4]=((0.1075)+((x1412*x1415))+(((-1.0)*x1413*x1414))+((x1411*x1414))+(((-1.0)*r11*x1416)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r21))+(IKabs(r20)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1417=((1.38709677419355)*cj5*sj4);
IkReal x1418=((1.38709677419355)*sj4*sj5);
if( IKabs((((r01*x1418))+(((-1.0)*r00*x1417)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r11*x1418))+((r10*x1417)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*x1418))+(((-1.0)*r00*x1417))))+IKsqr(((((-1.0)*r11*x1418))+((r10*x1417))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2((((r01*x1418))+(((-1.0)*r00*x1417))), ((((-1.0)*r11*x1418))+((r10*x1417))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[4];
IkReal x1419=IKcos(j0);
IkReal x1420=IKsin(j0);
IkReal x1421=((0.1075)*sj4);
IkReal x1422=(r01*sj5);
IkReal x1423=(cj5*r00);
IkReal x1424=(cj5*r10);
IkReal x1425=((0.0775)*x1420);
IkReal x1426=((0.0775)*x1419);
IkReal x1427=(r11*x1426);
evalcond[0]=((((-1.0)*x1421*x1423))+((x1421*x1422))+(((-1.0)*x1425)));
evalcond[1]=((((-1.0)*x1421*x1424))+((r11*sj5*x1421))+x1426);
evalcond[2]=(((cj5*x1427))+(((-1.0)*cj5*r01*x1425))+(((-1.0)*r00*sj5*x1425))+((r10*sj5*x1426)));
evalcond[3]=(((x1424*x1426))+((x1422*x1425))+(((-1.0)*sj5*x1427))+(((-1.0)*x1423*x1425))+(((-1.0)*x1421)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1428=((1.38709677419355)*sj4);
IkReal x1429=(cj5*r00);
IkReal x1430=(r01*sj5);
IkReal x1431=((43.0)*cj4);
IkReal x1432=((43.0)*r02*sj4);
CheckValue<IkReal> x1433=IKPowWithIntegerCheck(r12,-1);
if(!x1433.valid){
continue;
}
if( IKabs((((x1428*x1430))+(((1.38709677419355)*cj4*r02))+(((-1.0)*x1428*x1429)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.032258064516129)*(x1433.value)*((((x1430*x1432))+(((-1.0)*x1429*x1432))+(((-1.0)*x1431))+((x1431*(r02*r02))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x1428*x1430))+(((1.38709677419355)*cj4*r02))+(((-1.0)*x1428*x1429))))+IKsqr(((0.032258064516129)*(x1433.value)*((((x1430*x1432))+(((-1.0)*x1429*x1432))+(((-1.0)*x1431))+((x1431*(r02*r02)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2((((x1428*x1430))+(((1.38709677419355)*cj4*r02))+(((-1.0)*x1428*x1429))), ((0.032258064516129)*(x1433.value)*((((x1430*x1432))+(((-1.0)*x1429*x1432))+(((-1.0)*x1431))+((x1431*(r02*r02)))))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1434=IKsin(j0);
IkReal x1435=IKcos(j0);
IkReal x1436=((0.1075)*cj4);
IkReal x1437=(r11*sj5);
IkReal x1438=(r01*sj5);
IkReal x1439=((0.1075)*sj4);
IkReal x1440=((0.0775)*x1435);
IkReal x1441=(cj5*x1439);
IkReal x1442=((0.0775)*x1434);
evalcond[0]=(((r12*x1440))+x1436+(((-1.0)*r02*x1442)));
evalcond[1]=(((r02*x1436))+(((-1.0)*r00*x1441))+((x1438*x1439))+(((-1.0)*x1442)));
evalcond[2]=(((x1437*x1439))+((r12*x1436))+(((-1.0)*r10*x1441))+x1440);
evalcond[3]=(((r10*sj5*x1440))+(((-1.0)*cj5*r01*x1442))+((cj5*r11*x1440))+(((-1.0)*r00*sj5*x1442)));
evalcond[4]=(((x1438*x1442))+((cj5*r10*x1440))+(((-1.0)*x1437*x1440))+(((-1.0)*x1439))+(((-1.0)*cj5*r00*x1442)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1443=((1333.0)*sj4);
IkReal x1444=((1333.0)*cj4*sj5);
IkReal x1445=((1333.0)*cj4*cj5);
CheckValue<IkReal> x1446 = IKatan2WithCheck(IkReal((((r12*x1443))+((r10*x1445))+(((-1.0)*r11*x1444)))),IkReal(((((-1.0)*r01*x1444))+((r02*x1443))+((r00*x1445)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1446.valid){
continue;
}
CheckValue<IkReal> x1447=IKPowWithIntegerCheck(IKsign(((((961.0)*cj5*r21))+(((961.0)*r20*sj5)))),-1);
if(!x1447.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x1446.value)+(((1.5707963267949)*(x1447.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1448=IKsin(j0);
IkReal x1449=IKcos(j0);
IkReal x1450=((0.1075)*cj4);
IkReal x1451=(r11*sj5);
IkReal x1452=(r01*sj5);
IkReal x1453=((0.1075)*sj4);
IkReal x1454=((0.0775)*x1449);
IkReal x1455=(cj5*x1453);
IkReal x1456=((0.0775)*x1448);
evalcond[0]=(((r12*x1454))+(((-1.0)*r02*x1456))+x1450);
evalcond[1]=((((-1.0)*x1456))+(((-1.0)*r00*x1455))+((x1452*x1453))+((r02*x1450)));
evalcond[2]=(((r12*x1450))+x1454+(((-1.0)*r10*x1455))+((x1451*x1453)));
evalcond[3]=((((-1.0)*cj5*r01*x1456))+((r10*sj5*x1454))+(((-1.0)*r00*sj5*x1456))+((cj5*r11*x1454)));
evalcond[4]=((((-1.0)*cj5*r00*x1456))+(((-1.0)*x1453))+((cj5*r10*x1454))+(((-1.0)*x1451*x1454))+((x1452*x1456)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1457=((3.3325)*cj4*cj5);
IkReal x1458=((3.3325)*cj4*sj5);
CheckValue<IkReal> x1459 = IKatan2WithCheck(IkReal((((r10*x1458))+((r11*x1457)))),IkReal((((r01*x1457))+((r00*x1458)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1459.valid){
continue;
}
CheckValue<IkReal> x1460=IKPowWithIntegerCheck(IKsign(((((-2.4025)*cj5*r20))+(((2.4025)*r21*sj5)))),-1);
if(!x1460.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x1459.value)+(((1.5707963267949)*(x1460.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1461=IKsin(j0);
IkReal x1462=IKcos(j0);
IkReal x1463=((0.1075)*cj4);
IkReal x1464=(r11*sj5);
IkReal x1465=(r01*sj5);
IkReal x1466=((0.1075)*sj4);
IkReal x1467=((0.0775)*x1462);
IkReal x1468=(cj5*x1466);
IkReal x1469=((0.0775)*x1461);
evalcond[0]=((((-1.0)*r02*x1469))+((r12*x1467))+x1463);
evalcond[1]=((((-1.0)*x1469))+((x1465*x1466))+(((-1.0)*r00*x1468))+((r02*x1463)));
evalcond[2]=(((x1464*x1466))+((r12*x1463))+x1467+(((-1.0)*r10*x1468)));
evalcond[3]=((((-1.0)*cj5*r01*x1469))+((cj5*r11*x1467))+(((-1.0)*r00*sj5*x1469))+((r10*sj5*x1467)));
evalcond[4]=(((cj5*r10*x1467))+(((-1.0)*x1466))+((x1465*x1469))+(((-1.0)*x1464*x1467))+(((-1.0)*cj5*r00*x1469)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x1470=((0.0775)*cj5);
IkReal x1471=((1.0)*pz);
IkReal x1472=((0.0775)*sj5);
IkReal x1473=(((r10*x1472))+((r11*x1470)));
IkReal x1474=((((-1.0)*r01*x1470))+(((-1.0)*r00*x1472)));
CheckValue<IkReal> x1477 = IKatan2WithCheck(IkReal(x1473),IkReal(x1474),IKFAST_ATAN2_MAGTHRESH);
if(!x1477.valid){
continue;
}
IkReal x1475=((1.0)*(x1477.value));
if((((x1474*x1474)+(x1473*x1473))) < -0.00001)
continue;
CheckValue<IkReal> x1478=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1474*x1474)+(x1473*x1473)))),-1);
if(!x1478.valid){
continue;
}
if( (((-1.0)*(x1478.value)*(((((-1.0)*cj5*r21*x1471))+(((-1.0)*r20*sj5*x1471)))))) < -1-IKFAST_SINCOS_THRESH || (((-1.0)*(x1478.value)*(((((-1.0)*cj5*r21*x1471))+(((-1.0)*r20*sj5*x1471)))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1476=((-1.0)*(IKasin(((-1.0)*(x1478.value)*(((((-1.0)*cj5*r21*x1471))+(((-1.0)*r20*sj5*x1471))))))));
j0array[0]=((((-1.0)*x1475))+(((-1.0)*x1476)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((1.0)*x1476))+(((-1.0)*x1475)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal j4eval[1];
IkReal x1479=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1479);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1479);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1479);
rxp2_2=0;
j4eval[0]=(((r21*sj5))+(((-1.0)*cj5*r20)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
IkReal x1480=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1480);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1480);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1480);
rxp2_2=0;
j4eval[0]=(((r01*sj5))+(((-1.0)*cj5*r00)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
IkReal x1481=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1481);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1481);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1481);
rxp2_2=0;
j4eval[0]=((((-1.0)*cj5*r10))+((r11*sj5)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x1483 = ((1.0)+(((-1.0)*(r12*r12))));
if(IKabs(x1483)==0){
continue;
}
IkReal x1482=pow(x1483,-0.5);
CheckValue<IkReal> x1484 = IKatan2WithCheck(IkReal(((-1.0)*r10)),IkReal(r11),IKFAST_ATAN2_MAGTHRESH);
if(!x1484.valid){
continue;
}
IkReal gconst64=((-1.0)*(x1484.value));
IkReal gconst65=(r10*x1482);
IkReal gconst66=(r11*x1482);
CheckValue<IkReal> x1485 = IKatan2WithCheck(IkReal(((-1.0)*r10)),IkReal(r11),IKFAST_ATAN2_MAGTHRESH);
if(!x1485.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x1485.value)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1486=((0.0775)*r22);
IkReal x1487=(r02*sj0);
IkReal x1488=(cj0*r12);
CheckValue<IkReal> x1489=IKPowWithIntegerCheck(((((0.1075)*gconst65*r21))+(((-0.1075)*gconst66*r20))),-1);
if(!x1489.valid){
continue;
}
if( IKabs(((x1489.value)*(((((-1.0)*x1486*x1487))+(((-1.0)*pz*(r22*r22)))+((x1486*x1488))+pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((0.720930232558139)*x1487))+(((9.30232558139535)*pz*r22))+(((-0.720930232558139)*x1488)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1489.value)*(((((-1.0)*x1486*x1487))+(((-1.0)*pz*(r22*r22)))+((x1486*x1488))+pz))))+IKsqr(((((0.720930232558139)*x1487))+(((9.30232558139535)*pz*r22))+(((-0.720930232558139)*x1488))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1489.value)*(((((-1.0)*x1486*x1487))+(((-1.0)*pz*(r22*r22)))+((x1486*x1488))+pz))), ((((0.720930232558139)*x1487))+(((9.30232558139535)*pz*r22))+(((-0.720930232558139)*x1488))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1490=IKcos(j4);
IkReal x1491=IKsin(j4);
IkReal x1492=((0.0775)*cj0);
IkReal x1493=((0.215)*pz);
IkReal x1494=((1.0)*pz);
IkReal x1495=((0.0775)*sj0);
IkReal x1496=(gconst65*r21);
IkReal x1497=((0.1075)*x1490);
IkReal x1498=(gconst66*x1491);
IkReal x1499=((0.1075)*gconst65*x1491);
evalcond[0]=(((r12*x1492))+(((-1.0)*r02*x1495))+x1497+(((-1.0)*r22*x1494)));
evalcond[1]=((((-1.0)*x1494))+(((-0.1075)*r20*x1498))+((r22*x1497))+(((0.1075)*x1491*x1496)));
evalcond[2]=((((-1.0)*x1495))+((r01*x1499))+(((-0.1075)*r00*x1498))+((r02*x1497)));
evalcond[3]=(((r12*x1497))+((r11*x1499))+x1492+(((-0.1075)*r10*x1498)));
evalcond[4]=((-0.0111)+((r22*x1490*x1493))+((x1491*x1493*x1496))+(((-1.0)*r20*x1493*x1498)));
evalcond[5]=(((gconst66*r10*x1492))+((pz*x1496))+(((-1.0)*gconst66*r20*x1494))+(((-1.0)*gconst65*r11*x1492))+((gconst65*r01*x1495))+(((-1.0)*gconst66*r00*x1495))+(((-0.1075)*x1491)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1502 = ((1.0)+(((-1.0)*(r12*r12))));
if(IKabs(x1502)==0){
continue;
}
IkReal x1500=pow(x1502,-0.5);
IkReal x1501=((-1.0)*x1500);
CheckValue<IkReal> x1503 = IKatan2WithCheck(IkReal(((-1.0)*r10)),IkReal(r11),IKFAST_ATAN2_MAGTHRESH);
if(!x1503.valid){
continue;
}
IkReal gconst67=((3.14159265358979)+(((-1.0)*(x1503.value))));
IkReal gconst68=(r10*x1501);
IkReal gconst69=(r11*x1501);
CheckValue<IkReal> x1504 = IKatan2WithCheck(IkReal(((-1.0)*r10)),IkReal(r11),IKFAST_ATAN2_MAGTHRESH);
if(!x1504.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x1504.value)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1505=((0.0775)*r22);
IkReal x1506=(r02*sj0);
IkReal x1507=(cj0*r12);
CheckValue<IkReal> x1508=IKPowWithIntegerCheck(((((-0.1075)*gconst69*r20))+(((0.1075)*gconst68*r21))),-1);
if(!x1508.valid){
continue;
}
if( IKabs(((x1508.value)*(((((-1.0)*pz*(r22*r22)))+pz+((x1505*x1507))+(((-1.0)*x1505*x1506)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-0.720930232558139)*x1507))+(((0.720930232558139)*x1506))+(((9.30232558139535)*pz*r22)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1508.value)*(((((-1.0)*pz*(r22*r22)))+pz+((x1505*x1507))+(((-1.0)*x1505*x1506))))))+IKsqr(((((-0.720930232558139)*x1507))+(((0.720930232558139)*x1506))+(((9.30232558139535)*pz*r22))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1508.value)*(((((-1.0)*pz*(r22*r22)))+pz+((x1505*x1507))+(((-1.0)*x1505*x1506))))), ((((-0.720930232558139)*x1507))+(((0.720930232558139)*x1506))+(((9.30232558139535)*pz*r22))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1509=IKcos(j4);
IkReal x1510=IKsin(j4);
IkReal x1511=((0.0775)*cj0);
IkReal x1512=(gconst69*r10);
IkReal x1513=((0.215)*pz);
IkReal x1514=((1.0)*pz);
IkReal x1515=(gconst69*r20);
IkReal x1516=((0.0775)*sj0);
IkReal x1517=(gconst69*r00);
IkReal x1518=((0.1075)*x1509);
IkReal x1519=(gconst68*x1510);
IkReal x1520=((0.1075)*x1510);
evalcond[0]=((((-1.0)*r22*x1514))+((r12*x1511))+x1518+(((-1.0)*r02*x1516)));
evalcond[1]=((((-1.0)*x1514))+(((-1.0)*x1515*x1520))+((r22*x1518))+(((0.1075)*r21*x1519)));
evalcond[2]=((((-1.0)*x1516))+(((0.1075)*r01*x1519))+((r02*x1518))+(((-1.0)*x1517*x1520)));
evalcond[3]=(((r12*x1518))+(((0.1075)*r11*x1519))+x1511+(((-1.0)*x1512*x1520)));
evalcond[4]=((-0.0111)+(((-1.0)*x1510*x1513*x1515))+((r21*x1513*x1519))+((r22*x1509*x1513)));
evalcond[5]=((((-1.0)*x1516*x1517))+(((-1.0)*x1520))+(((-1.0)*x1514*x1515))+((gconst68*r01*x1516))+((gconst68*pz*r21))+(((-1.0)*gconst68*r11*x1511))+((x1511*x1512)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1522 = ((1.0)+(((-1.0)*(r02*r02))));
if(IKabs(x1522)==0){
continue;
}
IkReal x1521=pow(x1522,-0.5);
CheckValue<IkReal> x1523 = IKatan2WithCheck(IkReal(((-1.0)*r00)),IkReal(r01),IKFAST_ATAN2_MAGTHRESH);
if(!x1523.valid){
continue;
}
IkReal gconst70=((-1.0)*(x1523.value));
IkReal gconst71=(r00*x1521);
IkReal gconst72=(r01*x1521);
CheckValue<IkReal> x1524 = IKatan2WithCheck(IkReal(((-1.0)*r00)),IkReal(r01),IKFAST_ATAN2_MAGTHRESH);
if(!x1524.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x1524.value)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1525=((0.0775)*r22);
IkReal x1526=(r02*sj0);
IkReal x1527=(cj0*r12);
CheckValue<IkReal> x1528=IKPowWithIntegerCheck(((((-0.1075)*gconst72*r20))+(((0.1075)*gconst71*r21))),-1);
if(!x1528.valid){
continue;
}
if( IKabs(((x1528.value)*((((x1525*x1527))+(((-1.0)*x1525*x1526))+(((-1.0)*pz*(r22*r22)))+pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-0.720930232558139)*x1527))+(((0.720930232558139)*x1526))+(((9.30232558139535)*pz*r22)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1528.value)*((((x1525*x1527))+(((-1.0)*x1525*x1526))+(((-1.0)*pz*(r22*r22)))+pz))))+IKsqr(((((-0.720930232558139)*x1527))+(((0.720930232558139)*x1526))+(((9.30232558139535)*pz*r22))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1528.value)*((((x1525*x1527))+(((-1.0)*x1525*x1526))+(((-1.0)*pz*(r22*r22)))+pz))), ((((-0.720930232558139)*x1527))+(((0.720930232558139)*x1526))+(((9.30232558139535)*pz*r22))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1529=IKcos(j4);
IkReal x1530=IKsin(j4);
IkReal x1531=((0.0775)*cj0);
IkReal x1532=(gconst72*r00);
IkReal x1533=((0.0775)*sj0);
IkReal x1534=(gconst71*r01);
IkReal x1535=((1.0)*pz);
IkReal x1536=(gconst71*r21);
IkReal x1537=((0.215)*pz);
IkReal x1538=(gconst72*r20);
IkReal x1539=(gconst72*r10);
IkReal x1540=(gconst71*r11);
IkReal x1541=((0.1075)*x1530);
IkReal x1542=((0.1075)*x1529);
evalcond[0]=(((r12*x1531))+(((-1.0)*r22*x1535))+(((-1.0)*r02*x1533))+x1542);
evalcond[1]=(((x1536*x1541))+(((-1.0)*x1535))+((r22*x1542))+(((-1.0)*x1538*x1541)));
evalcond[2]=((((-1.0)*x1533))+(((-1.0)*x1532*x1541))+((x1534*x1541))+((r02*x1542)));
evalcond[3]=(((r12*x1542))+x1531+((x1540*x1541))+(((-1.0)*x1539*x1541)));
evalcond[4]=((-0.0111)+((x1530*x1536*x1537))+(((-1.0)*x1530*x1537*x1538))+((r22*x1529*x1537)));
evalcond[5]=((((-1.0)*x1532*x1533))+((x1531*x1539))+(((-1.0)*x1531*x1540))+(((-1.0)*x1535*x1538))+((x1533*x1534))+(((-1.0)*x1541))+((pz*x1536)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1543=((-1.0)*r00);
IkReal x1545 = ((1.0)+(((-1.0)*(r02*r02))));
if(IKabs(x1545)==0){
continue;
}
IkReal x1544=pow(x1545,-0.5);
CheckValue<IkReal> x1546 = IKatan2WithCheck(IkReal(x1543),IkReal(r01),IKFAST_ATAN2_MAGTHRESH);
if(!x1546.valid){
continue;
}
IkReal gconst73=((3.14159265358979)+(((-1.0)*(x1546.value))));
IkReal gconst74=(x1543*x1544);
IkReal gconst75=((-1.0)*r01*x1544);
CheckValue<IkReal> x1547 = IKatan2WithCheck(IkReal(((-1.0)*r00)),IkReal(r01),IKFAST_ATAN2_MAGTHRESH);
if(!x1547.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x1547.value)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1548=(cj0*r12);
IkReal x1549=((0.0775)*r22);
IkReal x1550=(r02*sj0);
CheckValue<IkReal> x1551=IKPowWithIntegerCheck(((((-0.1075)*gconst75*r20))+(((0.1075)*gconst74*r21))),-1);
if(!x1551.valid){
continue;
}
if( IKabs(((x1551.value)*(((((-1.0)*x1549*x1550))+(((-1.0)*pz*(r22*r22)))+pz+((x1548*x1549)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((9.30232558139535)*pz*r22))+(((-0.720930232558139)*x1548))+(((0.720930232558139)*x1550)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1551.value)*(((((-1.0)*x1549*x1550))+(((-1.0)*pz*(r22*r22)))+pz+((x1548*x1549))))))+IKsqr(((((9.30232558139535)*pz*r22))+(((-0.720930232558139)*x1548))+(((0.720930232558139)*x1550))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1551.value)*(((((-1.0)*x1549*x1550))+(((-1.0)*pz*(r22*r22)))+pz+((x1548*x1549))))), ((((9.30232558139535)*pz*r22))+(((-0.720930232558139)*x1548))+(((0.720930232558139)*x1550))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1552=IKcos(j4);
IkReal x1553=IKsin(j4);
IkReal x1554=((0.0775)*cj0);
IkReal x1555=(pz*r20);
IkReal x1556=((1.0)*pz);
IkReal x1557=(gconst74*r11);
IkReal x1558=((0.0775)*sj0);
IkReal x1559=(gconst74*r01);
IkReal x1560=((0.215)*pz);
IkReal x1561=(gconst74*r21);
IkReal x1562=((0.1075)*x1552);
IkReal x1563=(gconst75*x1553);
IkReal x1564=((0.1075)*x1553);
evalcond[0]=((((-1.0)*r22*x1556))+(((-1.0)*r02*x1558))+((r12*x1554))+x1562);
evalcond[1]=(((x1561*x1564))+(((-0.1075)*r20*x1563))+((r22*x1562))+(((-1.0)*x1556)));
evalcond[2]=((((-0.1075)*r00*x1563))+(((-1.0)*x1558))+((r02*x1562))+((x1559*x1564)));
evalcond[3]=((((-0.1075)*r10*x1563))+((r12*x1562))+x1554+((x1557*x1564)));
evalcond[4]=((-0.0111)+(((-0.215)*x1555*x1563))+((x1553*x1560*x1561))+((r22*x1552*x1560)));
evalcond[5]=((((-1.0)*gconst75*x1555))+(((-1.0)*gconst75*r00*x1558))+((gconst75*r10*x1554))+((pz*x1561))+((x1558*x1559))+(((-1.0)*x1564))+(((-1.0)*x1554*x1557)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1566 = ((1.0)+(((-1.0)*(r22*r22))));
if(IKabs(x1566)==0){
continue;
}
IkReal x1565=pow(x1566,-0.5);
CheckValue<IkReal> x1567 = IKatan2WithCheck(IkReal(((-1.0)*r20)),IkReal(r21),IKFAST_ATAN2_MAGTHRESH);
if(!x1567.valid){
continue;
}
IkReal gconst76=((-1.0)*(x1567.value));
IkReal gconst77=(r20*x1565);
IkReal gconst78=(r21*x1565);
CheckValue<IkReal> x1568 = IKatan2WithCheck(IkReal(((-1.0)*r20)),IkReal(r21),IKFAST_ATAN2_MAGTHRESH);
if(!x1568.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x1568.value)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1569=(pz*r22);
IkReal x1570=(cj0*r12);
IkReal x1571=((31.0)*sj0);
CheckValue<IkReal> x1572=IKPowWithIntegerCheck(((((43.0)*gconst77*r01))+(((-43.0)*gconst78*r00))),-1);
if(!x1572.valid){
continue;
}
if( IKabs(((x1572.value)*((x1571+(((31.0)*r02*x1570))+(((-1.0)*x1571*(r02*r02)))+(((-400.0)*r02*x1569)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((0.720930232558139)*r02*sj0))+(((-0.720930232558139)*x1570))+(((9.30232558139535)*x1569)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1572.value)*((x1571+(((31.0)*r02*x1570))+(((-1.0)*x1571*(r02*r02)))+(((-400.0)*r02*x1569))))))+IKsqr(((((0.720930232558139)*r02*sj0))+(((-0.720930232558139)*x1570))+(((9.30232558139535)*x1569))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1572.value)*((x1571+(((31.0)*r02*x1570))+(((-1.0)*x1571*(r02*r02)))+(((-400.0)*r02*x1569))))), ((((0.720930232558139)*r02*sj0))+(((-0.720930232558139)*x1570))+(((9.30232558139535)*x1569))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1573=IKcos(j4);
IkReal x1574=IKsin(j4);
IkReal x1575=((0.0775)*sj0);
IkReal x1576=(gconst78*r00);
IkReal x1577=((0.0775)*cj0);
IkReal x1578=(gconst77*r11);
IkReal x1579=(gconst77*r01);
IkReal x1580=(gconst77*r21);
IkReal x1581=(gconst78*r10);
IkReal x1582=(pz*r22);
IkReal x1583=((0.1075)*x1574);
IkReal x1584=((0.1075)*x1573);
IkReal x1585=(gconst78*pz*r20);
IkReal x1586=((0.215)*x1574);
evalcond[0]=((((-1.0)*r02*x1575))+((r12*x1577))+x1584+(((-1.0)*x1582)));
evalcond[1]=((((-1.0)*pz))+((x1580*x1583))+((r22*x1584))+(((-1.0)*gconst78*r20*x1583)));
evalcond[2]=(((r02*x1584))+((x1579*x1583))+(((-1.0)*x1575))+(((-1.0)*x1576*x1583)));
evalcond[3]=(((r12*x1584))+x1577+(((-1.0)*x1581*x1583))+((x1578*x1583)));
evalcond[4]=((-0.0111)+(((-1.0)*x1585*x1586))+(((0.215)*x1573*x1582))+((pz*x1580*x1586)));
evalcond[5]=((((-1.0)*x1583))+(((-1.0)*x1575*x1576))+((x1575*x1579))+(((-1.0)*x1577*x1578))+((pz*x1580))+((x1577*x1581))+(((-1.0)*x1585)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1589 = ((1.0)+(((-1.0)*(r22*r22))));
if(IKabs(x1589)==0){
continue;
}
IkReal x1587=pow(x1589,-0.5);
IkReal x1588=((-1.0)*x1587);
CheckValue<IkReal> x1590 = IKatan2WithCheck(IkReal(((-1.0)*r20)),IkReal(r21),IKFAST_ATAN2_MAGTHRESH);
if(!x1590.valid){
continue;
}
IkReal gconst79=((3.14159265358979)+(((-1.0)*(x1590.value))));
IkReal gconst80=(r20*x1588);
IkReal gconst81=(r21*x1588);
CheckValue<IkReal> x1591 = IKatan2WithCheck(IkReal(((-1.0)*r20)),IkReal(r21),IKFAST_ATAN2_MAGTHRESH);
if(!x1591.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x1591.value)+j5)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1592=(pz*r22);
IkReal x1593=((31.0)*sj0);
IkReal x1594=(cj0*r12);
CheckValue<IkReal> x1595=IKPowWithIntegerCheck(((((-43.0)*gconst81*r00))+(((43.0)*gconst80*r01))),-1);
if(!x1595.valid){
continue;
}
if( IKabs(((x1595.value)*(((((-1.0)*x1593*(r02*r02)))+(((-400.0)*r02*x1592))+(((31.0)*r02*x1594))+x1593)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((9.30232558139535)*x1592))+(((0.720930232558139)*r02*sj0))+(((-0.720930232558139)*x1594)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1595.value)*(((((-1.0)*x1593*(r02*r02)))+(((-400.0)*r02*x1592))+(((31.0)*r02*x1594))+x1593))))+IKsqr(((((9.30232558139535)*x1592))+(((0.720930232558139)*r02*sj0))+(((-0.720930232558139)*x1594))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1595.value)*(((((-1.0)*x1593*(r02*r02)))+(((-400.0)*r02*x1592))+(((31.0)*r02*x1594))+x1593))), ((((9.30232558139535)*x1592))+(((0.720930232558139)*r02*sj0))+(((-0.720930232558139)*x1594))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1596=IKcos(j4);
IkReal x1597=IKsin(j4);
IkReal x1598=((0.0775)*cj0);
IkReal x1599=(gconst80*r11);
IkReal x1600=((1.0)*pz);
IkReal x1601=(gconst81*r20);
IkReal x1602=(gconst80*r21);
IkReal x1603=((0.0775)*sj0);
IkReal x1604=((0.215)*pz);
IkReal x1605=(gconst80*r01);
IkReal x1606=((0.1075)*x1596);
IkReal x1607=((0.1075)*x1597);
IkReal x1608=(gconst81*x1607);
evalcond[0]=(x1606+((r12*x1598))+(((-1.0)*r22*x1600))+(((-1.0)*r02*x1603)));
evalcond[1]=((((-1.0)*x1600))+(((-1.0)*x1601*x1607))+((r22*x1606))+((x1602*x1607)));
evalcond[2]=((((-1.0)*x1603))+(((-1.0)*r00*x1608))+((x1605*x1607))+((r02*x1606)));
evalcond[3]=(((x1599*x1607))+x1598+((r12*x1606))+(((-1.0)*r10*x1608)));
evalcond[4]=((-0.0111)+((r22*x1596*x1604))+((x1597*x1602*x1604))+(((-1.0)*x1597*x1601*x1604)));
evalcond[5]=((((-1.0)*gconst81*r00*x1603))+(((-1.0)*x1607))+((gconst81*r10*x1598))+(((-1.0)*x1600*x1601))+(((-1.0)*x1598*x1599))+((x1603*x1605))+((pz*x1602)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(r21))+(IKabs(r20)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
IkReal x1609=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1609);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1609);
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
r20=0;
r21=0;
r02=0;
r12=0;
j4eval[0]=(((r01*sj5))+(((-1.0)*cj5*r00)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
IkReal x1610=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1610);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1610);
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
r20=0;
r21=0;
r02=0;
r12=0;
j4eval[0]=((((-1.0)*cj5*r10))+((r11*sj5)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
IkReal x1611=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=0;
npy=0;
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1611);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1611);
rxp1_2=0;
rxp2_0=0;
rxp2_1=0;
rxp2_2=0;
r20=0;
r21=0;
r02=0;
r12=0;
j4eval[0]=(((r01*sj5))+(((-1.0)*cj5*r00)));
j4eval[1]=pz;
j4eval[2]=r22;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(pz);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
IkReal x1612=((0.720930232558139)*cj5);
IkReal x1613=((0.720930232558139)*sj5);
sj4array[0]=(((cj0*r10*x1612))+(((-1.0)*cj0*r11*x1613))+((r01*sj0*x1613))+(((-1.0)*r00*sj0*x1612)));
if( sj4array[0] >= -1-IKFAST_SINCOS_THRESH && sj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKasin(sj4array[0]);
    cj4array[0] = IKcos(j4array[0]);
    sj4array[1] = sj4array[0];
    j4array[1] = j4array[0] > 0 ? (IKPI-j4array[0]) : (-IKPI-j4array[0]);
    cj4array[1] = -cj4array[0];
}
else if( isnan(sj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[4];
IkReal x1614=IKcos(j4);
IkReal x1615=IKsin(j4);
IkReal x1616=((0.1075)*x1614);
IkReal x1617=((0.1075)*x1615);
evalcond[0]=x1616;
evalcond[1]=(r22*x1616);
evalcond[2]=(((r01*sj5*x1617))+(((-1.0)*cj5*r00*x1617))+(((-0.0775)*sj0)));
evalcond[3]=(((r11*sj5*x1617))+(((-1.0)*cj5*r10*x1617))+(((0.0775)*cj0)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x1618=IKPowWithIntegerCheck(((((43.0)*r01*sj5))+(((-43.0)*cj5*r00))),-1);
if(!x1618.valid){
continue;
}
CheckValue<IkReal> x1619=IKPowWithIntegerCheck(pz,-1);
if(!x1619.valid){
continue;
}
CheckValue<IkReal> x1620=IKPowWithIntegerCheck(r22,-1);
if(!x1620.valid){
continue;
}
if( IKabs(((31.0)*sj0*(x1618.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.0516279069767442)*(x1619.value)*(x1620.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((31.0)*sj0*(x1618.value)))+IKsqr(((0.0516279069767442)*(x1619.value)*(x1620.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((31.0)*sj0*(x1618.value)), ((0.0516279069767442)*(x1619.value)*(x1620.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1621=IKcos(j4);
IkReal x1622=IKsin(j4);
IkReal x1623=(r11*sj5);
IkReal x1624=(cj5*r00);
IkReal x1625=((1.0)*pz);
IkReal x1626=(r01*sj5);
IkReal x1627=((0.0775)*cj0);
IkReal x1628=(cj5*r10);
IkReal x1629=((0.0775)*sj0);
IkReal x1630=(r22*x1621);
IkReal x1631=((0.1075)*x1622);
evalcond[0]=((-0.0111)+(((0.215)*pz*x1630)));
evalcond[1]=((((0.1075)*x1621))+(((-1.0)*r22*x1625)));
evalcond[2]=((((-1.0)*x1625))+(((0.1075)*x1630)));
evalcond[3]=((((-1.0)*x1624*x1631))+(((-1.0)*x1629))+((x1626*x1631)));
evalcond[4]=(x1627+((x1623*x1631))+(((-1.0)*x1628*x1631)));
evalcond[5]=(((x1627*x1628))+((x1626*x1629))+(((-1.0)*x1631))+(((-1.0)*x1623*x1627))+(((-1.0)*x1624*x1629)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x1632=IKPowWithIntegerCheck(((((-43.0)*cj5*r10))+(((43.0)*r11*sj5))),-1);
if(!x1632.valid){
continue;
}
if( IKabs(((-31.0)*cj0*(x1632.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((9.30232558139535)*pz*r22)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-31.0)*cj0*(x1632.value)))+IKsqr(((9.30232558139535)*pz*r22))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-31.0)*cj0*(x1632.value)), ((9.30232558139535)*pz*r22));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1633=IKcos(j4);
IkReal x1634=IKsin(j4);
IkReal x1635=(r11*sj5);
IkReal x1636=(cj5*r00);
IkReal x1637=((1.0)*pz);
IkReal x1638=(r01*sj5);
IkReal x1639=((0.0775)*cj0);
IkReal x1640=(cj5*r10);
IkReal x1641=((0.0775)*sj0);
IkReal x1642=(r22*x1633);
IkReal x1643=((0.1075)*x1634);
evalcond[0]=((-0.0111)+(((0.215)*pz*x1642)));
evalcond[1]=((((-1.0)*r22*x1637))+(((0.1075)*x1633)));
evalcond[2]=((((-1.0)*x1637))+(((0.1075)*x1642)));
evalcond[3]=((((-1.0)*x1641))+(((-1.0)*x1636*x1643))+((x1638*x1643)));
evalcond[4]=(x1639+(((-1.0)*x1640*x1643))+((x1635*x1643)));
evalcond[5]=((((-1.0)*x1635*x1639))+(((-1.0)*x1643))+((x1639*x1640))+(((-1.0)*x1636*x1641))+((x1638*x1641)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x1644=IKPowWithIntegerCheck(((((43.0)*r01*sj5))+(((-43.0)*cj5*r00))),-1);
if(!x1644.valid){
continue;
}
if( IKabs(((31.0)*sj0*(x1644.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((9.30232558139535)*pz*r22)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((31.0)*sj0*(x1644.value)))+IKsqr(((9.30232558139535)*pz*r22))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((31.0)*sj0*(x1644.value)), ((9.30232558139535)*pz*r22));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1645=IKcos(j4);
IkReal x1646=IKsin(j4);
IkReal x1647=(r11*sj5);
IkReal x1648=(cj5*r00);
IkReal x1649=((1.0)*pz);
IkReal x1650=(r01*sj5);
IkReal x1651=((0.0775)*cj0);
IkReal x1652=(cj5*r10);
IkReal x1653=((0.0775)*sj0);
IkReal x1654=(r22*x1645);
IkReal x1655=((0.1075)*x1646);
evalcond[0]=((-0.0111)+(((0.215)*pz*x1654)));
evalcond[1]=((((-1.0)*r22*x1649))+(((0.1075)*x1645)));
evalcond[2]=((((0.1075)*x1654))+(((-1.0)*x1649)));
evalcond[3]=(((x1650*x1655))+(((-1.0)*x1653))+(((-1.0)*x1648*x1655)));
evalcond[4]=((((-1.0)*x1652*x1655))+x1651+((x1647*x1655)));
evalcond[5]=(((x1650*x1653))+(((-1.0)*x1647*x1651))+(((-1.0)*x1655))+((x1651*x1652))+(((-1.0)*x1648*x1653)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1656=((31.0)*cj0);
IkReal x1657=(pz*r22);
IkReal x1658=(r02*sj0);
CheckValue<IkReal> x1659=IKPowWithIntegerCheck(((((-43.0)*cj5*r10))+(((43.0)*r11*sj5))),-1);
if(!x1659.valid){
continue;
}
if( IKabs(((x1659.value)*(((((-31.0)*r12*x1658))+(((-400.0)*r12*x1657))+(((-1.0)*x1656))+((x1656*(r12*r12))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-0.720930232558139)*cj0*r12))+(((0.720930232558139)*x1658))+(((9.30232558139535)*x1657)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1659.value)*(((((-31.0)*r12*x1658))+(((-400.0)*r12*x1657))+(((-1.0)*x1656))+((x1656*(r12*r12)))))))+IKsqr(((((-0.720930232558139)*cj0*r12))+(((0.720930232558139)*x1658))+(((9.30232558139535)*x1657))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1659.value)*(((((-31.0)*r12*x1658))+(((-400.0)*r12*x1657))+(((-1.0)*x1656))+((x1656*(r12*r12)))))), ((((-0.720930232558139)*cj0*r12))+(((0.720930232558139)*x1658))+(((9.30232558139535)*x1657))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1660=IKcos(j4);
IkReal x1661=IKsin(j4);
IkReal x1662=(cj5*r00);
IkReal x1663=(r01*sj5);
IkReal x1664=((1.0)*pz);
IkReal x1665=(cj5*r20);
IkReal x1666=((0.0775)*cj0);
IkReal x1667=(cj5*r10);
IkReal x1668=((0.0775)*sj0);
IkReal x1669=((0.215)*pz);
IkReal x1670=(r21*sj5);
IkReal x1671=(r11*sj5);
IkReal x1672=((0.1075)*x1661);
IkReal x1673=((0.1075)*x1660);
evalcond[0]=(((r12*x1666))+x1673+(((-1.0)*r22*x1664))+(((-1.0)*r02*x1668)));
evalcond[1]=((((-1.0)*x1664))+(((-1.0)*x1665*x1672))+((r22*x1673))+((x1670*x1672)));
evalcond[2]=(((r02*x1673))+(((-1.0)*x1662*x1672))+(((-1.0)*x1668))+((x1663*x1672)));
evalcond[3]=((((-1.0)*x1667*x1672))+x1666+((x1671*x1672))+((r12*x1673)));
evalcond[4]=((-0.0111)+(((-1.0)*x1661*x1665*x1669))+((x1661*x1669*x1670))+((r22*x1660*x1669)));
evalcond[5]=((((-1.0)*x1662*x1668))+((pz*x1670))+(((-1.0)*x1666*x1671))+((x1666*x1667))+(((-1.0)*x1672))+((x1663*x1668))+(((-1.0)*x1664*x1665)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1674=(pz*r22);
IkReal x1675=(cj0*r12);
IkReal x1676=((31.0)*sj0);
CheckValue<IkReal> x1677=IKPowWithIntegerCheck(((((43.0)*r01*sj5))+(((-43.0)*cj5*r00))),-1);
if(!x1677.valid){
continue;
}
if( IKabs(((x1677.value)*(((((31.0)*r02*x1675))+x1676+(((-400.0)*r02*x1674))+(((-1.0)*x1676*(r02*r02))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((9.30232558139535)*x1674))+(((0.720930232558139)*r02*sj0))+(((-0.720930232558139)*x1675)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1677.value)*(((((31.0)*r02*x1675))+x1676+(((-400.0)*r02*x1674))+(((-1.0)*x1676*(r02*r02)))))))+IKsqr(((((9.30232558139535)*x1674))+(((0.720930232558139)*r02*sj0))+(((-0.720930232558139)*x1675))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1677.value)*(((((31.0)*r02*x1675))+x1676+(((-400.0)*r02*x1674))+(((-1.0)*x1676*(r02*r02)))))), ((((9.30232558139535)*x1674))+(((0.720930232558139)*r02*sj0))+(((-0.720930232558139)*x1675))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1678=IKcos(j4);
IkReal x1679=IKsin(j4);
IkReal x1680=(cj5*r00);
IkReal x1681=(r01*sj5);
IkReal x1682=((1.0)*pz);
IkReal x1683=(cj5*r20);
IkReal x1684=((0.0775)*cj0);
IkReal x1685=(cj5*r10);
IkReal x1686=((0.0775)*sj0);
IkReal x1687=((0.215)*pz);
IkReal x1688=(r21*sj5);
IkReal x1689=(r11*sj5);
IkReal x1690=((0.1075)*x1679);
IkReal x1691=((0.1075)*x1678);
evalcond[0]=(x1691+((r12*x1684))+(((-1.0)*r22*x1682))+(((-1.0)*r02*x1686)));
evalcond[1]=((((-1.0)*x1682))+((r22*x1691))+(((-1.0)*x1683*x1690))+((x1688*x1690)));
evalcond[2]=((((-1.0)*x1686))+(((-1.0)*x1680*x1690))+((r02*x1691))+((x1681*x1690)));
evalcond[3]=(((r12*x1691))+x1684+((x1689*x1690))+(((-1.0)*x1685*x1690)));
evalcond[4]=((-0.0111)+(((-1.0)*x1679*x1683*x1687))+((x1679*x1687*x1688))+((r22*x1678*x1687)));
evalcond[5]=(((x1681*x1686))+(((-1.0)*x1690))+(((-1.0)*x1682*x1683))+(((-1.0)*x1680*x1686))+((pz*x1688))+((x1684*x1685))+(((-1.0)*x1684*x1689)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x1692=((0.0775)*r22);
IkReal x1693=(r02*sj0);
IkReal x1694=(cj0*r12);
CheckValue<IkReal> x1695=IKPowWithIntegerCheck(((((0.1075)*r21*sj5))+(((-0.1075)*cj5*r20))),-1);
if(!x1695.valid){
continue;
}
if( IKabs(((x1695.value)*(((((-1.0)*x1692*x1693))+(((-1.0)*pz*(r22*r22)))+((x1692*x1694))+pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-0.720930232558139)*x1694))+(((9.30232558139535)*pz*r22))+(((0.720930232558139)*x1693)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1695.value)*(((((-1.0)*x1692*x1693))+(((-1.0)*pz*(r22*r22)))+((x1692*x1694))+pz))))+IKsqr(((((-0.720930232558139)*x1694))+(((9.30232558139535)*pz*r22))+(((0.720930232558139)*x1693))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x1695.value)*(((((-1.0)*x1692*x1693))+(((-1.0)*pz*(r22*r22)))+((x1692*x1694))+pz))), ((((-0.720930232558139)*x1694))+(((9.30232558139535)*pz*r22))+(((0.720930232558139)*x1693))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x1696=IKcos(j4);
IkReal x1697=IKsin(j4);
IkReal x1698=(cj5*r00);
IkReal x1699=(r01*sj5);
IkReal x1700=((1.0)*pz);
IkReal x1701=(cj5*r20);
IkReal x1702=((0.0775)*cj0);
IkReal x1703=(cj5*r10);
IkReal x1704=((0.0775)*sj0);
IkReal x1705=((0.215)*pz);
IkReal x1706=(r21*sj5);
IkReal x1707=(r11*sj5);
IkReal x1708=((0.1075)*x1697);
IkReal x1709=((0.1075)*x1696);
evalcond[0]=(((r12*x1702))+x1709+(((-1.0)*r02*x1704))+(((-1.0)*r22*x1700)));
evalcond[1]=(((r22*x1709))+((x1706*x1708))+(((-1.0)*x1700))+(((-1.0)*x1701*x1708)));
evalcond[2]=((((-1.0)*x1698*x1708))+((r02*x1709))+(((-1.0)*x1704))+((x1699*x1708)));
evalcond[3]=(((r12*x1709))+x1702+(((-1.0)*x1703*x1708))+((x1707*x1708)));
evalcond[4]=((-0.0111)+((r22*x1696*x1705))+(((-1.0)*x1697*x1701*x1705))+((x1697*x1705*x1706)));
evalcond[5]=((((-1.0)*x1702*x1707))+(((-1.0)*x1698*x1704))+(((-1.0)*x1708))+(((-1.0)*x1700*x1701))+((x1702*x1703))+((x1699*x1704))+((pz*x1706)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
IkReal x1710=((0.215)*pz);
IkReal x1711=((((-1.0)*cj5*r20*x1710))+((r21*sj5*x1710)));
CheckValue<IkReal> x1714 = IKatan2WithCheck(IkReal((r22*x1710)),IkReal(x1711),IKFAST_ATAN2_MAGTHRESH);
if(!x1714.valid){
continue;
}
IkReal x1712=((1.0)*(x1714.value));
if((((x1711*x1711)+(((0.046225)*(pz*pz)*(r22*r22))))) < -0.00001)
continue;
CheckValue<IkReal> x1715=IKPowWithIntegerCheck(IKabs(IKsqrt(((x1711*x1711)+(((0.046225)*(pz*pz)*(r22*r22)))))),-1);
if(!x1715.valid){
continue;
}
if( (((0.0111)*(x1715.value))) < -1-IKFAST_SINCOS_THRESH || (((0.0111)*(x1715.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1713=IKasin(((0.0111)*(x1715.value)));
j4array[0]=(x1713+(((-1.0)*x1712)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x1712))+(((-1.0)*x1713)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
IkReal x1716=IKsin(j4);
IkReal x1717=((0.1075)*x1716);
evalcond[0]=((((-1.0)*cj5*r20*x1717))+(((0.1075)*r22*(IKcos(j4))))+(((-1.0)*pz))+((r21*sj5*x1717)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1718=((1.38709677419355)*sj4);
IkReal x1719=((1.38709677419355)*cj4);
if( IKabs((((r02*x1719))+(((-1.0)*cj5*r00*x1718))+((r01*sj5*x1718)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj5*r10*x1718))+(((-1.0)*r11*sj5*x1718))+(((-1.0)*r12*x1719)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r02*x1719))+(((-1.0)*cj5*r00*x1718))+((r01*sj5*x1718))))+IKsqr((((cj5*r10*x1718))+(((-1.0)*r11*sj5*x1718))+(((-1.0)*r12*x1719))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2((((r02*x1719))+(((-1.0)*cj5*r00*x1718))+((r01*sj5*x1718))), (((cj5*r10*x1718))+(((-1.0)*r11*sj5*x1718))+(((-1.0)*r12*x1719))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1720=IKsin(j0);
IkReal x1721=IKcos(j0);
IkReal x1722=((0.0775)*sj5);
IkReal x1723=((0.0775)*cj5);
IkReal x1724=((1.0)*pz);
IkReal x1725=((0.1075)*sj4);
IkReal x1726=((0.1075)*cj4);
IkReal x1727=(r10*x1721);
IkReal x1728=(r01*x1720);
IkReal x1729=((0.0775)*x1720);
IkReal x1730=(r11*x1721);
IkReal x1731=(r00*x1720);
IkReal x1732=((0.0775)*x1721);
evalcond[0]=((((-1.0)*r22*x1724))+x1726+((r12*x1732))+(((-1.0)*r02*x1729)));
evalcond[1]=(((r02*x1726))+(((-1.0)*cj5*r00*x1725))+(((-1.0)*x1729))+((r01*sj5*x1725)));
evalcond[2]=(x1732+(((-1.0)*cj5*r10*x1725))+((r11*sj5*x1725))+((r12*x1726)));
evalcond[3]=(((x1723*x1730))+((x1722*x1727))+(((-1.0)*x1722*x1731))+(((-1.0)*r20*sj5*x1724))+(((-1.0)*x1723*x1728))+(((-1.0)*cj5*r21*x1724)));
evalcond[4]=(((x1723*x1727))+((x1722*x1728))+(((-1.0)*x1722*x1730))+(((-1.0)*x1723*x1731))+(((-1.0)*cj5*r20*x1724))+((pz*r21*sj5))+(((-1.0)*x1725)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
IkReal x1733=((((0.1075)*r21*sj5))+(((-0.1075)*cj5*r20)));
CheckValue<IkReal> x1736 = IKatan2WithCheck(IkReal(((0.1075)*r22)),IkReal(x1733),IKFAST_ATAN2_MAGTHRESH);
if(!x1736.valid){
continue;
}
IkReal x1734=((1.0)*(x1736.value));
if((((((0.01155625)*(r22*r22)))+(x1733*x1733))) < -0.00001)
continue;
CheckValue<IkReal> x1737=IKPowWithIntegerCheck(IKabs(IKsqrt(((((0.01155625)*(r22*r22)))+(x1733*x1733)))),-1);
if(!x1737.valid){
continue;
}
if( ((pz*(x1737.value))) < -1-IKFAST_SINCOS_THRESH || ((pz*(x1737.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1735=IKasin((pz*(x1737.value)));
j4array[0]=(x1735+(((-1.0)*x1734)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x1735))+(((-1.0)*x1734)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
IkReal x1738=IKsin(j4);
IkReal x1739=((0.215)*pz);
evalcond[0]=((-0.0111)+(((-1.0)*cj5*r20*x1738*x1739))+((r22*x1739*(IKcos(j4))))+((r21*sj5*x1738*x1739)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x1740=((1.38709677419355)*sj4);
IkReal x1741=((1.38709677419355)*cj4);
if( IKabs((((r01*sj5*x1740))+((r02*x1741))+(((-1.0)*cj5*r00*x1740)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r12*x1741))+((cj5*r10*x1740))+(((-1.0)*r11*sj5*x1740)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*sj5*x1740))+((r02*x1741))+(((-1.0)*cj5*r00*x1740))))+IKsqr(((((-1.0)*r12*x1741))+((cj5*r10*x1740))+(((-1.0)*r11*sj5*x1740))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j0array[0]=IKatan2((((r01*sj5*x1740))+((r02*x1741))+(((-1.0)*cj5*r00*x1740))), ((((-1.0)*r12*x1741))+((cj5*r10*x1740))+(((-1.0)*r11*sj5*x1740))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x1742=IKsin(j0);
IkReal x1743=IKcos(j0);
IkReal x1744=((0.0775)*sj5);
IkReal x1745=((0.0775)*cj5);
IkReal x1746=((1.0)*pz);
IkReal x1747=((0.1075)*sj4);
IkReal x1748=((0.1075)*cj4);
IkReal x1749=(r10*x1743);
IkReal x1750=(r01*x1742);
IkReal x1751=((0.0775)*x1742);
IkReal x1752=(r11*x1743);
IkReal x1753=(r00*x1742);
IkReal x1754=((0.0775)*x1743);
evalcond[0]=(x1748+(((-1.0)*r22*x1746))+(((-1.0)*r02*x1751))+((r12*x1754)));
evalcond[1]=(((r01*sj5*x1747))+((r02*x1748))+(((-1.0)*cj5*r00*x1747))+(((-1.0)*x1751)));
evalcond[2]=(((r12*x1748))+x1754+((r11*sj5*x1747))+(((-1.0)*cj5*r10*x1747)));
evalcond[3]=(((x1744*x1749))+((x1745*x1752))+(((-1.0)*cj5*r21*x1746))+(((-1.0)*x1745*x1750))+(((-1.0)*x1744*x1753))+(((-1.0)*r20*sj5*x1746)));
evalcond[4]=(((x1744*x1750))+((x1745*x1749))+(((-1.0)*cj5*r20*x1746))+(((-1.0)*x1745*x1753))+(((-1.0)*x1747))+(((-1.0)*x1744*x1752))+((pz*r21*sj5)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j4, j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x1757 = IKatan2WithCheck(IkReal(((-0.155)*py)),IkReal(((0.155)*px)),IKFAST_ATAN2_MAGTHRESH);
if(!x1757.valid){
continue;
}
IkReal x1755=((1.0)*(x1757.value));
if((((((0.024025)*(py*py)))+(((0.024025)*(px*px))))) < -0.00001)
continue;
CheckValue<IkReal> x1758=IKPowWithIntegerCheck(IKabs(IKsqrt(((((0.024025)*(py*py)))+(((0.024025)*(px*px)))))),-1);
if(!x1758.valid){
continue;
}
if( (((x1758.value)*(((-0.00555)+pp)))) < -1-IKFAST_SINCOS_THRESH || (((x1758.value)*(((-0.00555)+pp)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1756=IKasin(((x1758.value)*(((-0.00555)+pp))));
j0array[0]=((((-1.0)*x1755))+(((-1.0)*x1756)));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x1756+(((-1.0)*x1755)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
cj4array[0]=((((-0.720930232558139)*cj0*r12))+(((0.720930232558139)*r02*sj0))+(((9.30232558139535)*npz)));
if( cj4array[0] >= -1-IKFAST_SINCOS_THRESH && cj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKacos(cj4array[0]);
    sj4array[0] = IKsin(j4array[0]);
    cj4array[1] = cj4array[0];
    j4array[1] = -j4array[0];
    sj4array[1] = -sj4array[0];
}
else if( isnan(cj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

{
IkReal j5eval[3];
IkReal x1759=(r02*sj4);
IkReal x1760=((31.0)*cj0);
IkReal x1761=((43.0)*cj4);
j5eval[0]=x1759;
j5eval[1]=IKsign(x1759);
j5eval[2]=((IKabs((((r21*x1760))+(((-1.0)*r00*x1761))+(((400.0)*rxp1_0)))))+(IKabs((((r20*x1760))+((r01*x1761))+(((400.0)*rxp0_0))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal j5eval[3];
IkReal x1762=(r12*sj4);
IkReal x1763=((43.0)*cj4);
IkReal x1764=((31.0)*sj0);
j5eval[0]=x1762;
j5eval[1]=((IKabs(((((-1.0)*r21*x1764))+(((-400.0)*rxp1_1))+((r10*x1763)))))+(IKabs(((((-1.0)*r20*x1764))+(((-1.0)*r11*x1763))+(((-400.0)*rxp0_1))))));
j5eval[2]=IKsign(x1762);
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal j5eval[3];
IkReal x1765=((200.0)*pp);
IkReal x1766=((400.0)*pz);
IkReal x1767=(npx*r21*sj4);
IkReal x1768=((43.0)*cj4*npz);
IkReal x1769=((43.0)*cj4*r22);
IkReal x1770=(npy*r20*sj4);
j5eval[0]=((((-1.0)*x1767))+x1770);
j5eval[1]=((IKabs((((r20*x1765))+(((-1.0)*r20*x1768))+((npx*x1769))+(((1.11)*r20))+(((-1.0)*npx*x1766)))))+(IKabs((((r21*x1765))+(((-1.0)*r21*x1768))+((npy*x1769))+(((-1.0)*npy*x1766))+(((1.11)*r21))))));
j5eval[2]=IKsign(((((43.0)*x1770))+(((-43.0)*x1767))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
sj4=0;
cj4=1.0;
j4=0;
IkReal x1771=((0.0775)*sj0);
IkReal x1772=((0.0775)*cj0);
j5eval[0]=((IKabs(((((-1.0)*npx))+((r10*x1772))+(((-1.0)*r00*x1771)))))+(IKabs((npy+((r01*x1771))+(((-1.0)*r11*x1772))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
sj4=0;
cj4=1.0;
j4=0;
IkReal x1773=((0.0775)*sj0);
IkReal x1774=((0.0775)*cj0);
j5eval[0]=((IKabs((((r11*x1774))+(((-1.0)*npy))+(((-1.0)*r01*x1773)))))+(IKabs(((((-1.0)*npx))+((r10*x1774))+(((-1.0)*r00*x1773))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j5]

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1775=((0.0775)*sj0);
IkReal x1776=((0.0775)*cj0);
CheckValue<IkReal> x1778 = IKatan2WithCheck(IkReal((((r11*x1776))+(((-1.0)*npy))+(((-1.0)*r01*x1775)))),IkReal(((((-1.0)*npx))+((r10*x1776))+(((-1.0)*r00*x1775)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1778.valid){
continue;
}
IkReal x1777=x1778.value;
j5array[0]=((-1.0)*x1777);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1777)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1779=IKsin(j5);
IkReal x1780=IKcos(j5);
IkReal x1781=((0.0775)*sj0);
IkReal x1782=((0.0775)*cj0);
evalcond[0]=(((r10*x1780*x1782))+((r01*x1779*x1781))+(((-1.0)*r11*x1779*x1782))+((npy*x1779))+(((-1.0)*r00*x1780*x1781))+(((-1.0)*npx*x1780)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1783=((0.0775)*sj0);
IkReal x1784=((0.0775)*cj0);
CheckValue<IkReal> x1786 = IKatan2WithCheck(IkReal((((r10*x1784))+(((-1.0)*r00*x1783))+(((-1.0)*npx)))),IkReal(((((-1.0)*r11*x1784))+npy+((r01*x1783)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1786.valid){
continue;
}
IkReal x1785=x1786.value;
j5array[0]=((-1.0)*x1785);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1785)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1787=IKcos(j5);
IkReal x1788=IKsin(j5);
IkReal x1789=((0.0775)*cj0);
IkReal x1790=((0.0775)*sj0);
evalcond[0]=((((-1.0)*r01*x1787*x1790))+(((-1.0)*npy*x1787))+(((-1.0)*r00*x1788*x1790))+((r10*x1788*x1789))+((r11*x1787*x1789))+(((-1.0)*npx*x1788)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
IkReal x1791=((0.0775)*sj0);
IkReal x1792=((0.0775)*cj0);
j5eval[0]=((IKabs(((((-1.0)*r11*x1792))+npy+((r01*x1791)))))+(IKabs((((r10*x1792))+(((-1.0)*r00*x1791))+(((-1.0)*npx))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
IkReal x1793=((0.0775)*sj0);
IkReal x1794=((0.0775)*cj0);
j5eval[0]=((IKabs(((((-1.0)*r01*x1793))+(((-1.0)*npy))+((r11*x1794)))))+(IKabs((((r10*x1794))+(((-1.0)*r00*x1793))+(((-1.0)*npx))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j5]

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1795=((0.0775)*sj0);
IkReal x1796=((0.0775)*cj0);
CheckValue<IkReal> x1798 = IKatan2WithCheck(IkReal(((((-1.0)*r01*x1795))+(((-1.0)*npy))+((r11*x1796)))),IkReal((((r10*x1796))+(((-1.0)*r00*x1795))+(((-1.0)*npx)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1798.valid){
continue;
}
IkReal x1797=x1798.value;
j5array[0]=((-1.0)*x1797);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1797)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1799=IKsin(j5);
IkReal x1800=IKcos(j5);
IkReal x1801=((0.0775)*sj0);
IkReal x1802=((0.0775)*cj0);
evalcond[0]=((((-1.0)*r11*x1799*x1802))+((r01*x1799*x1801))+(((-1.0)*r00*x1800*x1801))+((npy*x1799))+((r10*x1800*x1802))+(((-1.0)*npx*x1800)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1803=((0.0775)*sj0);
IkReal x1804=((0.0775)*cj0);
CheckValue<IkReal> x1806 = IKatan2WithCheck(IkReal(((((-1.0)*r00*x1803))+(((-1.0)*npx))+((r10*x1804)))),IkReal((npy+((r01*x1803))+(((-1.0)*r11*x1804)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1806.valid){
continue;
}
IkReal x1805=x1806.value;
j5array[0]=((-1.0)*x1805);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1805)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1807=IKcos(j5);
IkReal x1808=IKsin(j5);
IkReal x1809=((0.0775)*cj0);
IkReal x1810=((0.0775)*sj0);
evalcond[0]=((((-1.0)*r01*x1807*x1810))+((r10*x1808*x1809))+(((-1.0)*npy*x1807))+(((-1.0)*r00*x1808*x1810))+((r11*x1807*x1809))+(((-1.0)*npx*x1808)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(r02);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[3];
r02=0;
npz=(((py*r12))+((pz*r22)));
rxp2_1=(px*r22);
rxp2_2=((-1.0)*px*r12);
IkReal x1811=(r12*sj4);
IkReal x1812=((31.0)*sj0);
IkReal x1813=((43.0)*cj4*r22);
j5eval[0]=x1811;
j5eval[1]=IKsign(x1811);
j5eval[2]=((IKabs(((((-400.0)*rxp1_1))+(((-1.0)*r01*x1813))+(((-1.0)*r21*x1812)))))+(IKabs(((((-400.0)*rxp0_1))+(((-1.0)*r00*x1813))+(((-1.0)*r20*x1812))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal j5eval[3];
r02=0;
npz=(((py*r12))+((pz*r22)));
rxp2_1=(px*r22);
rxp2_2=((-1.0)*px*r12);
IkReal x1814=(r22*sj4);
IkReal x1815=((31.0)*sj0);
IkReal x1816=((31.0)*cj0);
IkReal x1817=((43.0)*cj4*r12);
j5eval[0]=x1814;
j5eval[1]=((IKabs(((((-1.0)*r11*x1815))+(((-1.0)*r01*x1817))+(((-1.0)*r01*x1816))+(((400.0)*rxp1_2)))))+(IKabs(((((400.0)*rxp0_2))+(((-1.0)*r10*x1815))+(((-1.0)*r00*x1816))+(((-1.0)*r00*x1817))))));
j5eval[2]=IKsign(x1814);
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
r02=0;
npz=(((py*r12))+((pz*r22)));
rxp2_1=(px*r22);
rxp2_2=((-1.0)*px*r12);
sj4=0;
cj4=1.0;
j4=0;
IkReal x1818=((0.0775)*sj0);
IkReal x1819=((0.0775)*cj0);
j5eval[0]=((IKabs((npy+(((-1.0)*r11*x1819))+((r01*x1818)))))+(IKabs(((((-1.0)*npx))+(((-1.0)*r00*x1818))+((r10*x1819))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
r02=0;
npz=(((py*r12))+((pz*r22)));
rxp2_1=(px*r22);
rxp2_2=((-1.0)*px*r12);
sj4=0;
cj4=1.0;
j4=0;
IkReal x1820=((0.0775)*sj0);
IkReal x1821=((0.0775)*cj0);
j5eval[0]=((IKabs((((r10*x1821))+(((-1.0)*npx))+(((-1.0)*r00*x1820)))))+(IKabs(((((-1.0)*npy))+(((-1.0)*r01*x1820))+((r11*x1821))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j5]

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1822=((0.0775)*sj0);
IkReal x1823=((0.0775)*cj0);
CheckValue<IkReal> x1825 = IKatan2WithCheck(IkReal(((((-1.0)*npy))+(((-1.0)*r01*x1822))+((r11*x1823)))),IkReal((((r10*x1823))+(((-1.0)*npx))+(((-1.0)*r00*x1822)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1825.valid){
continue;
}
IkReal x1824=x1825.value;
j5array[0]=((-1.0)*x1824);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1824)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1826=IKsin(j5);
IkReal x1827=IKcos(j5);
IkReal x1828=((0.0775)*sj0);
IkReal x1829=((0.0775)*cj0);
evalcond[0]=(((r01*x1826*x1828))+((r10*x1827*x1829))+(((-1.0)*r11*x1826*x1829))+(((-1.0)*r00*x1827*x1828))+((npy*x1826))+(((-1.0)*npx*x1827)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1830=((0.0775)*sj0);
IkReal x1831=((0.0775)*cj0);
CheckValue<IkReal> x1833 = IKatan2WithCheck(IkReal((((r10*x1831))+(((-1.0)*r00*x1830))+(((-1.0)*npx)))),IkReal((((r01*x1830))+npy+(((-1.0)*r11*x1831)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1833.valid){
continue;
}
IkReal x1832=x1833.value;
j5array[0]=((-1.0)*x1832);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1832)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1834=IKcos(j5);
IkReal x1835=IKsin(j5);
IkReal x1836=((0.0775)*cj0);
IkReal x1837=((0.0775)*sj0);
evalcond[0]=((((-1.0)*r01*x1834*x1837))+(((-1.0)*r00*x1835*x1837))+(((-1.0)*npy*x1834))+((r11*x1834*x1836))+(((-1.0)*npx*x1835))+((r10*x1835*x1836)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
r02=0;
npz=(((py*r12))+((pz*r22)));
rxp2_1=(px*r22);
rxp2_2=((-1.0)*px*r12);
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
IkReal x1838=((0.0775)*sj0);
IkReal x1839=((0.0775)*cj0);
j5eval[0]=((IKabs((((r01*x1838))+npy+(((-1.0)*r11*x1839)))))+(IKabs((((r10*x1839))+(((-1.0)*r00*x1838))+(((-1.0)*npx))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
{
IkReal j5eval[1];
r02=0;
npz=(((py*r12))+((pz*r22)));
rxp2_1=(px*r22);
rxp2_2=((-1.0)*px*r12);
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
IkReal x1840=((0.0775)*sj0);
IkReal x1841=((0.0775)*cj0);
j5eval[0]=((IKabs(((((-1.0)*r00*x1840))+(((-1.0)*npx))+((r10*x1841)))))+(IKabs(((((-1.0)*npy))+(((-1.0)*r01*x1840))+((r11*x1841))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j5]

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1842=((0.0775)*sj0);
IkReal x1843=((0.0775)*cj0);
CheckValue<IkReal> x1845 = IKatan2WithCheck(IkReal(((((-1.0)*npy))+(((-1.0)*r01*x1842))+((r11*x1843)))),IkReal(((((-1.0)*r00*x1842))+(((-1.0)*npx))+((r10*x1843)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1845.valid){
continue;
}
IkReal x1844=x1845.value;
j5array[0]=((-1.0)*x1844);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1844)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1846=IKsin(j5);
IkReal x1847=IKcos(j5);
IkReal x1848=((0.0775)*sj0);
IkReal x1849=((0.0775)*cj0);
evalcond[0]=(((r10*x1847*x1849))+((npy*x1846))+(((-1.0)*npx*x1847))+(((-1.0)*r11*x1846*x1849))+((r01*x1846*x1848))+(((-1.0)*r00*x1847*x1848)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x1850=((0.0775)*sj0);
IkReal x1851=((0.0775)*cj0);
CheckValue<IkReal> x1853 = IKatan2WithCheck(IkReal((((r10*x1851))+(((-1.0)*npx))+(((-1.0)*r00*x1850)))),IkReal((((r01*x1850))+npy+(((-1.0)*r11*x1851)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1853.valid){
continue;
}
IkReal x1852=x1853.value;
j5array[0]=((-1.0)*x1852);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1852)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1854=IKcos(j5);
IkReal x1855=IKsin(j5);
IkReal x1856=((0.0775)*cj0);
IkReal x1857=((0.0775)*sj0);
evalcond[0]=((((-1.0)*npy*x1854))+(((-1.0)*npx*x1855))+(((-1.0)*r00*x1855*x1857))+((r11*x1854*x1856))+(((-1.0)*r01*x1854*x1857))+((r10*x1855*x1856)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(r12);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[3];
r02=0;
npz=(pz*r22);
rxp2_1=(px*r22);
rxp2_2=0;
r12=0;
rxp2_0=((-1.0)*py*r22);
IkReal x1858=(r22*sj4);
IkReal x1859=((31.0)*sj0);
IkReal x1860=((31.0)*cj0);
j5eval[0]=x1858;
j5eval[1]=IKsign(x1858);
j5eval[2]=((IKabs(((((-1.0)*r11*x1859))+(((-1.0)*r01*x1860))+(((400.0)*rxp1_2)))))+(IKabs(((((400.0)*rxp0_2))+(((-1.0)*r00*x1860))+(((-1.0)*r10*x1859))))));
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
r02=0;
npz=(pz*r22);
rxp2_1=(px*r22);
rxp2_2=0;
r12=0;
rxp2_0=((-1.0)*py*r22);
sj4=0;
cj4=1.0;
j4=0;
j5eval[0]=((IKabs((pz*r20)))+(IKabs((pz*r21))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
CheckValue<IkReal> x1862 = IKatan2WithCheck(IkReal((((px*r01))+(((-1.0)*npy))+((py*r11)))),IkReal((((px*r00))+(((-1.0)*npx))+((py*r10)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1862.valid){
continue;
}
IkReal x1861=x1862.value;
j5array[0]=((-1.0)*x1861);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1861)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1863=IKcos(j5);
IkReal x1864=IKsin(j5);
IkReal x1865=((1.0)*x1864);
evalcond[0]=(((py*r10*x1863))+(((-1.0)*px*r01*x1865))+(((-1.0)*py*r11*x1865))+(((-1.0)*npx*x1863))+((px*r00*x1863))+((npy*x1864)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j5eval[1];
r02=0;
npz=(pz*r22);
rxp2_1=(px*r22);
rxp2_2=0;
r12=0;
rxp2_0=((-1.0)*py*r22);
sj4=0;
cj4=-1.0;
j4=3.14159265358979;
j5eval[0]=((IKabs((pz*r20)))+(IKabs((pz*r21))));
if( IKabs(j5eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
CheckValue<IkReal> x1867 = IKatan2WithCheck(IkReal((((px*r01))+(((-1.0)*npy))+((py*r11)))),IkReal((((px*r00))+(((-1.0)*npx))+((py*r10)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1867.valid){
continue;
}
IkReal x1866=x1867.value;
j5array[0]=((-1.0)*x1866);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=((3.14159265358979)+(((-1.0)*x1866)));
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
if( j5array[1] > IKPI )
{
    j5array[1]-=IK2PI;
}
else if( j5array[1] < -IKPI )
{    j5array[1]+=IK2PI;
}
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[1];
IkReal x1868=IKcos(j5);
IkReal x1869=IKsin(j5);
IkReal x1870=((1.0)*x1869);
evalcond[0]=(((py*r10*x1868))+(((-1.0)*py*r11*x1870))+(((-1.0)*npx*x1868))+((px*r00*x1868))+((npy*x1869))+(((-1.0)*px*r01*x1870)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1871=((31.0)*cj0);
IkReal x1872=((31.0)*sj0);
CheckValue<IkReal> x1873=IKPowWithIntegerCheck(IKsign((r22*sj4)),-1);
if(!x1873.valid){
continue;
}
CheckValue<IkReal> x1874 = IKatan2WithCheck(IkReal(((((-1.0)*r10*x1872))+(((-1.0)*r00*x1871))+(((400.0)*rxp0_2)))),IkReal(((((-1.0)*r01*x1871))+(((-1.0)*r11*x1872))+(((400.0)*rxp1_2)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1874.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1873.value)))+(x1874.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1875=IKsin(j5);
IkReal x1876=IKcos(j5);
IkReal x1877=((0.0775)*cj0);
IkReal x1878=((0.1075)*sj4);
IkReal x1879=((0.215)*sj4);
IkReal x1880=((0.0775)*sj0);
IkReal x1881=(cj4*r22);
IkReal x1882=((1.0)*npx);
IkReal x1883=(r10*x1876);
IkReal x1884=(npy*x1875);
IkReal x1885=(r01*x1875);
IkReal x1886=(r00*x1876);
IkReal x1887=(r11*x1875);
evalcond[0]=(((x1878*x1885))+(((-1.0)*x1878*x1886))+(((-1.0)*px))+(((-1.0)*x1880)));
evalcond[1]=(((x1878*x1887))+(((-1.0)*x1878*x1883))+(((-1.0)*py))+x1877);
evalcond[2]=((((-1.0)*r20*x1876*x1878))+(((0.1075)*x1881))+((r21*x1875*x1878))+(((-1.0)*pz)));
evalcond[3]=((-0.00555)+((x1879*x1884))+(((-1.0)*npx*x1876*x1879))+(((-1.0)*pp))+(((0.215)*pz*x1881)));
evalcond[4]=((((-1.0)*x1875*x1882))+(((-1.0)*r01*x1876*x1880))+((r11*x1876*x1877))+(((-1.0)*r00*x1875*x1880))+(((-1.0)*npy*x1876))+((r10*x1875*x1877)));
evalcond[5]=(((x1877*x1883))+(((-1.0)*x1876*x1882))+(((-1.0)*x1880*x1886))+(((-1.0)*x1878))+((x1880*x1885))+x1884+(((-1.0)*x1877*x1887)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1888=((31.0)*sj0);
IkReal x1889=((31.0)*cj0);
IkReal x1890=((43.0)*cj4*r12);
CheckValue<IkReal> x1891=IKPowWithIntegerCheck(IKsign((r22*sj4)),-1);
if(!x1891.valid){
continue;
}
CheckValue<IkReal> x1892 = IKatan2WithCheck(IkReal(((((400.0)*rxp0_2))+(((-1.0)*r10*x1888))+(((-1.0)*r00*x1890))+(((-1.0)*r00*x1889)))),IkReal(((((-1.0)*r11*x1888))+(((-1.0)*r01*x1890))+(((-1.0)*r01*x1889))+(((400.0)*rxp1_2)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1892.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1891.value)))+(x1892.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1893=IKsin(j5);
IkReal x1894=IKcos(j5);
IkReal x1895=((0.215)*cj4);
IkReal x1896=((0.0775)*cj0);
IkReal x1897=((0.1075)*sj4);
IkReal x1898=((0.215)*sj4);
IkReal x1899=((0.0775)*sj0);
IkReal x1900=((1.0)*npx);
IkReal x1901=((0.1075)*cj4);
IkReal x1902=(r10*x1894);
IkReal x1903=(npy*x1893);
IkReal x1904=(r01*x1893);
IkReal x1905=(r00*x1894);
IkReal x1906=(r11*x1893);
evalcond[0]=((((-1.0)*px))+(((-1.0)*x1899))+(((-1.0)*x1897*x1905))+((x1897*x1904)));
evalcond[1]=((((-1.0)*r20*x1894*x1897))+((r21*x1893*x1897))+(((-1.0)*pz))+((r22*x1901)));
evalcond[2]=(((r12*x1901))+(((-1.0)*py))+x1896+(((-1.0)*x1897*x1902))+((x1897*x1906)));
evalcond[3]=((-0.00555)+((x1898*x1903))+((py*r12*x1895))+(((-1.0)*pp))+((pz*r22*x1895))+(((-1.0)*npx*x1894*x1898)));
evalcond[4]=(((r11*x1894*x1896))+(((-1.0)*r01*x1894*x1899))+(((-1.0)*x1893*x1900))+(((-1.0)*r00*x1893*x1899))+((r10*x1893*x1896))+(((-1.0)*npy*x1894)));
evalcond[5]=((((-1.0)*x1899*x1905))+(((-1.0)*x1894*x1900))+x1903+((x1899*x1904))+(((-1.0)*x1896*x1906))+(((-1.0)*x1897))+((x1896*x1902)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1907=((31.0)*sj0);
IkReal x1908=((43.0)*cj4*r22);
CheckValue<IkReal> x1909 = IKatan2WithCheck(IkReal(((((-400.0)*rxp0_1))+(((-1.0)*r20*x1907))+(((-1.0)*r00*x1908)))),IkReal(((((-400.0)*rxp1_1))+(((-1.0)*r21*x1907))+(((-1.0)*r01*x1908)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1909.valid){
continue;
}
CheckValue<IkReal> x1910=IKPowWithIntegerCheck(IKsign((r12*sj4)),-1);
if(!x1910.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(x1909.value)+(((-1.5707963267949)*(x1910.value))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1911=IKsin(j5);
IkReal x1912=IKcos(j5);
IkReal x1913=((0.215)*cj4);
IkReal x1914=((0.0775)*cj0);
IkReal x1915=((0.1075)*sj4);
IkReal x1916=((0.215)*sj4);
IkReal x1917=((0.0775)*sj0);
IkReal x1918=((1.0)*npx);
IkReal x1919=((0.1075)*cj4);
IkReal x1920=(r10*x1912);
IkReal x1921=(npy*x1911);
IkReal x1922=(r01*x1911);
IkReal x1923=(r00*x1912);
IkReal x1924=(r11*x1911);
evalcond[0]=((((-1.0)*x1915*x1923))+(((-1.0)*px))+((x1915*x1922))+(((-1.0)*x1917)));
evalcond[1]=(((r22*x1919))+(((-1.0)*r20*x1912*x1915))+(((-1.0)*pz))+((r21*x1911*x1915)));
evalcond[2]=((((-1.0)*x1915*x1920))+(((-1.0)*py))+x1914+((r12*x1919))+((x1915*x1924)));
evalcond[3]=((-0.00555)+((pz*r22*x1913))+(((-1.0)*pp))+((py*r12*x1913))+((x1916*x1921))+(((-1.0)*npx*x1912*x1916)));
evalcond[4]=((((-1.0)*x1911*x1918))+(((-1.0)*r01*x1912*x1917))+(((-1.0)*r00*x1911*x1917))+(((-1.0)*npy*x1912))+((r11*x1912*x1914))+((r10*x1911*x1914)));
evalcond[5]=((((-1.0)*x1917*x1923))+(((-1.0)*x1914*x1924))+x1921+((x1917*x1922))+((x1914*x1920))+(((-1.0)*x1912*x1918))+(((-1.0)*x1915)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1925=((200.0)*pp);
IkReal x1926=((43.0)*npy);
IkReal x1927=(cj4*r22);
IkReal x1928=((400.0)*pz);
IkReal x1929=((43.0)*npx);
IkReal x1930=((43.0)*cj4*npz);
CheckValue<IkReal> x1931 = IKatan2WithCheck(IkReal(((((-1.0)*npx*x1928))+((x1927*x1929))+((r20*x1925))+(((-1.0)*r20*x1930))+(((1.11)*r20)))),IkReal(((((-1.0)*npy*x1928))+(((-1.0)*r21*x1930))+(((1.11)*r21))+((r21*x1925))+((x1926*x1927)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1931.valid){
continue;
}
CheckValue<IkReal> x1932=IKPowWithIntegerCheck(IKsign(((((-1.0)*r21*sj4*x1929))+((r20*sj4*x1926)))),-1);
if(!x1932.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(x1931.value)+(((1.5707963267949)*(x1932.value))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1933=IKsin(j5);
IkReal x1934=IKcos(j5);
IkReal x1935=((0.0775)*cj0);
IkReal x1936=((0.1075)*sj4);
IkReal x1937=((0.215)*sj4);
IkReal x1938=((0.0775)*sj0);
IkReal x1939=((1.0)*npx);
IkReal x1940=((0.1075)*cj4);
IkReal x1941=(r10*x1934);
IkReal x1942=(npy*x1933);
IkReal x1943=(r01*x1933);
IkReal x1944=(r00*x1934);
IkReal x1945=(r11*x1933);
evalcond[0]=((((-1.0)*r20*x1934*x1936))+((r22*x1940))+(((-1.0)*pz))+((r21*x1933*x1936)));
evalcond[1]=((-0.00555)+(((0.215)*cj4*npz))+((x1937*x1942))+(((-1.0)*pp))+(((-1.0)*npx*x1934*x1937)));
evalcond[2]=(((x1936*x1943))+(((-1.0)*px))+(((-1.0)*x1936*x1944))+((r02*x1940))+(((-1.0)*x1938)));
evalcond[3]=(((r12*x1940))+((x1936*x1945))+(((-1.0)*py))+x1935+(((-1.0)*x1936*x1941)));
evalcond[4]=(((r11*x1934*x1935))+(((-1.0)*r01*x1934*x1938))+(((-1.0)*x1933*x1939))+(((-1.0)*npy*x1934))+(((-1.0)*r00*x1933*x1938))+((r10*x1933*x1935)));
evalcond[5]=(((x1938*x1943))+(((-1.0)*x1934*x1939))+((x1935*x1941))+(((-1.0)*x1935*x1945))+x1942+(((-1.0)*x1938*x1944))+(((-1.0)*x1936)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1946=((43.0)*cj4);
IkReal x1947=((31.0)*sj0);
CheckValue<IkReal> x1948=IKPowWithIntegerCheck(IKsign((r12*sj4)),-1);
if(!x1948.valid){
continue;
}
CheckValue<IkReal> x1949 = IKatan2WithCheck(IkReal(((((-400.0)*rxp0_1))+(((-1.0)*r11*x1946))+(((-1.0)*r20*x1947)))),IkReal(((((-1.0)*r21*x1947))+(((-400.0)*rxp1_1))+((r10*x1946)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1949.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((-1.5707963267949)*(x1948.value)))+(x1949.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1950=IKsin(j5);
IkReal x1951=IKcos(j5);
IkReal x1952=((0.0775)*cj0);
IkReal x1953=((0.1075)*sj4);
IkReal x1954=((0.215)*sj4);
IkReal x1955=((0.0775)*sj0);
IkReal x1956=((1.0)*npx);
IkReal x1957=((0.1075)*cj4);
IkReal x1958=(r10*x1951);
IkReal x1959=(npy*x1950);
IkReal x1960=(r01*x1950);
IkReal x1961=(r00*x1951);
IkReal x1962=(r11*x1950);
evalcond[0]=((((-1.0)*r20*x1951*x1953))+(((-1.0)*pz))+((r22*x1957))+((r21*x1950*x1953)));
evalcond[1]=((-0.00555)+(((0.215)*cj4*npz))+((x1954*x1959))+(((-1.0)*pp))+(((-1.0)*npx*x1951*x1954)));
evalcond[2]=((((-1.0)*x1955))+(((-1.0)*px))+(((-1.0)*x1953*x1961))+((x1953*x1960))+((r02*x1957)));
evalcond[3]=(((r12*x1957))+(((-1.0)*py))+x1952+(((-1.0)*x1953*x1958))+((x1953*x1962)));
evalcond[4]=((((-1.0)*r00*x1950*x1955))+((r11*x1951*x1952))+(((-1.0)*x1950*x1956))+(((-1.0)*r01*x1951*x1955))+(((-1.0)*npy*x1951))+((r10*x1950*x1952)));
evalcond[5]=((((-1.0)*x1952*x1962))+(((-1.0)*x1953))+((x1952*x1958))+(((-1.0)*x1951*x1956))+((x1955*x1960))+x1959+(((-1.0)*x1955*x1961)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x1963=((31.0)*cj0);
IkReal x1964=((43.0)*cj4);
CheckValue<IkReal> x1965=IKPowWithIntegerCheck(IKsign((r02*sj4)),-1);
if(!x1965.valid){
continue;
}
CheckValue<IkReal> x1966 = IKatan2WithCheck(IkReal((((r20*x1963))+(((400.0)*rxp0_0))+((r01*x1964)))),IkReal((((r21*x1963))+(((-1.0)*r00*x1964))+(((400.0)*rxp1_0)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1966.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1965.value)))+(x1966.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[6];
IkReal x1967=IKsin(j5);
IkReal x1968=IKcos(j5);
IkReal x1969=((0.0775)*cj0);
IkReal x1970=((0.1075)*sj4);
IkReal x1971=((0.215)*sj4);
IkReal x1972=((0.0775)*sj0);
IkReal x1973=((1.0)*npx);
IkReal x1974=((0.1075)*cj4);
IkReal x1975=(r10*x1968);
IkReal x1976=(npy*x1967);
IkReal x1977=(r01*x1967);
IkReal x1978=(r00*x1968);
IkReal x1979=(r11*x1967);
evalcond[0]=(((r21*x1967*x1970))+(((-1.0)*r20*x1968*x1970))+(((-1.0)*pz))+((r22*x1974)));
evalcond[1]=((-0.00555)+(((0.215)*cj4*npz))+((x1971*x1976))+(((-1.0)*pp))+(((-1.0)*npx*x1968*x1971)));
evalcond[2]=(((r02*x1974))+((x1970*x1977))+(((-1.0)*x1972))+(((-1.0)*px))+(((-1.0)*x1970*x1978)));
evalcond[3]=(((r12*x1974))+((x1970*x1979))+(((-1.0)*py))+(((-1.0)*x1970*x1975))+x1969);
evalcond[4]=((((-1.0)*npy*x1968))+((r11*x1968*x1969))+((r10*x1967*x1969))+(((-1.0)*r01*x1968*x1972))+(((-1.0)*x1967*x1973))+(((-1.0)*r00*x1967*x1972)));
evalcond[5]=(((x1969*x1975))+((x1972*x1977))+(((-1.0)*x1970))+(((-1.0)*x1968*x1973))+(((-1.0)*x1972*x1978))+x1976+(((-1.0)*x1969*x1979)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}
}
}

}

}
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x176=((1.0)*sj4);
IkReal x177=((1.0)*cj4);
IkReal x178=((1.0)*sj5);
IkReal x179=((1.0)*sj0);
IkReal x180=((1.0)*cj5);
IkReal x181=(((r11*sj0))+((cj0*r01)));
IkReal x182=(((r10*sj0))+((cj0*r00)));
IkReal x183=(((r12*sj0))+((cj0*r02)));
IkReal x184=(((cj5*r20))+(((-1.0)*r21*x178)));
IkReal x185=((((-1.0)*r00*x179))+((cj0*r10)));
IkReal x186=((((-1.0)*r01*x179))+((cj0*r11)));
IkReal x187=((((-1.0)*r02*x179))+((cj0*r12)));
IkReal x188=((1.0)*x187);
IkReal x189=((((-1.0)*x180*x182))+((sj5*x181)));
IkReal x190=((((-1.0)*x180*x185))+((sj5*x186)));
new_r00=((((-1.0)*x176*x183))+((cj4*x189)));
new_r01=(((cj5*x181))+((sj5*x182)));
new_r02=((((-1.0)*x176*x189))+(((-1.0)*x177*x183)));
new_r10=(((r22*sj4))+((cj4*x184)));
new_r11=((((-1.0)*r20*x178))+(((-1.0)*r21*x180)));
new_r12=(((cj4*r22))+(((-1.0)*x176*x184)));
new_r20=(((cj4*x190))+(((-1.0)*x176*x187)));
new_r21=(((cj5*x186))+((sj5*x185)));
new_r22=((((-1.0)*x177*x187))+(((-1.0)*x176*x190)));
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
sj2array[0]=((-1.0)*new_r22);
if( sj2array[0] >= -1-IKFAST_SINCOS_THRESH && sj2array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j2valid[0] = j2valid[1] = true;
    j2array[0] = IKasin(sj2array[0]);
    cj2array[0] = IKcos(j2array[0]);
    sj2array[1] = sj2array[0];
    j2array[1] = j2array[0] > 0 ? (IKPI-j2array[0]) : (-IKPI-j2array[0]);
    cj2array[1] = -cj2array[0];
}
else if( isnan(sj2array[0]) )
{
    // probably any value will work
    j2valid[0] = true;
    cj2array[0] = 1; sj2array[0] = 0; j2array[0] = 0;
}
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

{
IkReal j3eval[3];
j3eval[0]=cj2;
j3eval[1]=IKsign(cj2);
j3eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
j1eval[0]=cj2;
j1eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j1eval[2]=IKsign(cj2);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
j1eval[0]=cj2;
j1eval[1]=new_r02;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j3mul = 1;
j3=0;
j1mul=1.0;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1=IKatan2(new_r01, ((-1.0)*new_r11));
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].fmul = j1mul;
vinfos[1].freeind = 0;
vinfos[1].maxsolutions = 0;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].fmul = j3mul;
vinfos[3].freeind = 0;
vinfos[3].maxsolutions = 0;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(1);
vfree[0] = 3;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j3mul = 1;
j3=0;
j1mul=-1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1=IKatan2(((-1.0)*new_r01), new_r11);
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].fmul = j1mul;
vinfos[1].freeind = 0;
vinfos[1].maxsolutions = 0;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].fmul = j3mul;
vinfos[3].freeind = 0;
vinfos[3].maxsolutions = 0;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(1);
vfree[0] = 3;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
IkReal x191=new_r22*new_r22;
IkReal x192=((16.0)*new_r10);
IkReal x193=((16.0)*new_r01);
IkReal x194=((16.0)*new_r00);
IkReal x195=(new_r11*new_r22);
IkReal x196=((8.0)*new_r00);
IkReal x197=(x191*x192);
IkReal x198=(x191*x193);
j1eval[0]=((IKabs(((((32.0)*new_r00))+(((-1.0)*x191*x194))+(((-16.0)*x195)))))+(IKabs(((((-1.0)*x197))+x192)))+(IKabs(((((-1.0)*x193))+x198)))+(IKabs(((((-1.0)*x192))+x197)))+(IKabs(((((-8.0)*x195))+((x191*x196)))))+(IKabs((((new_r22*x196))+(((-8.0)*new_r11)))))+(IKabs(((((-1.0)*x198))+x193)))+(IKabs(((((-32.0)*new_r11*x191))+((new_r22*x194))+(((16.0)*new_r11))))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j3]

} else
{
IkReal op[4+1], zeror[4];
int numroots;
IkReal j1evalpoly[1];
IkReal x199=new_r22*new_r22;
IkReal x200=((16.0)*new_r01);
IkReal x201=(new_r00*new_r22);
IkReal x202=(x199*x200);
IkReal x203=((((8.0)*x201))+(((-8.0)*new_r11)));
op[0]=x203;
op[1]=((((-1.0)*x200))+x202);
op[2]=((((-32.0)*new_r11*x199))+(((16.0)*x201))+(((16.0)*new_r11)));
op[3]=((((-1.0)*x202))+x200);
op[4]=x203;
polyroots4(op,zeror,numroots);
IkReal j1array[4], cj1array[4], sj1array[4], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[4]={true,true,true,true};
_nj1 = 4;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x204=new_r22*new_r22;
IkReal x205=((16.0)*new_r10);
IkReal x206=(new_r11*new_r22);
IkReal x207=((8.0)*x206);
IkReal x208=(new_r00*x204);
IkReal x209=((8.0)*x208);
IkReal x210=(x204*x205);
j1evalpoly[0]=((((htj1*htj1*htj1)*((x205+(((-1.0)*x210))))))+(((htj1*htj1)*(((((32.0)*new_r00))+(((-16.0)*x206))+(((-16.0)*x208))))))+(((htj1*htj1*htj1*htj1)*(((((-1.0)*x207))+x209))))+(((-1.0)*x207))+x209+((htj1*(((((-1.0)*x205))+x210)))));
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j3eval[3];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
IkReal x211=new_r22*new_r22;
IkReal x212=cj1*cj1;
IkReal x213=(new_r22*sj1);
IkReal x214=(((x211*x212))+(((-1.0)*x211))+(((-1.0)*x212)));
j3eval[0]=x214;
j3eval[1]=((IKabs((((cj1*new_r01))+((new_r00*x213)))))+(IKabs((((new_r01*x213))+(((-1.0)*cj1*new_r00))))));
j3eval[2]=IKsign(x214);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j3eval[0]=new_r22;
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j3eval[0]=cj1;
j3eval[1]=new_r22;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-1.0)*new_r11), new_r10);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x215=IKsin(j3);
IkReal x216=IKcos(j3);
IkReal x217=((1.0)*new_r22);
IkReal x218=((1.0)*x216);
IkReal x219=((1.0)*x215);
evalcond[0]=(x215+new_r11);
evalcond[1]=(new_r10+(((-1.0)*x218)));
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x215*x217)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x216*x217)));
evalcond[4]=((((-1.0)*x219))+(((-1.0)*new_r00*x217)));
evalcond[5]=((((-1.0)*new_r01*x217))+(((-1.0)*x218)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(new_r11, ((-1.0)*new_r10));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x220=IKsin(j3);
IkReal x221=IKcos(j3);
IkReal x222=((1.0)*x221);
IkReal x223=((1.0)*x220);
evalcond[0]=(x220+(((-1.0)*new_r11)));
evalcond[1]=((((-1.0)*new_r22*x223))+new_r00);
evalcond[2]=((((-1.0)*new_r22*x222))+new_r01);
evalcond[3]=((((-1.0)*new_r10))+(((-1.0)*x222)));
evalcond[4]=(((new_r00*new_r22))+(((-1.0)*x223)));
evalcond[5]=(((new_r01*new_r22))+(((-1.0)*x222)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x224=new_r22*new_r22;
CheckValue<IkReal> x225=IKPowWithIntegerCheck(((-1.0)+x224),-1);
if(!x225.valid){
continue;
}
if(((x224*(x225.value))) < -0.00001)
continue;
IkReal gconst88=IKsqrt((x224*(x225.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj1+(((-1.0)*gconst88)))))+(IKabs(((-1.0)+(IKsign(sj1)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if((((1.0)+(((-1.0)*(gconst88*gconst88))))) < -0.00001)
continue;
IkReal x226=IKsqrt(((1.0)+(((-1.0)*(gconst88*gconst88)))));
if( IKabs(((((-1.0)*new_r11*x226))+(((-1.0)*gconst88*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((gconst88*new_r00))+((new_r10*x226)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r11*x226))+(((-1.0)*gconst88*new_r01))))+IKsqr((((gconst88*new_r00))+((new_r10*x226))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*new_r11*x226))+(((-1.0)*gconst88*new_r01))), (((gconst88*new_r00))+((new_r10*x226))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[10];
IkReal x227=IKcos(j3);
IkReal x228=IKsin(j3);
IkReal x229=(gconst88*new_r11);
IkReal x230=(gconst88*new_r10);
IkReal x231=(gconst88*new_r22);
IkReal x232=((1.0)*new_r00);
IkReal x233=((1.0)*new_r01);
IkReal x234=((1.0)*x227);
IkReal x235=((1.0)*x228);
IkReal x236=x226;
IkReal x237=(new_r22*x236);
IkReal x238=(x228*x236);
evalcond[0]=(((gconst88*new_r01))+((new_r11*x236))+x228);
evalcond[1]=(((new_r10*x236))+((gconst88*new_r00))+(((-1.0)*x234)));
evalcond[2]=(((gconst88*x228))+((x227*x237))+new_r01);
evalcond[3]=(x238+(((-1.0)*x231*x234))+new_r11);
evalcond[4]=((((-1.0)*new_r22*x235))+x230+(((-1.0)*x232*x236)));
evalcond[5]=((((-1.0)*x233*x236))+(((-1.0)*new_r22*x234))+x229);
evalcond[6]=(((x228*x237))+new_r00+(((-1.0)*gconst88*x234)));
evalcond[7]=((((-1.0)*x231*x235))+new_r10+(((-1.0)*x234*x236)));
evalcond[8]=(((new_r22*x230))+(((-1.0)*x235))+(((-1.0)*x232*x237)));
evalcond[9]=((((-1.0)*x233*x237))+(((-1.0)*x234))+((new_r22*x229)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x239=new_r22*new_r22;
CheckValue<IkReal> x240=IKPowWithIntegerCheck(((-1.0)+x239),-1);
if(!x240.valid){
continue;
}
if(((x239*(x240.value))) < -0.00001)
continue;
IkReal gconst88=IKsqrt((x239*(x240.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj1+(((-1.0)*gconst88)))))+(IKabs(((1.0)+(IKsign(sj1)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if((((1.0)+(((-1.0)*(gconst88*gconst88))))) < -0.00001)
continue;
IkReal x241=IKsqrt(((1.0)+(((-1.0)*(gconst88*gconst88)))));
if( IKabs(((((-1.0)*gconst88*new_r01))+((new_r11*x241)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((gconst88*new_r00))+(((-1.0)*new_r10*x241)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*gconst88*new_r01))+((new_r11*x241))))+IKsqr((((gconst88*new_r00))+(((-1.0)*new_r10*x241))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*gconst88*new_r01))+((new_r11*x241))), (((gconst88*new_r00))+(((-1.0)*new_r10*x241))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[10];
IkReal x242=IKsin(j3);
IkReal x243=IKcos(j3);
IkReal x244=(gconst88*new_r11);
IkReal x245=(gconst88*new_r10);
IkReal x246=((1.0)*new_r22);
IkReal x247=((1.0)*x243);
IkReal x248=(gconst88*x242);
IkReal x249=((1.0)*x242);
IkReal x250=x241;
IkReal x251=(new_r22*x250);
IkReal x252=((1.0)*x250);
evalcond[0]=(((gconst88*new_r01))+(((-1.0)*new_r11*x252))+x242);
evalcond[1]=((((-1.0)*new_r10*x252))+((gconst88*new_r00))+(((-1.0)*x247)));
evalcond[2]=((((-1.0)*x242*x246))+((new_r00*x250))+x245);
evalcond[3]=(((new_r01*x250))+(((-1.0)*x243*x246))+x244);
evalcond[4]=(x248+new_r01+(((-1.0)*x243*x246*x250)));
evalcond[5]=(((x243*x250))+new_r10+(((-1.0)*x246*x248)));
evalcond[6]=(((new_r00*x251))+((new_r22*x245))+(((-1.0)*x249)));
evalcond[7]=(((new_r01*x251))+((new_r22*x244))+(((-1.0)*x247)));
evalcond[8]=((((-1.0)*x249*x250))+(((-1.0)*gconst88*x243*x246))+new_r11);
evalcond[9]=((((-1.0)*gconst88*x247))+(((-1.0)*x242*x246*x250))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x253=new_r22*new_r22;
CheckValue<IkReal> x254=IKPowWithIntegerCheck(((-1.0)+x253),-1);
if(!x254.valid){
continue;
}
if(((x253*(x254.value))) < -0.00001)
continue;
IkReal gconst89=((-1.0)*(IKsqrt((x253*(x254.value)))));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.0)+(IKsign(sj1)))))+(IKabs((cj1+(((-1.0)*gconst89)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if((((1.0)+(((-1.0)*(gconst89*gconst89))))) < -0.00001)
continue;
IkReal x255=IKsqrt(((1.0)+(((-1.0)*(gconst89*gconst89)))));
if( IKabs(((((-1.0)*new_r11*x255))+(((-1.0)*gconst89*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r10*x255))+((gconst89*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r11*x255))+(((-1.0)*gconst89*new_r01))))+IKsqr((((new_r10*x255))+((gconst89*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*new_r11*x255))+(((-1.0)*gconst89*new_r01))), (((new_r10*x255))+((gconst89*new_r00))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[10];
IkReal x256=IKsin(j3);
IkReal x257=IKcos(j3);
IkReal x258=(gconst89*new_r10);
IkReal x259=(gconst89*new_r22);
IkReal x260=((1.0)*new_r01);
IkReal x261=((1.0)*new_r00);
IkReal x262=((1.0)*x257);
IkReal x263=((1.0)*x256);
IkReal x264=x255;
IkReal x265=(new_r22*x264);
evalcond[0]=(x256+((gconst89*new_r01))+((new_r11*x264)));
evalcond[1]=(((gconst89*new_r00))+(((-1.0)*x262))+((new_r10*x264)));
evalcond[2]=(((x257*x265))+new_r01+((gconst89*x256)));
evalcond[3]=((((-1.0)*x259*x262))+((x256*x264))+new_r11);
evalcond[4]=((((-1.0)*new_r22*x263))+x258+(((-1.0)*x261*x264)));
evalcond[5]=((((-1.0)*new_r22*x262))+((gconst89*new_r11))+(((-1.0)*x260*x264)));
evalcond[6]=(((x256*x265))+(((-1.0)*gconst89*x262))+new_r00);
evalcond[7]=((((-1.0)*x262*x264))+(((-1.0)*x259*x263))+new_r10);
evalcond[8]=((((-1.0)*x261*x265))+((new_r22*x258))+(((-1.0)*x263)));
evalcond[9]=(((new_r11*x259))+(((-1.0)*x262))+(((-1.0)*x260*x265)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x266=new_r22*new_r22;
CheckValue<IkReal> x267=IKPowWithIntegerCheck(((-1.0)+x266),-1);
if(!x267.valid){
continue;
}
if(((x266*(x267.value))) < -0.00001)
continue;
IkReal gconst89=((-1.0)*(IKsqrt((x266*(x267.value)))));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.0)+(IKsign(sj1)))))+(IKabs((cj1+(((-1.0)*gconst89)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if((((1.0)+(((-1.0)*(gconst89*gconst89))))) < -0.00001)
continue;
IkReal x268=IKsqrt(((1.0)+(((-1.0)*(gconst89*gconst89)))));
if( IKabs(((((-1.0)*gconst89*new_r01))+((new_r11*x268)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r10*x268))+((gconst89*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*gconst89*new_r01))+((new_r11*x268))))+IKsqr(((((-1.0)*new_r10*x268))+((gconst89*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*gconst89*new_r01))+((new_r11*x268))), ((((-1.0)*new_r10*x268))+((gconst89*new_r00))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[10];
IkReal x269=IKsin(j3);
IkReal x270=IKcos(j3);
IkReal x271=(gconst89*new_r10);
IkReal x272=(gconst89*new_r22);
IkReal x273=((1.0)*x270);
IkReal x274=((1.0)*x269);
IkReal x275=x268;
IkReal x276=(new_r00*x275);
IkReal x277=((1.0)*x275);
IkReal x278=(new_r01*x275);
evalcond[0]=(x269+(((-1.0)*new_r11*x277))+((gconst89*new_r01)));
evalcond[1]=((((-1.0)*new_r10*x277))+(((-1.0)*x273))+((gconst89*new_r00)));
evalcond[2]=((((-1.0)*new_r22*x274))+x276+x271);
evalcond[3]=((((-1.0)*new_r22*x273))+x278+((gconst89*new_r11)));
evalcond[4]=(((gconst89*x269))+(((-1.0)*new_r22*x273*x275))+new_r01);
evalcond[5]=((((-1.0)*x272*x274))+((x270*x275))+new_r10);
evalcond[6]=(((new_r22*x271))+((new_r22*x276))+(((-1.0)*x274)));
evalcond[7]=(((new_r22*x278))+(((-1.0)*x273))+((new_r11*x272)));
evalcond[8]=((((-1.0)*x272*x273))+(((-1.0)*x274*x275))+new_r11);
evalcond[9]=((((-1.0)*gconst89*x273))+new_r00+(((-1.0)*new_r22*x274*x275)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x279=((1.0)*cj1*new_r01);
CheckValue<IkReal> x280=IKPowWithIntegerCheck(cj1,-1);
if(!x280.valid){
continue;
}
CheckValue<IkReal> x281=IKPowWithIntegerCheck(new_r22,-1);
if(!x281.valid){
continue;
}
if( IKabs(((((-1.0)*x279))+(((-1.0)*new_r11*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x280.value)*(x281.value)*(((((-1.0)*sj1*x279))+((new_r11*(cj1*cj1))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x279))+(((-1.0)*new_r11*sj1))))+IKsqr(((x280.value)*(x281.value)*(((((-1.0)*sj1*x279))+((new_r11*(cj1*cj1)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*x279))+(((-1.0)*new_r11*sj1))), ((x280.value)*(x281.value)*(((((-1.0)*sj1*x279))+((new_r11*(cj1*cj1)))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[10];
IkReal x282=IKcos(j3);
IkReal x283=IKsin(j3);
IkReal x284=(cj1*new_r22);
IkReal x285=(new_r22*sj1);
IkReal x286=((1.0)*new_r00);
IkReal x287=((1.0)*new_r01);
IkReal x288=((1.0)*x282);
IkReal x289=(cj1*x283);
IkReal x290=((1.0)*x283);
evalcond[0]=(((new_r11*sj1))+((cj1*new_r01))+x283);
evalcond[1]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x288)));
evalcond[2]=(x289+new_r01+((x282*x285)));
evalcond[3]=((((-1.0)*x284*x288))+new_r11+((sj1*x283)));
evalcond[4]=((((-1.0)*sj1*x286))+((cj1*new_r10))+(((-1.0)*new_r22*x290)));
evalcond[5]=((((-1.0)*sj1*x287))+(((-1.0)*new_r22*x288))+((cj1*new_r11)));
evalcond[6]=((((-1.0)*cj1*x288))+new_r00+((x283*x285)));
evalcond[7]=((((-1.0)*x284*x290))+(((-1.0)*sj1*x288))+new_r10);
evalcond[8]=((((-1.0)*x290))+(((-1.0)*x285*x286))+((new_r10*x284)));
evalcond[9]=((((-1.0)*x285*x287))+(((-1.0)*x288))+((new_r11*x284)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x291=((1.0)*new_r01);
CheckValue<IkReal> x292=IKPowWithIntegerCheck(new_r22,-1);
if(!x292.valid){
continue;
}
if( IKabs(((((-1.0)*cj1*x291))+(((-1.0)*new_r11*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x292.value)*((((cj1*new_r11))+(((-1.0)*sj1*x291)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj1*x291))+(((-1.0)*new_r11*sj1))))+IKsqr(((x292.value)*((((cj1*new_r11))+(((-1.0)*sj1*x291))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*cj1*x291))+(((-1.0)*new_r11*sj1))), ((x292.value)*((((cj1*new_r11))+(((-1.0)*sj1*x291))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[10];
IkReal x293=IKcos(j3);
IkReal x294=IKsin(j3);
IkReal x295=(cj1*new_r22);
IkReal x296=(new_r22*sj1);
IkReal x297=((1.0)*new_r00);
IkReal x298=((1.0)*new_r01);
IkReal x299=((1.0)*x293);
IkReal x300=(cj1*x294);
IkReal x301=((1.0)*x294);
evalcond[0]=(((new_r11*sj1))+((cj1*new_r01))+x294);
evalcond[1]=(((new_r10*sj1))+(((-1.0)*x299))+((cj1*new_r00)));
evalcond[2]=(x300+new_r01+((x293*x296)));
evalcond[3]=(((sj1*x294))+(((-1.0)*x295*x299))+new_r11);
evalcond[4]=((((-1.0)*new_r22*x301))+((cj1*new_r10))+(((-1.0)*sj1*x297)));
evalcond[5]=(((cj1*new_r11))+(((-1.0)*sj1*x298))+(((-1.0)*new_r22*x299)));
evalcond[6]=((((-1.0)*cj1*x299))+((x294*x296))+new_r00);
evalcond[7]=((((-1.0)*x295*x301))+(((-1.0)*sj1*x299))+new_r10);
evalcond[8]=((((-1.0)*x296*x297))+((new_r10*x295))+(((-1.0)*x301)));
evalcond[9]=(((new_r11*x295))+(((-1.0)*x299))+(((-1.0)*x296*x298)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x302=new_r22*new_r22;
IkReal x303=cj1*cj1;
IkReal x304=(new_r22*sj1);
CheckValue<IkReal> x305=IKPowWithIntegerCheck(IKsign(((((-1.0)*x302))+(((-1.0)*x303))+((x302*x303)))),-1);
if(!x305.valid){
continue;
}
CheckValue<IkReal> x306 = IKatan2WithCheck(IkReal((((new_r00*x304))+((cj1*new_r01)))),IkReal((((new_r01*x304))+(((-1.0)*cj1*new_r00)))),IKFAST_ATAN2_MAGTHRESH);
if(!x306.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x305.value)))+(x306.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[10];
IkReal x307=IKcos(j3);
IkReal x308=IKsin(j3);
IkReal x309=(cj1*new_r22);
IkReal x310=(new_r22*sj1);
IkReal x311=((1.0)*new_r00);
IkReal x312=((1.0)*new_r01);
IkReal x313=((1.0)*x307);
IkReal x314=(cj1*x308);
IkReal x315=((1.0)*x308);
evalcond[0]=(((new_r11*sj1))+((cj1*new_r01))+x308);
evalcond[1]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x313)));
evalcond[2]=(x314+((x307*x310))+new_r01);
evalcond[3]=(new_r11+(((-1.0)*x309*x313))+((sj1*x308)));
evalcond[4]=((((-1.0)*sj1*x311))+((cj1*new_r10))+(((-1.0)*new_r22*x315)));
evalcond[5]=((((-1.0)*sj1*x312))+((cj1*new_r11))+(((-1.0)*new_r22*x313)));
evalcond[6]=(((x308*x310))+(((-1.0)*cj1*x313))+new_r00);
evalcond[7]=((((-1.0)*sj1*x313))+new_r10+(((-1.0)*x309*x315)));
evalcond[8]=((((-1.0)*x310*x311))+((new_r10*x309))+(((-1.0)*x315)));
evalcond[9]=((((-1.0)*x310*x312))+((new_r11*x309))+(((-1.0)*x313)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x317=IKPowWithIntegerCheck(cj2,-1);
if(!x317.valid){
continue;
}
IkReal x316=x317.value;
CheckValue<IkReal> x318=IKPowWithIntegerCheck(new_r02,-1);
if(!x318.valid){
continue;
}
CheckValue<IkReal> x319=IKPowWithIntegerCheck(x316,-2);
if(!x319.valid){
continue;
}
if( IKabs((x316*(x318.value)*(((x319.value)+(((-1.0)*(new_r12*new_r12))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r12*x316)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x316*(x318.value)*(((x319.value)+(((-1.0)*(new_r12*new_r12)))))))+IKsqr(((-1.0)*new_r12*x316))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((x316*(x318.value)*(((x319.value)+(((-1.0)*(new_r12*new_r12)))))), ((-1.0)*new_r12*x316));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x320=IKsin(j1);
IkReal x321=IKcos(j1);
IkReal x322=((1.0)*x320);
IkReal x323=(cj2*x321);
IkReal x324=(new_r12*x321);
evalcond[0]=(x323+new_r12);
evalcond[1]=((((-1.0)*cj2*x322))+new_r02);
evalcond[2]=(((new_r12*x320))+((new_r02*x321)));
evalcond[3]=(cj2+(((-1.0)*new_r02*x322))+x324);
evalcond[4]=(((new_r20*sj2))+((new_r10*x323))+(((-1.0)*cj2*new_r00*x322)));
evalcond[5]=((((-1.0)*cj2*new_r01*x322))+((new_r21*sj2))+((new_r11*x323)));
evalcond[6]=((((-1.0)*sj2*x324))+((new_r02*sj2*x320))+((cj2*new_r22)));
evalcond[7]=((1.0)+((new_r12*x323))+((new_r22*sj2))+(((-1.0)*cj2*new_r02*x322)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[3];
j3eval[0]=cj2;
j3eval[1]=IKsign(cj2);
j3eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
j3eval[0]=cj2;
j3eval[1]=sj1;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
j3eval[0]=cj2;
j3eval[1]=sj1;
j3eval[2]=sj2;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x325=((1.0)*cj1);
if( IKabs(((((-1.0)*new_r01*x325))+(((-1.0)*new_r11*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r01*sj1))+(((-1.0)*new_r11*x325)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r01*x325))+(((-1.0)*new_r11*sj1))))+IKsqr((((new_r01*sj1))+(((-1.0)*new_r11*x325))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*new_r01*x325))+(((-1.0)*new_r11*sj1))), (((new_r01*sj1))+(((-1.0)*new_r11*x325))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x326=IKsin(j3);
IkReal x327=IKcos(j3);
IkReal x328=((1.0)*sj1);
IkReal x329=(cj1*x326);
IkReal x330=(cj1*x327);
IkReal x331=(x327*x328);
evalcond[0]=(((new_r11*sj1))+((cj1*new_r01))+x326);
evalcond[1]=(((cj1*new_r10))+x326+(((-1.0)*new_r00*x328)));
evalcond[2]=(((cj1*new_r11))+x327+(((-1.0)*new_r01*x328)));
evalcond[3]=(((new_r10*sj1))+(((-1.0)*x327))+((cj1*new_r00)));
evalcond[4]=(x330+((sj1*x326))+new_r11);
evalcond[5]=(x329+(((-1.0)*x331))+new_r01);
evalcond[6]=(x329+(((-1.0)*x331))+new_r10);
evalcond[7]=((((-1.0)*x326*x328))+(((-1.0)*x330))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x332=((1.0)*new_r01);
if( IKabs(((((-1.0)*new_r11*sj1))+(((-1.0)*cj1*x332)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*new_r11))+(((-1.0)*sj1*x332)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r11*sj1))+(((-1.0)*cj1*x332))))+IKsqr((((cj1*new_r11))+(((-1.0)*sj1*x332))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*new_r11*sj1))+(((-1.0)*cj1*x332))), (((cj1*new_r11))+(((-1.0)*sj1*x332))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x333=IKcos(j3);
IkReal x334=IKsin(j3);
IkReal x335=((1.0)*sj1);
IkReal x336=((1.0)*x333);
IkReal x337=(sj1*x334);
IkReal x338=((1.0)*x334);
IkReal x339=(sj1*x333);
IkReal x340=(cj1*x336);
evalcond[0]=(((new_r11*sj1))+((cj1*new_r01))+x334);
evalcond[1]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x336)));
evalcond[2]=(((cj1*x334))+x339+new_r01);
evalcond[3]=(x337+new_r11+(((-1.0)*x340)));
evalcond[4]=(((cj1*new_r10))+(((-1.0)*new_r00*x335))+(((-1.0)*x338)));
evalcond[5]=(((cj1*new_r11))+(((-1.0)*x336))+(((-1.0)*new_r01*x335)));
evalcond[6]=(x337+new_r00+(((-1.0)*x340)));
evalcond[7]=((((-1.0)*x333*x335))+new_r10+(((-1.0)*cj1*x338)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-1.0)*new_r01), new_r00);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x341=IKcos(j3);
IkReal x342=IKsin(j3);
IkReal x343=((1.0)*sj2);
IkReal x344=((1.0)*x341);
IkReal x345=((1.0)*x342);
evalcond[0]=(x342+new_r01);
evalcond[1]=(new_r00+(((-1.0)*x344)));
evalcond[2]=(((sj2*x341))+new_r11);
evalcond[3]=(((sj2*x342))+new_r10);
evalcond[4]=(new_r20+(((-1.0)*cj2*x345)));
evalcond[5]=(new_r21+(((-1.0)*cj2*x344)));
evalcond[6]=((((-1.0)*new_r10*x343))+((cj2*new_r20))+(((-1.0)*x345)));
evalcond[7]=((((-1.0)*new_r11*x343))+((cj2*new_r21))+(((-1.0)*x344)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(new_r01, ((-1.0)*new_r00));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x346=IKsin(j3);
IkReal x347=IKcos(j3);
IkReal x348=((1.0)*x347);
IkReal x349=((1.0)*x346);
evalcond[0]=(x346+(((-1.0)*new_r01)));
evalcond[1]=(new_r20+(((-1.0)*cj2*x349)));
evalcond[2]=(new_r21+(((-1.0)*cj2*x348)));
evalcond[3]=(new_r11+(((-1.0)*sj2*x348)));
evalcond[4]=((((-1.0)*new_r00))+(((-1.0)*x348)));
evalcond[5]=(((sj2*x346))+(((-1.0)*new_r10)));
evalcond[6]=(((new_r10*sj2))+((cj2*new_r20))+(((-1.0)*x349)));
evalcond[7]=(((new_r11*sj2))+((cj2*new_r21))+(((-1.0)*x348)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r20)+IKsqr(new_r21)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(new_r20, new_r21);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x350=IKsin(j3);
IkReal x351=IKcos(j3);
IkReal x352=((1.0)*x351);
evalcond[0]=((((-1.0)*x350))+new_r20);
evalcond[1]=((((-1.0)*x352))+new_r21);
evalcond[2]=(((sj1*x350))+new_r11);
evalcond[3]=(((cj1*x350))+new_r01);
evalcond[4]=(new_r10+(((-1.0)*sj1*x352)));
evalcond[5]=((((-1.0)*cj1*x352))+new_r00);
evalcond[6]=(((new_r11*sj1))+((cj1*new_r01))+x350);
evalcond[7]=(((new_r10*sj1))+(((-1.0)*x352))+((cj1*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r20))+IKsqr(((-1.0)*new_r21))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-1.0)*new_r20), ((-1.0)*new_r21));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x353=IKsin(j3);
IkReal x354=IKcos(j3);
IkReal x355=((1.0)*x354);
evalcond[0]=(x353+new_r20);
evalcond[1]=(x354+new_r21);
evalcond[2]=(((sj1*x353))+new_r11);
evalcond[3]=(((cj1*x353))+new_r01);
evalcond[4]=(new_r10+(((-1.0)*sj1*x355)));
evalcond[5]=((((-1.0)*cj1*x355))+new_r00);
evalcond[6]=(((new_r11*sj1))+((cj1*new_r01))+x353);
evalcond[7]=(((new_r10*sj1))+(((-1.0)*x355))+((cj1*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j3eval[0]=IKabs(new_r22);
if( IKabs(j3eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j3]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=new_r22;
op[1]=0;
op[2]=((-1.0)*new_r22);
polyroots2(op,zeror,numroots);
IkReal j3array[2], cj3array[2], sj3array[2], tempj3array[1];
int numsolutions = 0;
for(int ij3 = 0; ij3 < numroots; ++ij3)
{
IkReal htj3 = zeror[ij3];
tempj3array[0]=((2.0)*(atan(htj3)));
for(int kj3 = 0; kj3 < 1; ++kj3)
{
j3array[numsolutions] = tempj3array[kj3];
if( j3array[numsolutions] > IKPI )
{
    j3array[numsolutions]-=IK2PI;
}
else if( j3array[numsolutions] < -IKPI )
{
    j3array[numsolutions]+=IK2PI;
}
sj3array[numsolutions] = IKsin(j3array[numsolutions]);
cj3array[numsolutions] = IKcos(j3array[numsolutions]);
numsolutions++;
}
}
bool j3valid[2]={true,true};
_nj3 = 2;
for(int ij3 = 0; ij3 < numsolutions; ++ij3)
    {
if( !j3valid[ij3] )
{
    continue;
}
    j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
htj3 = IKtan(j3/2);

_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < numsolutions; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x357=IKPowWithIntegerCheck(cj2,-1);
if(!x357.valid){
continue;
}
IkReal x356=x357.value;
CheckValue<IkReal> x358=IKPowWithIntegerCheck(sj1,-1);
if(!x358.valid){
continue;
}
CheckValue<IkReal> x359=IKPowWithIntegerCheck(sj2,-1);
if(!x359.valid){
continue;
}
if( IKabs((new_r20*x356)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x356*(x358.value)*(x359.value)*((((cj1*new_r20))+((cj2*new_r01)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r20*x356))+IKsqr((x356*(x358.value)*(x359.value)*((((cj1*new_r20))+((cj2*new_r01))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((new_r20*x356), (x356*(x358.value)*(x359.value)*((((cj1*new_r20))+((cj2*new_r01))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x360=IKsin(j3);
IkReal x361=IKcos(j3);
IkReal x362=(cj1*new_r11);
IkReal x363=((1.0)*cj2);
IkReal x364=((1.0)*sj2);
IkReal x365=((1.0)*sj1);
IkReal x366=(cj1*new_r10);
IkReal x367=(sj1*sj2);
IkReal x368=((1.0)*x361);
IkReal x369=(cj1*x360);
IkReal x370=(sj2*x360);
IkReal x371=(sj2*x361);
evalcond[0]=((((-1.0)*x360*x363))+new_r20);
evalcond[1]=((((-1.0)*x361*x363))+new_r21);
evalcond[2]=(((new_r11*sj1))+((cj1*new_r01))+x360);
evalcond[3]=(((new_r10*sj1))+(((-1.0)*x368))+((cj1*new_r00)));
evalcond[4]=(((sj1*x360))+((cj1*x371))+new_r11);
evalcond[5]=((((-1.0)*new_r00*x365))+x370+x366);
evalcond[6]=(x371+x362+(((-1.0)*new_r01*x365)));
evalcond[7]=(x369+(((-1.0)*sj1*x361*x364))+new_r01);
evalcond[8]=((((-1.0)*x361*x365))+((sj2*x369))+new_r10);
evalcond[9]=((((-1.0)*sj1*x360*x364))+(((-1.0)*cj1*x368))+new_r00);
evalcond[10]=((((-1.0)*x360))+((new_r00*x367))+(((-1.0)*x364*x366))+((cj2*new_r20)));
evalcond[11]=((((-1.0)*x362*x364))+(((-1.0)*x368))+((new_r01*x367))+((cj2*new_r21)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x373=IKPowWithIntegerCheck(cj2,-1);
if(!x373.valid){
continue;
}
IkReal x372=x373.value;
CheckValue<IkReal> x374=IKPowWithIntegerCheck(sj1,-1);
if(!x374.valid){
continue;
}
if( IKabs((x372*(x374.value)*(((((-1.0)*cj1*new_r21*sj2))+(((-1.0)*cj2*new_r11)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r21*x372)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x372*(x374.value)*(((((-1.0)*cj1*new_r21*sj2))+(((-1.0)*cj2*new_r11))))))+IKsqr((new_r21*x372))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((x372*(x374.value)*(((((-1.0)*cj1*new_r21*sj2))+(((-1.0)*cj2*new_r11))))), (new_r21*x372));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x375=IKsin(j3);
IkReal x376=IKcos(j3);
IkReal x377=(cj1*new_r11);
IkReal x378=((1.0)*cj2);
IkReal x379=((1.0)*sj2);
IkReal x380=((1.0)*sj1);
IkReal x381=(cj1*new_r10);
IkReal x382=(sj1*sj2);
IkReal x383=((1.0)*x376);
IkReal x384=(cj1*x375);
IkReal x385=(sj2*x375);
IkReal x386=(sj2*x376);
evalcond[0]=(new_r20+(((-1.0)*x375*x378)));
evalcond[1]=((((-1.0)*x376*x378))+new_r21);
evalcond[2]=(((new_r11*sj1))+((cj1*new_r01))+x375);
evalcond[3]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x383)));
evalcond[4]=(((cj1*x386))+((sj1*x375))+new_r11);
evalcond[5]=((((-1.0)*new_r00*x380))+x385+x381);
evalcond[6]=((((-1.0)*new_r01*x380))+x386+x377);
evalcond[7]=((((-1.0)*sj1*x376*x379))+x384+new_r01);
evalcond[8]=((((-1.0)*x376*x380))+new_r10+((sj2*x384)));
evalcond[9]=((((-1.0)*cj1*x383))+new_r00+(((-1.0)*sj1*x375*x379)));
evalcond[10]=((((-1.0)*x375))+((new_r00*x382))+(((-1.0)*x379*x381))+((cj2*new_r20)));
evalcond[11]=(((new_r01*x382))+(((-1.0)*x377*x379))+(((-1.0)*x383))+((cj2*new_r21)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x387=IKPowWithIntegerCheck(IKsign(cj2),-1);
if(!x387.valid){
continue;
}
CheckValue<IkReal> x388 = IKatan2WithCheck(IkReal(new_r20),IkReal(new_r21),IKFAST_ATAN2_MAGTHRESH);
if(!x388.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x387.value)))+(x388.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x389=IKsin(j3);
IkReal x390=IKcos(j3);
IkReal x391=(cj1*new_r11);
IkReal x392=((1.0)*cj2);
IkReal x393=((1.0)*sj2);
IkReal x394=((1.0)*sj1);
IkReal x395=(cj1*new_r10);
IkReal x396=(sj1*sj2);
IkReal x397=((1.0)*x390);
IkReal x398=(cj1*x389);
IkReal x399=(sj2*x389);
IkReal x400=(sj2*x390);
evalcond[0]=((((-1.0)*x389*x392))+new_r20);
evalcond[1]=((((-1.0)*x390*x392))+new_r21);
evalcond[2]=(((new_r11*sj1))+((cj1*new_r01))+x389);
evalcond[3]=((((-1.0)*x397))+((new_r10*sj1))+((cj1*new_r00)));
evalcond[4]=(new_r11+((sj1*x389))+((cj1*x400)));
evalcond[5]=(x395+x399+(((-1.0)*new_r00*x394)));
evalcond[6]=((((-1.0)*new_r01*x394))+x391+x400);
evalcond[7]=(x398+(((-1.0)*sj1*x390*x393))+new_r01);
evalcond[8]=(((sj2*x398))+(((-1.0)*x390*x394))+new_r10);
evalcond[9]=((((-1.0)*cj1*x397))+new_r00+(((-1.0)*sj1*x389*x393)));
evalcond[10]=((((-1.0)*x389))+((new_r00*x396))+((cj2*new_r20))+(((-1.0)*x393*x395)));
evalcond[11]=((((-1.0)*x397))+(((-1.0)*x391*x393))+((new_r01*x396))+((cj2*new_r21)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x401=IKPowWithIntegerCheck(IKsign(cj2),-1);
if(!x401.valid){
continue;
}
CheckValue<IkReal> x402 = IKatan2WithCheck(IkReal(new_r02),IkReal(((-1.0)*new_r12)),IKFAST_ATAN2_MAGTHRESH);
if(!x402.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x401.value)))+(x402.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x403=IKsin(j1);
IkReal x404=IKcos(j1);
IkReal x405=((1.0)*x403);
IkReal x406=(cj2*x404);
IkReal x407=(new_r12*x404);
evalcond[0]=(x406+new_r12);
evalcond[1]=((((-1.0)*cj2*x405))+new_r02);
evalcond[2]=(((new_r12*x403))+((new_r02*x404)));
evalcond[3]=(cj2+x407+(((-1.0)*new_r02*x405)));
evalcond[4]=(((new_r20*sj2))+((new_r10*x406))+(((-1.0)*cj2*new_r00*x405)));
evalcond[5]=((((-1.0)*cj2*new_r01*x405))+((new_r11*x406))+((new_r21*sj2)));
evalcond[6]=(((new_r02*sj2*x403))+(((-1.0)*sj2*x407))+((cj2*new_r22)));
evalcond[7]=((1.0)+((new_r22*sj2))+((new_r12*x406))+(((-1.0)*cj2*new_r02*x405)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[3];
j3eval[0]=cj2;
j3eval[1]=IKsign(cj2);
j3eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
j3eval[0]=cj2;
j3eval[1]=sj1;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
j3eval[0]=cj2;
j3eval[1]=sj1;
j3eval[2]=sj2;
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x408=((1.0)*cj1);
if( IKabs(((((-1.0)*new_r11*sj1))+(((-1.0)*new_r01*x408)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r01*sj1))+(((-1.0)*new_r11*x408)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r11*sj1))+(((-1.0)*new_r01*x408))))+IKsqr((((new_r01*sj1))+(((-1.0)*new_r11*x408))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*new_r11*sj1))+(((-1.0)*new_r01*x408))), (((new_r01*sj1))+(((-1.0)*new_r11*x408))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x409=IKsin(j3);
IkReal x410=IKcos(j3);
IkReal x411=((1.0)*sj1);
IkReal x412=(cj1*x409);
IkReal x413=(cj1*x410);
IkReal x414=(x410*x411);
evalcond[0]=(((new_r11*sj1))+((cj1*new_r01))+x409);
evalcond[1]=(((cj1*new_r10))+x409+(((-1.0)*new_r00*x411)));
evalcond[2]=(((cj1*new_r11))+x410+(((-1.0)*new_r01*x411)));
evalcond[3]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x410)));
evalcond[4]=(((sj1*x409))+x413+new_r11);
evalcond[5]=(x412+new_r01+(((-1.0)*x414)));
evalcond[6]=(x412+new_r10+(((-1.0)*x414)));
evalcond[7]=(new_r00+(((-1.0)*x409*x411))+(((-1.0)*x413)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x415=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj1*x415))+(((-1.0)*new_r11*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*new_r11))+(((-1.0)*sj1*x415)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj1*x415))+(((-1.0)*new_r11*sj1))))+IKsqr((((cj1*new_r11))+(((-1.0)*sj1*x415))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((-1.0)*cj1*x415))+(((-1.0)*new_r11*sj1))), (((cj1*new_r11))+(((-1.0)*sj1*x415))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x416=IKcos(j3);
IkReal x417=IKsin(j3);
IkReal x418=((1.0)*sj1);
IkReal x419=((1.0)*x416);
IkReal x420=(sj1*x417);
IkReal x421=((1.0)*x417);
IkReal x422=(sj1*x416);
IkReal x423=(cj1*x419);
evalcond[0]=(((new_r11*sj1))+((cj1*new_r01))+x417);
evalcond[1]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x419)));
evalcond[2]=(x422+new_r01+((cj1*x417)));
evalcond[3]=((((-1.0)*x423))+x420+new_r11);
evalcond[4]=((((-1.0)*x421))+((cj1*new_r10))+(((-1.0)*new_r00*x418)));
evalcond[5]=(((cj1*new_r11))+(((-1.0)*x419))+(((-1.0)*new_r01*x418)));
evalcond[6]=((((-1.0)*x423))+x420+new_r00);
evalcond[7]=((((-1.0)*cj1*x421))+(((-1.0)*x416*x418))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-1.0)*new_r01), new_r00);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x424=IKcos(j3);
IkReal x425=IKsin(j3);
IkReal x426=((1.0)*sj2);
IkReal x427=((1.0)*x424);
IkReal x428=((1.0)*x425);
evalcond[0]=(x425+new_r01);
evalcond[1]=((((-1.0)*x427))+new_r00);
evalcond[2]=(new_r11+((sj2*x424)));
evalcond[3]=(new_r10+((sj2*x425)));
evalcond[4]=((((-1.0)*cj2*x428))+new_r20);
evalcond[5]=((((-1.0)*cj2*x427))+new_r21);
evalcond[6]=((((-1.0)*x428))+(((-1.0)*new_r10*x426))+((cj2*new_r20)));
evalcond[7]=((((-1.0)*x427))+(((-1.0)*new_r11*x426))+((cj2*new_r21)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(new_r01, ((-1.0)*new_r00));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x429=IKsin(j3);
IkReal x430=IKcos(j3);
IkReal x431=((1.0)*x430);
IkReal x432=((1.0)*x429);
evalcond[0]=(x429+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*cj2*x432))+new_r20);
evalcond[2]=((((-1.0)*cj2*x431))+new_r21);
evalcond[3]=(new_r11+(((-1.0)*sj2*x431)));
evalcond[4]=((((-1.0)*x431))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*new_r10))+((sj2*x429)));
evalcond[6]=((((-1.0)*x432))+((new_r10*sj2))+((cj2*new_r20)));
evalcond[7]=((((-1.0)*x431))+((new_r11*sj2))+((cj2*new_r21)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r20)+IKsqr(new_r21)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(new_r20, new_r21);
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x433=IKsin(j3);
IkReal x434=IKcos(j3);
IkReal x435=((1.0)*x434);
evalcond[0]=((((-1.0)*x433))+new_r20);
evalcond[1]=((((-1.0)*x435))+new_r21);
evalcond[2]=(new_r11+((sj1*x433)));
evalcond[3]=(((cj1*x433))+new_r01);
evalcond[4]=((((-1.0)*sj1*x435))+new_r10);
evalcond[5]=((((-1.0)*cj1*x435))+new_r00);
evalcond[6]=(((new_r11*sj1))+((cj1*new_r01))+x433);
evalcond[7]=((((-1.0)*x435))+((new_r10*sj1))+((cj1*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r20))+IKsqr(((-1.0)*new_r21))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-1.0)*new_r20), ((-1.0)*new_r21));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x436=IKsin(j3);
IkReal x437=IKcos(j3);
IkReal x438=((1.0)*x437);
evalcond[0]=(x436+new_r20);
evalcond[1]=(x437+new_r21);
evalcond[2]=(new_r11+((sj1*x436)));
evalcond[3]=(((cj1*x436))+new_r01);
evalcond[4]=((((-1.0)*sj1*x438))+new_r10);
evalcond[5]=((((-1.0)*cj1*x438))+new_r00);
evalcond[6]=(((new_r11*sj1))+((cj1*new_r01))+x436);
evalcond[7]=((((-1.0)*x438))+((new_r10*sj1))+((cj1*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j3eval[0]=IKabs(new_r22);
if( IKabs(j3eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j3]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=new_r22;
op[1]=0;
op[2]=((-1.0)*new_r22);
polyroots2(op,zeror,numroots);
IkReal j3array[2], cj3array[2], sj3array[2], tempj3array[1];
int numsolutions = 0;
for(int ij3 = 0; ij3 < numroots; ++ij3)
{
IkReal htj3 = zeror[ij3];
tempj3array[0]=((2.0)*(atan(htj3)));
for(int kj3 = 0; kj3 < 1; ++kj3)
{
j3array[numsolutions] = tempj3array[kj3];
if( j3array[numsolutions] > IKPI )
{
    j3array[numsolutions]-=IK2PI;
}
else if( j3array[numsolutions] < -IKPI )
{
    j3array[numsolutions]+=IK2PI;
}
sj3array[numsolutions] = IKsin(j3array[numsolutions]);
cj3array[numsolutions] = IKcos(j3array[numsolutions]);
numsolutions++;
}
}
bool j3valid[2]={true,true};
_nj3 = 2;
for(int ij3 = 0; ij3 < numsolutions; ++ij3)
    {
if( !j3valid[ij3] )
{
    continue;
}
    j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
htj3 = IKtan(j3/2);

_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < numsolutions; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x440=IKPowWithIntegerCheck(cj2,-1);
if(!x440.valid){
continue;
}
IkReal x439=x440.value;
CheckValue<IkReal> x441=IKPowWithIntegerCheck(sj1,-1);
if(!x441.valid){
continue;
}
CheckValue<IkReal> x442=IKPowWithIntegerCheck(sj2,-1);
if(!x442.valid){
continue;
}
if( IKabs((new_r20*x439)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x439*(x441.value)*(x442.value)*((((cj1*new_r20))+((cj2*new_r01)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r20*x439))+IKsqr((x439*(x441.value)*(x442.value)*((((cj1*new_r20))+((cj2*new_r01))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((new_r20*x439), (x439*(x441.value)*(x442.value)*((((cj1*new_r20))+((cj2*new_r01))))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x443=IKsin(j3);
IkReal x444=IKcos(j3);
IkReal x445=(cj1*new_r11);
IkReal x446=((1.0)*cj2);
IkReal x447=((1.0)*sj2);
IkReal x448=((1.0)*sj1);
IkReal x449=(cj1*new_r10);
IkReal x450=(sj1*sj2);
IkReal x451=((1.0)*x444);
IkReal x452=(cj1*x443);
IkReal x453=(sj2*x443);
IkReal x454=(sj2*x444);
evalcond[0]=((((-1.0)*x443*x446))+new_r20);
evalcond[1]=((((-1.0)*x444*x446))+new_r21);
evalcond[2]=(((new_r11*sj1))+((cj1*new_r01))+x443);
evalcond[3]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x451)));
evalcond[4]=(((sj1*x443))+((cj1*x454))+new_r11);
evalcond[5]=((((-1.0)*new_r00*x448))+x449+x453);
evalcond[6]=((((-1.0)*new_r01*x448))+x445+x454);
evalcond[7]=(x452+(((-1.0)*sj1*x444*x447))+new_r01);
evalcond[8]=(((sj2*x452))+(((-1.0)*x444*x448))+new_r10);
evalcond[9]=((((-1.0)*sj1*x443*x447))+(((-1.0)*cj1*x451))+new_r00);
evalcond[10]=((((-1.0)*x443))+((new_r00*x450))+(((-1.0)*x447*x449))+((cj2*new_r20)));
evalcond[11]=((((-1.0)*x445*x447))+((new_r01*x450))+(((-1.0)*x451))+((cj2*new_r21)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x456=IKPowWithIntegerCheck(cj2,-1);
if(!x456.valid){
continue;
}
IkReal x455=x456.value;
CheckValue<IkReal> x457=IKPowWithIntegerCheck(sj1,-1);
if(!x457.valid){
continue;
}
if( IKabs((x455*(x457.value)*(((((-1.0)*cj1*new_r21*sj2))+(((-1.0)*cj2*new_r11)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r21*x455)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x455*(x457.value)*(((((-1.0)*cj1*new_r21*sj2))+(((-1.0)*cj2*new_r11))))))+IKsqr((new_r21*x455))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((x455*(x457.value)*(((((-1.0)*cj1*new_r21*sj2))+(((-1.0)*cj2*new_r11))))), (new_r21*x455));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x458=IKsin(j3);
IkReal x459=IKcos(j3);
IkReal x460=(cj1*new_r11);
IkReal x461=((1.0)*cj2);
IkReal x462=((1.0)*sj2);
IkReal x463=((1.0)*sj1);
IkReal x464=(cj1*new_r10);
IkReal x465=(sj1*sj2);
IkReal x466=((1.0)*x459);
IkReal x467=(cj1*x458);
IkReal x468=(sj2*x458);
IkReal x469=(sj2*x459);
evalcond[0]=((((-1.0)*x458*x461))+new_r20);
evalcond[1]=((((-1.0)*x459*x461))+new_r21);
evalcond[2]=(((new_r11*sj1))+((cj1*new_r01))+x458);
evalcond[3]=(((new_r10*sj1))+((cj1*new_r00))+(((-1.0)*x466)));
evalcond[4]=(((cj1*x469))+((sj1*x458))+new_r11);
evalcond[5]=((((-1.0)*new_r00*x463))+x468+x464);
evalcond[6]=((((-1.0)*new_r01*x463))+x469+x460);
evalcond[7]=((((-1.0)*sj1*x459*x462))+x467+new_r01);
evalcond[8]=((((-1.0)*x459*x463))+new_r10+((sj2*x467)));
evalcond[9]=((((-1.0)*cj1*x466))+(((-1.0)*sj1*x458*x462))+new_r00);
evalcond[10]=((((-1.0)*x462*x464))+((new_r00*x465))+(((-1.0)*x458))+((cj2*new_r20)));
evalcond[11]=(((new_r01*x465))+(((-1.0)*x460*x462))+(((-1.0)*x466))+((cj2*new_r21)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x470=IKPowWithIntegerCheck(IKsign(cj2),-1);
if(!x470.valid){
continue;
}
CheckValue<IkReal> x471 = IKatan2WithCheck(IkReal(new_r20),IkReal(new_r21),IKFAST_ATAN2_MAGTHRESH);
if(!x471.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x470.value)))+(x471.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[12];
IkReal x472=IKsin(j3);
IkReal x473=IKcos(j3);
IkReal x474=(cj1*new_r11);
IkReal x475=((1.0)*cj2);
IkReal x476=((1.0)*sj2);
IkReal x477=((1.0)*sj1);
IkReal x478=(cj1*new_r10);
IkReal x479=(sj1*sj2);
IkReal x480=((1.0)*x473);
IkReal x481=(cj1*x472);
IkReal x482=(sj2*x472);
IkReal x483=(sj2*x473);
evalcond[0]=((((-1.0)*x472*x475))+new_r20);
evalcond[1]=((((-1.0)*x473*x475))+new_r21);
evalcond[2]=(((new_r11*sj1))+((cj1*new_r01))+x472);
evalcond[3]=(((new_r10*sj1))+(((-1.0)*x480))+((cj1*new_r00)));
evalcond[4]=(((cj1*x483))+((sj1*x472))+new_r11);
evalcond[5]=((((-1.0)*new_r00*x477))+x482+x478);
evalcond[6]=((((-1.0)*new_r01*x477))+x483+x474);
evalcond[7]=((((-1.0)*sj1*x473*x476))+x481+new_r01);
evalcond[8]=((((-1.0)*x473*x477))+((sj2*x481))+new_r10);
evalcond[9]=((((-1.0)*cj1*x480))+(((-1.0)*sj1*x472*x476))+new_r00);
evalcond[10]=((((-1.0)*x476*x478))+((new_r00*x479))+(((-1.0)*x472))+((cj2*new_r20)));
evalcond[11]=((((-1.0)*x480))+((new_r01*x479))+((cj2*new_r21))+(((-1.0)*x474*x476)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x484=IKPowWithIntegerCheck(IKsign(cj2),-1);
if(!x484.valid){
continue;
}
CheckValue<IkReal> x485 = IKatan2WithCheck(IkReal(new_r20),IkReal(new_r21),IKFAST_ATAN2_MAGTHRESH);
if(!x485.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x484.value)))+(x485.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[2];
IkReal x486=((1.0)*cj2);
evalcond[0]=((((-1.0)*x486*(IKsin(j3))))+new_r20);
evalcond[1]=((((-1.0)*x486*(IKcos(j3))))+new_r21);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[3];
j1eval[0]=cj2;
j1eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j1eval[2]=IKsign(cj2);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
j1eval[0]=cj2;
j1eval[1]=new_r11;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
IkReal x487=((1.0)*sj3);
IkReal x488=(((new_r10*new_r11))+((new_r00*new_r01)));
j1eval[0]=x488;
j1eval[1]=IKsign(x488);
j1eval[2]=((IKabs(((((-1.0)*new_r10*x487))+((new_r01*sj3)))))+(IKabs(((((-1.0)*new_r11*x487))+(((-1.0)*new_r00*x487))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
IkReal x489=((1.0)*sj3);
IkReal x490=((new_r01*new_r01)+(new_r11*new_r11));
j1eval[0]=x490;
j1eval[1]=((IKabs(((((-1.0)*new_r01*x489))+(((-1.0)*cj3*new_r11)))))+(IKabs(((((-1.0)*new_r11*x489))+((cj3*new_r01))))));
j1eval[2]=IKsign(x490);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
IkReal x491=(((new_r11*sj3))+((cj3*new_r01)));
j1eval[0]=x491;
j1eval[1]=((IKabs(((-1.0)+(cj3*cj3)+(new_r01*new_r01))))+(IKabs(((((-1.0)*cj3*sj3))+(((-1.0)*new_r01*new_r11))))));
j1eval[2]=IKsign(x491);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x493 = ((new_r01*new_r01)+(new_r11*new_r11));
if(IKabs(x493)==0){
continue;
}
IkReal x492=pow(x493,-0.5);
CheckValue<IkReal> x494 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x494.valid){
continue;
}
IkReal gconst82=((-1.0)*(x494.value));
IkReal gconst83=((-1.0)*new_r01*x492);
IkReal gconst84=(new_r11*x492);
CheckValue<IkReal> x495 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x495.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x495.value)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
CheckValue<IkReal> x498 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x498.valid){
continue;
}
IkReal x496=((-1.0)*(x498.value));
IkReal x497=x492;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst83;
cj3=gconst84;
j3=x496;
IkReal gconst82=x496;
IkReal gconst83=((-1.0)*new_r01*x497);
IkReal gconst84=(new_r11*x497);
IkReal x499=new_r01*new_r01;
IkReal x500=(new_r00*new_r01);
IkReal x501=(((new_r10*new_r11))+x500);
IkReal x502=x492;
IkReal x503=(new_r01*x502);
j1eval[0]=x501;
j1eval[1]=IKsign(x501);
j1eval[2]=((IKabs((((new_r10*x503))+(((-1.0)*x499*x502)))))+(IKabs((((x500*x502))+((new_r11*x503))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
CheckValue<IkReal> x506 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x506.valid){
continue;
}
IkReal x504=((-1.0)*(x506.value));
IkReal x505=x492;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst83;
cj3=gconst84;
j3=x504;
IkReal gconst82=x504;
IkReal gconst83=((-1.0)*new_r01*x505);
IkReal gconst84=(new_r11*x505);
IkReal x507=((new_r01*new_r01)+(new_r11*new_r11));
j1eval[0]=x507;
j1eval[1]=IKsign(x507);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x510 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x510.valid){
continue;
}
IkReal x508=((-1.0)*(x510.value));
IkReal x509=x492;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst83;
cj3=gconst84;
j3=x508;
IkReal gconst82=x508;
IkReal gconst83=((-1.0)*new_r01*x509);
IkReal gconst84=(new_r11*x509);
IkReal x511=new_r01*new_r01;
IkReal x512=new_r11*new_r11;
IkReal x513=((1.0)*x511);
CheckValue<IkReal> x519=IKPowWithIntegerCheck((x512+x511),-1);
if(!x519.valid){
continue;
}
IkReal x514=x519.value;
CheckValue<IkReal> x520=IKPowWithIntegerCheck(((((-1.0)*x512))+(((-1.0)*x513))),-1);
if(!x520.valid){
continue;
}
IkReal x515=x520.value;
IkReal x516=((1.0)*x515);
IkReal x517=(new_r11*x516);
IkReal x518=(new_r01*x516);
j1eval[0]=((IKabs(((((-1.0)*x513*x514))+((x511*x512*x514))+((x514*(x512*x512))))))+(IKabs(((((-1.0)*x517*(new_r01*new_r01*new_r01)))+(((-1.0)*new_r01*x517*(new_r11*new_r11)))+(((-1.0)*new_r01*x517))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
CheckValue<IkReal> x522 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x522.valid){
continue;
}
IkReal x521=((-1.0)*(x522.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst83;
cj3=gconst84;
j3=x521;
new_r11=0;
new_r00=0;
IkReal gconst82=x521;
IkReal x523 = new_r01*new_r01;
if(IKabs(x523)==0){
continue;
}
IkReal gconst83=((-1.0)*new_r01*(pow(x523,-0.5)));
IkReal gconst84=0;
j1eval[0]=new_r01;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x525 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x525.valid){
continue;
}
IkReal x524=((-1.0)*(x525.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst83;
cj3=gconst84;
j3=x524;
new_r11=0;
new_r00=0;
IkReal gconst82=x524;
IkReal x526 = new_r01*new_r01;
if(IKabs(x526)==0){
continue;
}
IkReal gconst83=((-1.0)*new_r01*(pow(x526,-0.5)));
IkReal gconst84=0;
j1eval[0]=new_r10;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x527=IKPowWithIntegerCheck(gconst83,-1);
if(!x527.valid){
continue;
}
cj1array[0]=((-1.0)*new_r01*(x527.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x528=IKsin(j1);
IkReal x529=IKcos(j1);
evalcond[0]=(new_r10*x528);
evalcond[1]=(gconst83*x528);
evalcond[2]=((-1.0)*new_r01*x528);
evalcond[3]=(((new_r01*x529))+gconst83);
evalcond[4]=(gconst83+((new_r10*x529)));
evalcond[5]=(((gconst83*x529))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x530=IKPowWithIntegerCheck(new_r10,-1);
if(!x530.valid){
continue;
}
cj1array[0]=((-1.0)*gconst83*(x530.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x531=IKsin(j1);
IkReal x532=IKcos(j1);
IkReal x533=(gconst83*x532);
evalcond[0]=(new_r10*x531);
evalcond[1]=(gconst83*x531);
evalcond[2]=((-1.0)*new_r01*x531);
evalcond[3]=(((new_r01*x532))+gconst83);
evalcond[4]=(x533+new_r01);
evalcond[5]=(x533+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x534=IKPowWithIntegerCheck(new_r01,-1);
if(!x534.valid){
continue;
}
cj1array[0]=((-1.0)*gconst83*(x534.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x535=IKsin(j1);
IkReal x536=IKcos(j1);
IkReal x537=(gconst83*x536);
evalcond[0]=(new_r10*x535);
evalcond[1]=(gconst83*x535);
evalcond[2]=((-1.0)*new_r01*x535);
evalcond[3]=(gconst83+((new_r10*x536)));
evalcond[4]=(x537+new_r01);
evalcond[5]=(x537+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
evalcond[1]=gconst83;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
CheckValue<IkReal> x539 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x539.valid){
continue;
}
IkReal x538=((-1.0)*(x539.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst83;
cj3=gconst84;
j3=x538;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst82=x538;
IkReal gconst83=((-1.0)*new_r01);
IkReal gconst84=new_r11;
j1eval[0]=-1.0;
j1eval[1]=-1.0;
j1eval[2]=((IKabs(new_r01*new_r01))+(IKabs((new_r01*new_r11))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
CheckValue<IkReal> x541 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x541.valid){
continue;
}
IkReal x540=((-1.0)*(x541.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst83;
cj3=gconst84;
j3=x540;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst82=x540;
IkReal gconst83=((-1.0)*new_r01);
IkReal gconst84=new_r11;
j1eval[0]=-1.0;
j1eval[1]=((IKabs((new_r01*new_r11)))+(IKabs(((1.0)+(((-1.0)*(new_r01*new_r01)))))));
j1eval[2]=-1.0;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
CheckValue<IkReal> x543 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x543.valid){
continue;
}
IkReal x542=((-1.0)*(x543.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst83;
cj3=gconst84;
j3=x542;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst82=x542;
IkReal gconst83=((-1.0)*new_r01);
IkReal gconst84=new_r11;
j1eval[0]=1.0;
j1eval[1]=((((0.5)*(IKabs(((-1.0)+(((2.0)*(new_r01*new_r01))))))))+(IKabs((new_r01*new_r11))));
j1eval[2]=1.0;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x544=((1.0)*gconst83);
CheckValue<IkReal> x545 = IKatan2WithCheck(IkReal((((gconst84*new_r01))+(((-1.0)*new_r11*x544)))),IkReal(((((-1.0)*new_r01*x544))+(((-1.0)*gconst84*new_r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x545.valid){
continue;
}
CheckValue<IkReal> x546=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x546.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x545.value)+(((1.5707963267949)*(x546.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x547=IKcos(j1);
IkReal x548=IKsin(j1);
IkReal x549=(gconst83*x547);
IkReal x550=((1.0)*x548);
IkReal x551=(gconst84*x547);
IkReal x552=(gconst84*x550);
evalcond[0]=(gconst83+((new_r11*x548))+((new_r01*x547)));
evalcond[1]=(((gconst83*x548))+x551+new_r11);
evalcond[2]=((((-1.0)*x552))+x549);
evalcond[3]=(gconst84+(((-1.0)*new_r01*x550))+((new_r11*x547)));
evalcond[4]=((((-1.0)*x552))+x549+new_r01);
evalcond[5]=((((-1.0)*x551))+(((-1.0)*gconst83*x550)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x553=IKPowWithIntegerCheck(IKsign(((((-1.0)*(gconst84*gconst84)))+(((-1.0)*(gconst83*gconst83))))),-1);
if(!x553.valid){
continue;
}
CheckValue<IkReal> x554 = IKatan2WithCheck(IkReal((gconst83*new_r11)),IkReal((gconst84*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x554.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x553.value)))+(x554.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x555=IKcos(j1);
IkReal x556=IKsin(j1);
IkReal x557=(gconst83*x555);
IkReal x558=((1.0)*x556);
IkReal x559=(gconst84*x555);
IkReal x560=(gconst84*x558);
evalcond[0]=(((new_r11*x556))+gconst83+((new_r01*x555)));
evalcond[1]=(((gconst83*x556))+x559+new_r11);
evalcond[2]=(x557+(((-1.0)*x560)));
evalcond[3]=(((new_r11*x555))+gconst84+(((-1.0)*new_r01*x558)));
evalcond[4]=(x557+new_r01+(((-1.0)*x560)));
evalcond[5]=((((-1.0)*x559))+(((-1.0)*gconst83*x558)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x561=IKPowWithIntegerCheck(IKsign(((((-1.0)*gconst84*new_r11))+((gconst83*new_r01)))),-1);
if(!x561.valid){
continue;
}
CheckValue<IkReal> x562 = IKatan2WithCheck(IkReal((gconst83*gconst84)),IkReal(((-1.0)*(gconst83*gconst83))),IKFAST_ATAN2_MAGTHRESH);
if(!x562.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x561.value)))+(x562.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x563=IKcos(j1);
IkReal x564=IKsin(j1);
IkReal x565=(gconst83*x563);
IkReal x566=((1.0)*x564);
IkReal x567=(gconst84*x563);
IkReal x568=(gconst84*x566);
evalcond[0]=(gconst83+((new_r01*x563))+((new_r11*x564)));
evalcond[1]=(x567+((gconst83*x564))+new_r11);
evalcond[2]=(x565+(((-1.0)*x568)));
evalcond[3]=(gconst84+((new_r11*x563))+(((-1.0)*new_r01*x566)));
evalcond[4]=(x565+new_r01+(((-1.0)*x568)));
evalcond[5]=((((-1.0)*gconst83*x566))+(((-1.0)*x567)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x569=IKPowWithIntegerCheck(gconst84,-1);
if(!x569.valid){
continue;
}
cj1array[0]=(new_r00*(x569.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x570=IKsin(j1);
IkReal x571=IKcos(j1);
IkReal x572=((-1.0)*x570);
evalcond[0]=(new_r11*x570);
evalcond[1]=(new_r00*x572);
evalcond[2]=(gconst84*x572);
evalcond[3]=(((gconst84*x571))+new_r11);
evalcond[4]=(((new_r11*x571))+gconst84);
evalcond[5]=(((new_r00*x571))+(((-1.0)*gconst84)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
CheckValue<IkReal> x574 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x574.valid){
continue;
}
IkReal x573=((-1.0)*(x574.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst83;
cj3=gconst84;
j3=x573;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst82=x573;
IkReal gconst83=0;
IkReal x575 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x575)==0){
continue;
}
IkReal gconst84=(new_r11*(pow(x575,-0.5)));
j1eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x577 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x577.valid){
continue;
}
IkReal x576=((-1.0)*(x577.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst83;
cj3=gconst84;
j3=x576;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst82=x576;
IkReal gconst83=0;
IkReal x578 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x578)==0){
continue;
}
IkReal gconst84=(new_r11*(pow(x578,-0.5)));
j1eval[0]=new_r11;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x580 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x580.valid){
continue;
}
IkReal x579=((-1.0)*(x580.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst83;
cj3=gconst84;
j3=x579;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst82=x579;
IkReal gconst83=0;
IkReal x581 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x581)==0){
continue;
}
IkReal gconst84=(new_r11*(pow(x581,-0.5)));
j1eval[0]=new_r10;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x582=IKPowWithIntegerCheck(new_r10,-1);
if(!x582.valid){
continue;
}
CheckValue<IkReal> x583=IKPowWithIntegerCheck(gconst84,-1);
if(!x583.valid){
continue;
}
if( IKabs((gconst84*(x582.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11*(x583.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((gconst84*(x582.value)))+IKsqr(((-1.0)*new_r11*(x583.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((gconst84*(x582.value)), ((-1.0)*new_r11*(x583.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x584=IKsin(j1);
IkReal x585=IKcos(j1);
IkReal x586=((1.0)*gconst84);
IkReal x587=((-1.0)*gconst84);
evalcond[0]=(new_r11*x584);
evalcond[1]=(new_r10*x585);
evalcond[2]=(x584*x587);
evalcond[3]=(x585*x587);
evalcond[4]=(((gconst84*x585))+new_r11);
evalcond[5]=(gconst84+((new_r11*x585)));
evalcond[6]=((((-1.0)*x584*x586))+new_r10);
evalcond[7]=((((-1.0)*x586))+((new_r10*x584)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x588=IKPowWithIntegerCheck(gconst84,-1);
if(!x588.valid){
continue;
}
CheckValue<IkReal> x589=IKPowWithIntegerCheck(new_r11,-1);
if(!x589.valid){
continue;
}
if( IKabs((new_r10*(x588.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst84*(x589.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x588.value)))+IKsqr(((-1.0)*gconst84*(x589.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((new_r10*(x588.value)), ((-1.0)*gconst84*(x589.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x590=IKsin(j1);
IkReal x591=IKcos(j1);
IkReal x592=((1.0)*gconst84);
IkReal x593=((-1.0)*gconst84);
evalcond[0]=(new_r11*x590);
evalcond[1]=(new_r10*x591);
evalcond[2]=(x590*x593);
evalcond[3]=(x591*x593);
evalcond[4]=(((gconst84*x591))+new_r11);
evalcond[5]=(((new_r11*x591))+gconst84);
evalcond[6]=((((-1.0)*x590*x592))+new_r10);
evalcond[7]=(((new_r10*x590))+(((-1.0)*x592)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x594 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x594.valid){
continue;
}
CheckValue<IkReal> x595=IKPowWithIntegerCheck(IKsign(gconst84),-1);
if(!x595.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x594.value)+(((1.5707963267949)*(x595.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x596=IKsin(j1);
IkReal x597=IKcos(j1);
IkReal x598=((1.0)*gconst84);
IkReal x599=((-1.0)*gconst84);
evalcond[0]=(new_r11*x596);
evalcond[1]=(new_r10*x597);
evalcond[2]=(x596*x599);
evalcond[3]=(x597*x599);
evalcond[4]=(((gconst84*x597))+new_r11);
evalcond[5]=(((new_r11*x597))+gconst84);
evalcond[6]=((((-1.0)*x596*x598))+new_r10);
evalcond[7]=(((new_r10*x596))+(((-1.0)*x598)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r01);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
CheckValue<IkReal> x601 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x601.valid){
continue;
}
IkReal x600=((-1.0)*(x601.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst83;
cj3=gconst84;
j3=x600;
new_r01=0;
IkReal gconst82=x600;
IkReal gconst83=0;
IkReal x602 = new_r11*new_r11;
if(IKabs(x602)==0){
continue;
}
IkReal gconst84=(new_r11*(pow(x602,-0.5)));
j1eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x604 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x604.valid){
continue;
}
IkReal x603=((-1.0)*(x604.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst83;
cj3=gconst84;
j3=x603;
new_r01=0;
IkReal gconst82=x603;
IkReal gconst83=0;
IkReal x605 = new_r11*new_r11;
if(IKabs(x605)==0){
continue;
}
IkReal gconst84=(new_r11*(pow(x605,-0.5)));
j1eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x607 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x607.valid){
continue;
}
IkReal x606=((-1.0)*(x607.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst83;
cj3=gconst84;
j3=x606;
new_r01=0;
IkReal gconst82=x606;
IkReal gconst83=0;
IkReal x608 = new_r11*new_r11;
if(IKabs(x608)==0){
continue;
}
IkReal gconst84=(new_r11*(pow(x608,-0.5)));
j1eval[0]=new_r11;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x609=IKPowWithIntegerCheck(gconst84,-1);
if(!x609.valid){
continue;
}
CheckValue<IkReal> x610=IKPowWithIntegerCheck(new_r11,-1);
if(!x610.valid){
continue;
}
if( IKabs((new_r10*(x609.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst84*(x610.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x609.value)))+IKsqr(((-1.0)*gconst84*(x610.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((new_r10*(x609.value)), ((-1.0)*gconst84*(x610.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x611=IKsin(j1);
IkReal x612=IKcos(j1);
IkReal x613=((1.0)*gconst84);
evalcond[0]=(new_r11*x611);
evalcond[1]=((-1.0)*gconst84*x611);
evalcond[2]=(((gconst84*x612))+new_r11);
evalcond[3]=(gconst84+((new_r11*x612)));
evalcond[4]=((((-1.0)*x611*x613))+new_r10);
evalcond[5]=((((-1.0)*x612*x613))+new_r00);
evalcond[6]=(((new_r10*x612))+(((-1.0)*new_r00*x611)));
evalcond[7]=(((new_r10*x611))+(((-1.0)*x613))+((new_r00*x612)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x614 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x614.valid){
continue;
}
CheckValue<IkReal> x615=IKPowWithIntegerCheck(IKsign(gconst84),-1);
if(!x615.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x614.value)+(((1.5707963267949)*(x615.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x616=IKsin(j1);
IkReal x617=IKcos(j1);
IkReal x618=((1.0)*gconst84);
evalcond[0]=(new_r11*x616);
evalcond[1]=((-1.0)*gconst84*x616);
evalcond[2]=(((gconst84*x617))+new_r11);
evalcond[3]=(gconst84+((new_r11*x617)));
evalcond[4]=(new_r10+(((-1.0)*x616*x618)));
evalcond[5]=((((-1.0)*x617*x618))+new_r00);
evalcond[6]=(((new_r10*x617))+(((-1.0)*new_r00*x616)));
evalcond[7]=(((new_r10*x616))+(((-1.0)*x618))+((new_r00*x617)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x619=IKPowWithIntegerCheck(IKsign(gconst84),-1);
if(!x619.valid){
continue;
}
CheckValue<IkReal> x620 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x620.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x619.value)))+(x620.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x621=IKsin(j1);
IkReal x622=IKcos(j1);
IkReal x623=((1.0)*gconst84);
evalcond[0]=(new_r11*x621);
evalcond[1]=((-1.0)*gconst84*x621);
evalcond[2]=(((gconst84*x622))+new_r11);
evalcond[3]=(gconst84+((new_r11*x622)));
evalcond[4]=((((-1.0)*x621*x623))+new_r10);
evalcond[5]=((((-1.0)*x622*x623))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x621))+((new_r10*x622)));
evalcond[7]=((((-1.0)*x623))+((new_r00*x622))+((new_r10*x621)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x624=((1.0)*new_r11);
CheckValue<IkReal> x625=IKPowWithIntegerCheck(IKsign(((((-1.0)*gconst84*x624))+((gconst83*new_r01)))),-1);
if(!x625.valid){
continue;
}
CheckValue<IkReal> x626 = IKatan2WithCheck(IkReal(((((-1.0)*new_r01*x624))+((gconst83*gconst84)))),IkReal(((((-1.0)*(gconst83*gconst83)))+(new_r11*new_r11))),IKFAST_ATAN2_MAGTHRESH);
if(!x626.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x625.value)))+(x626.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x627=IKcos(j1);
IkReal x628=IKsin(j1);
IkReal x629=((1.0)*gconst84);
IkReal x630=(gconst83*x627);
IkReal x631=((1.0)*x628);
IkReal x632=(x628*x629);
evalcond[0]=(gconst83+((new_r01*x627))+((new_r11*x628)));
evalcond[1]=(((gconst83*x628))+((gconst84*x627))+new_r11);
evalcond[2]=((((-1.0)*new_r00*x631))+gconst83+((new_r10*x627)));
evalcond[3]=((((-1.0)*new_r01*x631))+gconst84+((new_r11*x627)));
evalcond[4]=((((-1.0)*x632))+x630+new_r01);
evalcond[5]=((((-1.0)*x632))+x630+new_r10);
evalcond[6]=((((-1.0)*x629))+((new_r00*x627))+((new_r10*x628)));
evalcond[7]=((((-1.0)*gconst83*x631))+(((-1.0)*x627*x629))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x633=((1.0)*gconst83);
CheckValue<IkReal> x634 = IKatan2WithCheck(IkReal((((gconst84*new_r01))+(((-1.0)*new_r11*x633)))),IkReal(((((-1.0)*new_r01*x633))+(((-1.0)*gconst84*new_r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x634.valid){
continue;
}
CheckValue<IkReal> x635=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x635.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x634.value)+(((1.5707963267949)*(x635.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x636=IKcos(j1);
IkReal x637=IKsin(j1);
IkReal x638=((1.0)*gconst84);
IkReal x639=(gconst83*x636);
IkReal x640=((1.0)*x637);
IkReal x641=(x637*x638);
evalcond[0]=(gconst83+((new_r01*x636))+((new_r11*x637)));
evalcond[1]=(((gconst83*x637))+((gconst84*x636))+new_r11);
evalcond[2]=(gconst83+(((-1.0)*new_r00*x640))+((new_r10*x636)));
evalcond[3]=(gconst84+(((-1.0)*new_r01*x640))+((new_r11*x636)));
evalcond[4]=((((-1.0)*x641))+x639+new_r01);
evalcond[5]=((((-1.0)*x641))+x639+new_r10);
evalcond[6]=((((-1.0)*x638))+((new_r00*x636))+((new_r10*x637)));
evalcond[7]=((((-1.0)*x636*x638))+(((-1.0)*gconst83*x640))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x642=((1.0)*gconst83);
CheckValue<IkReal> x643 = IKatan2WithCheck(IkReal(((((-1.0)*new_r10*x642))+((gconst83*new_r01)))),IkReal(((((-1.0)*new_r11*x642))+(((-1.0)*new_r00*x642)))),IKFAST_ATAN2_MAGTHRESH);
if(!x643.valid){
continue;
}
CheckValue<IkReal> x644=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x644.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x643.value)+(((1.5707963267949)*(x644.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x645=IKcos(j1);
IkReal x646=IKsin(j1);
IkReal x647=((1.0)*gconst84);
IkReal x648=(gconst83*x645);
IkReal x649=((1.0)*x646);
IkReal x650=(x646*x647);
evalcond[0]=(gconst83+((new_r11*x646))+((new_r01*x645)));
evalcond[1]=(((gconst83*x646))+new_r11+((gconst84*x645)));
evalcond[2]=(gconst83+((new_r10*x645))+(((-1.0)*new_r00*x649)));
evalcond[3]=(gconst84+((new_r11*x645))+(((-1.0)*new_r01*x649)));
evalcond[4]=((((-1.0)*x650))+x648+new_r01);
evalcond[5]=((((-1.0)*x650))+x648+new_r10);
evalcond[6]=((((-1.0)*x647))+((new_r10*x646))+((new_r00*x645)));
evalcond[7]=((((-1.0)*gconst83*x649))+(((-1.0)*x645*x647))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x652 = ((new_r01*new_r01)+(new_r11*new_r11));
if(IKabs(x652)==0){
continue;
}
IkReal x651=pow(x652,-0.5);
CheckValue<IkReal> x653 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x653.valid){
continue;
}
IkReal gconst85=((3.14159265358979)+(((-1.0)*(x653.value))));
IkReal gconst86=((1.0)*new_r01*x651);
IkReal gconst87=((-1.0)*new_r11*x651);
CheckValue<IkReal> x654 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x654.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x654.value)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
CheckValue<IkReal> x657 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x657.valid){
continue;
}
IkReal x655=((1.0)*(x657.value));
IkReal x656=x651;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst86;
cj3=gconst87;
j3=((3.14159265)+(((-1.0)*x655)));
IkReal gconst85=((3.14159265358979)+(((-1.0)*x655)));
IkReal gconst86=((1.0)*new_r01*x656);
IkReal gconst87=((-1.0)*new_r11*x656);
IkReal x658=new_r01*new_r01;
IkReal x659=(((new_r10*new_r11))+((new_r00*new_r01)));
IkReal x660=x651;
IkReal x661=((1.0)*new_r01*x660);
j1eval[0]=x659;
j1eval[1]=IKsign(x659);
j1eval[2]=((IKabs(((((-1.0)*new_r11*x661))+(((-1.0)*new_r00*x661)))))+(IKabs(((((-1.0)*new_r10*x661))+((x658*x660))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
CheckValue<IkReal> x664 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x664.valid){
continue;
}
IkReal x662=((1.0)*(x664.value));
IkReal x663=x651;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst86;
cj3=gconst87;
j3=((3.14159265)+(((-1.0)*x662)));
IkReal gconst85=((3.14159265358979)+(((-1.0)*x662)));
IkReal gconst86=((1.0)*new_r01*x663);
IkReal gconst87=((-1.0)*new_r11*x663);
IkReal x665=((new_r01*new_r01)+(new_r11*new_r11));
j1eval[0]=x665;
j1eval[1]=IKsign(x665);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x668 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x668.valid){
continue;
}
IkReal x666=((1.0)*(x668.value));
IkReal x667=x651;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst86;
cj3=gconst87;
j3=((3.14159265)+(((-1.0)*x666)));
IkReal gconst85=((3.14159265358979)+(((-1.0)*x666)));
IkReal gconst86=((1.0)*new_r01*x667);
IkReal gconst87=((-1.0)*new_r11*x667);
IkReal x669=new_r01*new_r01;
IkReal x670=new_r11*new_r11;
IkReal x671=((1.0)*x669);
CheckValue<IkReal> x677=IKPowWithIntegerCheck((x669+x670),-1);
if(!x677.valid){
continue;
}
IkReal x672=x677.value;
CheckValue<IkReal> x678=IKPowWithIntegerCheck(((((-1.0)*x670))+(((-1.0)*x671))),-1);
if(!x678.valid){
continue;
}
IkReal x673=x678.value;
IkReal x674=((1.0)*x673);
IkReal x675=(new_r11*x674);
IkReal x676=(new_r01*x674);
j1eval[0]=((IKabs((((x669*x670*x672))+(((-1.0)*x671*x672))+((x672*(x670*x670))))))+(IKabs(((((-1.0)*new_r01*x675))+(((-1.0)*x675*(new_r01*new_r01*new_r01)))+(((-1.0)*new_r01*x675*(new_r11*new_r11)))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
CheckValue<IkReal> x680 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x680.valid){
continue;
}
IkReal x679=((1.0)*(x680.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst86;
cj3=gconst87;
j3=((3.14159265)+(((-1.0)*x679)));
new_r11=0;
new_r00=0;
IkReal gconst85=((3.14159265358979)+(((-1.0)*x679)));
IkReal x681 = new_r01*new_r01;
if(IKabs(x681)==0){
continue;
}
IkReal gconst86=((1.0)*new_r01*(pow(x681,-0.5)));
IkReal gconst87=0;
j1eval[0]=new_r01;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x683 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x683.valid){
continue;
}
IkReal x682=((1.0)*(x683.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst86;
cj3=gconst87;
j3=((3.14159265)+(((-1.0)*x682)));
new_r11=0;
new_r00=0;
IkReal gconst85=((3.14159265358979)+(((-1.0)*x682)));
IkReal x684 = new_r01*new_r01;
if(IKabs(x684)==0){
continue;
}
IkReal gconst86=((1.0)*new_r01*(pow(x684,-0.5)));
IkReal gconst87=0;
j1eval[0]=new_r10;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x685=IKPowWithIntegerCheck(gconst86,-1);
if(!x685.valid){
continue;
}
cj1array[0]=((-1.0)*new_r01*(x685.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x686=IKsin(j1);
IkReal x687=IKcos(j1);
evalcond[0]=(new_r10*x686);
evalcond[1]=(gconst86*x686);
evalcond[2]=((-1.0)*new_r01*x686);
evalcond[3]=(gconst86+((new_r01*x687)));
evalcond[4]=(gconst86+((new_r10*x687)));
evalcond[5]=(new_r10+((gconst86*x687)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x688=IKPowWithIntegerCheck(new_r10,-1);
if(!x688.valid){
continue;
}
cj1array[0]=((-1.0)*gconst86*(x688.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x689=IKsin(j1);
IkReal x690=IKcos(j1);
IkReal x691=(gconst86*x690);
evalcond[0]=(new_r10*x689);
evalcond[1]=(gconst86*x689);
evalcond[2]=((-1.0)*new_r01*x689);
evalcond[3]=(gconst86+((new_r01*x690)));
evalcond[4]=(x691+new_r01);
evalcond[5]=(x691+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x692=IKPowWithIntegerCheck(new_r01,-1);
if(!x692.valid){
continue;
}
cj1array[0]=((-1.0)*gconst86*(x692.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x693=IKsin(j1);
IkReal x694=IKcos(j1);
IkReal x695=(gconst86*x694);
evalcond[0]=(new_r10*x693);
evalcond[1]=(gconst86*x693);
evalcond[2]=((-1.0)*new_r01*x693);
evalcond[3]=(gconst86+((new_r10*x694)));
evalcond[4]=(x695+new_r01);
evalcond[5]=(x695+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
evalcond[1]=gconst86;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[4];
CheckValue<IkReal> x697 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x697.valid){
continue;
}
IkReal x696=((1.0)*(x697.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst86;
cj3=gconst87;
j3=((3.14159265)+(((-1.0)*x696)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst85=((3.14159265358979)+(((-1.0)*x696)));
IkReal gconst86=((1.0)*new_r01);
IkReal gconst87=((-1.0)*new_r11);
j1eval[0]=1.0;
j1eval[1]=new_r01;
j1eval[2]=1.0;
j1eval[3]=1.0;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  || IKabs(j1eval[3]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
CheckValue<IkReal> x699 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x699.valid){
continue;
}
IkReal x698=((1.0)*(x699.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst86;
cj3=gconst87;
j3=((3.14159265)+(((-1.0)*x698)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst85=((3.14159265358979)+(((-1.0)*x698)));
IkReal gconst86=((1.0)*new_r01);
IkReal gconst87=((-1.0)*new_r11);
j1eval[0]=-1.0;
j1eval[1]=((IKabs(((-1.0)+(new_r01*new_r01))))+(IKabs(((1.0)*new_r01*new_r11))));
j1eval[2]=-1.0;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
CheckValue<IkReal> x701 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x701.valid){
continue;
}
IkReal x700=((1.0)*(x701.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst86;
cj3=gconst87;
j3=((3.14159265)+(((-1.0)*x700)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst85=((3.14159265358979)+(((-1.0)*x700)));
IkReal gconst86=((1.0)*new_r01);
IkReal gconst87=((-1.0)*new_r11);
j1eval[0]=1.0;
j1eval[1]=((IKabs(((2.0)*new_r01*new_r11)))+(IKabs(((1.0)+(((-2.0)*(new_r01*new_r01)))))));
j1eval[2]=1.0;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x702=((1.0)*gconst86);
CheckValue<IkReal> x703=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x703.valid){
continue;
}
CheckValue<IkReal> x704 = IKatan2WithCheck(IkReal((((gconst87*new_r01))+(((-1.0)*new_r11*x702)))),IkReal(((((-1.0)*gconst87*new_r11))+(((-1.0)*new_r01*x702)))),IKFAST_ATAN2_MAGTHRESH);
if(!x704.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x703.value)))+(x704.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x705=IKsin(j1);
IkReal x706=IKcos(j1);
IkReal x707=(gconst86*x706);
IkReal x708=((1.0)*x705);
IkReal x709=(gconst87*x706);
IkReal x710=(gconst87*x708);
evalcond[0]=(((new_r01*x706))+gconst86+((new_r11*x705)));
evalcond[1]=(((gconst86*x705))+x709+new_r11);
evalcond[2]=((((-1.0)*x710))+x707);
evalcond[3]=(gconst87+((new_r11*x706))+(((-1.0)*new_r01*x708)));
evalcond[4]=((((-1.0)*x710))+x707+new_r01);
evalcond[5]=((((-1.0)*x709))+(((-1.0)*gconst86*x708)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x711=IKPowWithIntegerCheck(IKsign(((((-1.0)*(gconst86*gconst86)))+(((-1.0)*(gconst87*gconst87))))),-1);
if(!x711.valid){
continue;
}
CheckValue<IkReal> x712 = IKatan2WithCheck(IkReal((gconst86*new_r11)),IkReal((gconst87*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x712.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x711.value)))+(x712.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x713=IKsin(j1);
IkReal x714=IKcos(j1);
IkReal x715=(gconst86*x714);
IkReal x716=((1.0)*x713);
IkReal x717=(gconst87*x714);
IkReal x718=(gconst87*x716);
evalcond[0]=(((new_r01*x714))+gconst86+((new_r11*x713)));
evalcond[1]=(((gconst86*x713))+x717+new_r11);
evalcond[2]=((((-1.0)*x718))+x715);
evalcond[3]=(gconst87+((new_r11*x714))+(((-1.0)*new_r01*x716)));
evalcond[4]=((((-1.0)*x718))+x715+new_r01);
evalcond[5]=((((-1.0)*x717))+(((-1.0)*gconst86*x716)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x719=IKPowWithIntegerCheck(IKsign(((((-1.0)*gconst87*new_r11))+((gconst86*new_r01)))),-1);
if(!x719.valid){
continue;
}
CheckValue<IkReal> x720 = IKatan2WithCheck(IkReal((gconst86*gconst87)),IkReal(((-1.0)*(gconst86*gconst86))),IKFAST_ATAN2_MAGTHRESH);
if(!x720.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x719.value)))+(x720.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x721=IKsin(j1);
IkReal x722=IKcos(j1);
IkReal x723=(gconst86*x722);
IkReal x724=((1.0)*x721);
IkReal x725=(gconst87*x722);
IkReal x726=(gconst87*x724);
evalcond[0]=(gconst86+((new_r01*x722))+((new_r11*x721)));
evalcond[1]=(((gconst86*x721))+x725+new_r11);
evalcond[2]=((((-1.0)*x726))+x723);
evalcond[3]=(gconst87+((new_r11*x722))+(((-1.0)*new_r01*x724)));
evalcond[4]=((((-1.0)*x726))+x723+new_r01);
evalcond[5]=((((-1.0)*gconst86*x724))+(((-1.0)*x725)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x727=IKPowWithIntegerCheck(gconst87,-1);
if(!x727.valid){
continue;
}
cj1array[0]=(new_r00*(x727.value));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x728=IKsin(j1);
IkReal x729=IKcos(j1);
IkReal x730=((-1.0)*x728);
evalcond[0]=(new_r11*x728);
evalcond[1]=(new_r00*x730);
evalcond[2]=(gconst87*x730);
evalcond[3]=(((gconst87*x729))+new_r11);
evalcond[4]=(gconst87+((new_r11*x729)));
evalcond[5]=(((new_r00*x729))+(((-1.0)*gconst87)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
CheckValue<IkReal> x732 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x732.valid){
continue;
}
IkReal x731=((1.0)*(x732.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst86;
cj3=gconst87;
j3=((3.14159265)+(((-1.0)*x731)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst85=((3.14159265358979)+(((-1.0)*x731)));
IkReal gconst86=0;
IkReal x733 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x733)==0){
continue;
}
IkReal gconst87=((-1.0)*new_r11*(pow(x733,-0.5)));
j1eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x735 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x735.valid){
continue;
}
IkReal x734=((1.0)*(x735.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst86;
cj3=gconst87;
j3=((3.14159265)+(((-1.0)*x734)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst85=((3.14159265358979)+(((-1.0)*x734)));
IkReal gconst86=0;
IkReal x736 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x736)==0){
continue;
}
IkReal gconst87=((-1.0)*new_r11*(pow(x736,-0.5)));
j1eval[0]=new_r11;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x738 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x738.valid){
continue;
}
IkReal x737=((1.0)*(x738.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst86;
cj3=gconst87;
j3=((3.14159265)+(((-1.0)*x737)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst85=((3.14159265358979)+(((-1.0)*x737)));
IkReal gconst86=0;
IkReal x739 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x739)==0){
continue;
}
IkReal gconst87=((-1.0)*new_r11*(pow(x739,-0.5)));
j1eval[0]=new_r10;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x740=IKPowWithIntegerCheck(new_r10,-1);
if(!x740.valid){
continue;
}
CheckValue<IkReal> x741=IKPowWithIntegerCheck(gconst87,-1);
if(!x741.valid){
continue;
}
if( IKabs((gconst87*(x740.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11*(x741.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((gconst87*(x740.value)))+IKsqr(((-1.0)*new_r11*(x741.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((gconst87*(x740.value)), ((-1.0)*new_r11*(x741.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x742=IKsin(j1);
IkReal x743=IKcos(j1);
IkReal x744=(gconst87*x742);
IkReal x745=(gconst87*x743);
evalcond[0]=(new_r11*x742);
evalcond[1]=(new_r10*x743);
evalcond[2]=((-1.0)*x744);
evalcond[3]=((-1.0)*x745);
evalcond[4]=(x745+new_r11);
evalcond[5]=(gconst87+((new_r11*x743)));
evalcond[6]=((((-1.0)*x744))+new_r10);
evalcond[7]=((((-1.0)*gconst87))+((new_r10*x742)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x746=IKPowWithIntegerCheck(gconst87,-1);
if(!x746.valid){
continue;
}
CheckValue<IkReal> x747=IKPowWithIntegerCheck(new_r11,-1);
if(!x747.valid){
continue;
}
if( IKabs((new_r10*(x746.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst87*(x747.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x746.value)))+IKsqr(((-1.0)*gconst87*(x747.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((new_r10*(x746.value)), ((-1.0)*gconst87*(x747.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x748=IKsin(j1);
IkReal x749=IKcos(j1);
IkReal x750=(gconst87*x748);
IkReal x751=(gconst87*x749);
evalcond[0]=(new_r11*x748);
evalcond[1]=(new_r10*x749);
evalcond[2]=((-1.0)*x750);
evalcond[3]=((-1.0)*x751);
evalcond[4]=(x751+new_r11);
evalcond[5]=(gconst87+((new_r11*x749)));
evalcond[6]=((((-1.0)*x750))+new_r10);
evalcond[7]=((((-1.0)*gconst87))+((new_r10*x748)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x752 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x752.valid){
continue;
}
CheckValue<IkReal> x753=IKPowWithIntegerCheck(IKsign(gconst87),-1);
if(!x753.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x752.value)+(((1.5707963267949)*(x753.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x754=IKsin(j1);
IkReal x755=IKcos(j1);
IkReal x756=(gconst87*x754);
IkReal x757=(gconst87*x755);
evalcond[0]=(new_r11*x754);
evalcond[1]=(new_r10*x755);
evalcond[2]=((-1.0)*x756);
evalcond[3]=((-1.0)*x757);
evalcond[4]=(x757+new_r11);
evalcond[5]=(gconst87+((new_r11*x755)));
evalcond[6]=((((-1.0)*x756))+new_r10);
evalcond[7]=((((-1.0)*gconst87))+((new_r10*x754)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r01);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
CheckValue<IkReal> x759 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x759.valid){
continue;
}
IkReal x758=((1.0)*(x759.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst86;
cj3=gconst87;
j3=((3.14159265)+(((-1.0)*x758)));
new_r01=0;
IkReal gconst85=((3.14159265358979)+(((-1.0)*x758)));
IkReal gconst86=0;
IkReal x760 = new_r11*new_r11;
if(IKabs(x760)==0){
continue;
}
IkReal gconst87=((-1.0)*new_r11*(pow(x760,-0.5)));
j1eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x762 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x762.valid){
continue;
}
IkReal x761=((1.0)*(x762.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst86;
cj3=gconst87;
j3=((3.14159265)+(((-1.0)*x761)));
new_r01=0;
IkReal gconst85=((3.14159265358979)+(((-1.0)*x761)));
IkReal gconst86=0;
IkReal x763 = new_r11*new_r11;
if(IKabs(x763)==0){
continue;
}
IkReal gconst87=((-1.0)*new_r11*(pow(x763,-0.5)));
j1eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
CheckValue<IkReal> x765 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x765.valid){
continue;
}
IkReal x764=((1.0)*(x765.value));
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=gconst86;
cj3=gconst87;
j3=((3.14159265)+(((-1.0)*x764)));
new_r01=0;
IkReal gconst85=((3.14159265358979)+(((-1.0)*x764)));
IkReal gconst86=0;
IkReal x766 = new_r11*new_r11;
if(IKabs(x766)==0){
continue;
}
IkReal gconst87=((-1.0)*new_r11*(pow(x766,-0.5)));
j1eval[0]=new_r11;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x767=IKPowWithIntegerCheck(gconst87,-1);
if(!x767.valid){
continue;
}
CheckValue<IkReal> x768=IKPowWithIntegerCheck(new_r11,-1);
if(!x768.valid){
continue;
}
if( IKabs((new_r10*(x767.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst87*(x768.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x767.value)))+IKsqr(((-1.0)*gconst87*(x768.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((new_r10*(x767.value)), ((-1.0)*gconst87*(x768.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x769=IKsin(j1);
IkReal x770=IKcos(j1);
IkReal x771=((1.0)*gconst87);
evalcond[0]=(new_r11*x769);
evalcond[1]=((-1.0)*gconst87*x769);
evalcond[2]=(((gconst87*x770))+new_r11);
evalcond[3]=(gconst87+((new_r11*x770)));
evalcond[4]=((((-1.0)*x769*x771))+new_r10);
evalcond[5]=(new_r00+(((-1.0)*x770*x771)));
evalcond[6]=(((new_r10*x770))+(((-1.0)*new_r00*x769)));
evalcond[7]=(((new_r10*x769))+((new_r00*x770))+(((-1.0)*x771)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x772 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x772.valid){
continue;
}
CheckValue<IkReal> x773=IKPowWithIntegerCheck(IKsign(gconst87),-1);
if(!x773.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x772.value)+(((1.5707963267949)*(x773.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x774=IKsin(j1);
IkReal x775=IKcos(j1);
IkReal x776=((1.0)*gconst87);
evalcond[0]=(new_r11*x774);
evalcond[1]=((-1.0)*gconst87*x774);
evalcond[2]=(((gconst87*x775))+new_r11);
evalcond[3]=(gconst87+((new_r11*x775)));
evalcond[4]=((((-1.0)*x774*x776))+new_r10);
evalcond[5]=((((-1.0)*x775*x776))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x774))+((new_r10*x775)));
evalcond[7]=(((new_r00*x775))+((new_r10*x774))+(((-1.0)*x776)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x777 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x777.valid){
continue;
}
CheckValue<IkReal> x778=IKPowWithIntegerCheck(IKsign(gconst87),-1);
if(!x778.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x777.value)+(((1.5707963267949)*(x778.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x779=IKsin(j1);
IkReal x780=IKcos(j1);
IkReal x781=((1.0)*gconst87);
evalcond[0]=(new_r11*x779);
evalcond[1]=((-1.0)*gconst87*x779);
evalcond[2]=(new_r11+((gconst87*x780)));
evalcond[3]=(((new_r11*x780))+gconst87);
evalcond[4]=(new_r10+(((-1.0)*x779*x781)));
evalcond[5]=(new_r00+(((-1.0)*x780*x781)));
evalcond[6]=((((-1.0)*new_r00*x779))+((new_r10*x780)));
evalcond[7]=((((-1.0)*x781))+((new_r00*x780))+((new_r10*x779)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x782=((1.0)*new_r11);
CheckValue<IkReal> x783=IKPowWithIntegerCheck(IKsign((((gconst86*new_r01))+(((-1.0)*gconst87*x782)))),-1);
if(!x783.valid){
continue;
}
CheckValue<IkReal> x784 = IKatan2WithCheck(IkReal(((((-1.0)*new_r01*x782))+((gconst86*gconst87)))),IkReal(((((-1.0)*(gconst86*gconst86)))+(new_r11*new_r11))),IKFAST_ATAN2_MAGTHRESH);
if(!x784.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x783.value)))+(x784.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x785=IKsin(j1);
IkReal x786=IKcos(j1);
IkReal x787=((1.0)*gconst87);
IkReal x788=(gconst86*x786);
IkReal x789=(gconst86*x785);
IkReal x790=((1.0)*x785);
IkReal x791=(x785*x787);
evalcond[0]=(((new_r11*x785))+gconst86+((new_r01*x786)));
evalcond[1]=(x789+new_r11+((gconst87*x786)));
evalcond[2]=(((new_r10*x786))+gconst86+(((-1.0)*new_r00*x790)));
evalcond[3]=((((-1.0)*new_r01*x790))+((new_r11*x786))+gconst87);
evalcond[4]=((((-1.0)*x791))+x788+new_r01);
evalcond[5]=((((-1.0)*x791))+x788+new_r10);
evalcond[6]=(((new_r10*x785))+(((-1.0)*x787))+((new_r00*x786)));
evalcond[7]=((((-1.0)*x786*x787))+(((-1.0)*x789))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x792=((1.0)*gconst86);
CheckValue<IkReal> x793 = IKatan2WithCheck(IkReal((((gconst87*new_r01))+(((-1.0)*new_r11*x792)))),IkReal(((((-1.0)*gconst87*new_r11))+(((-1.0)*new_r01*x792)))),IKFAST_ATAN2_MAGTHRESH);
if(!x793.valid){
continue;
}
CheckValue<IkReal> x794=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x794.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x793.value)+(((1.5707963267949)*(x794.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x795=IKsin(j1);
IkReal x796=IKcos(j1);
IkReal x797=((1.0)*gconst87);
IkReal x798=(gconst86*x796);
IkReal x799=(gconst86*x795);
IkReal x800=((1.0)*x795);
IkReal x801=(x795*x797);
evalcond[0]=(((new_r11*x795))+gconst86+((new_r01*x796)));
evalcond[1]=(x799+new_r11+((gconst87*x796)));
evalcond[2]=(((new_r10*x796))+(((-1.0)*new_r00*x800))+gconst86);
evalcond[3]=((((-1.0)*new_r01*x800))+((new_r11*x796))+gconst87);
evalcond[4]=(x798+new_r01+(((-1.0)*x801)));
evalcond[5]=(x798+new_r10+(((-1.0)*x801)));
evalcond[6]=((((-1.0)*x797))+((new_r10*x795))+((new_r00*x796)));
evalcond[7]=((((-1.0)*x796*x797))+(((-1.0)*x799))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x802=((1.0)*gconst86);
CheckValue<IkReal> x803 = IKatan2WithCheck(IkReal((((gconst86*new_r01))+(((-1.0)*new_r10*x802)))),IkReal(((((-1.0)*new_r00*x802))+(((-1.0)*new_r11*x802)))),IKFAST_ATAN2_MAGTHRESH);
if(!x803.valid){
continue;
}
CheckValue<IkReal> x804=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x804.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x803.value)+(((1.5707963267949)*(x804.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x805=IKsin(j1);
IkReal x806=IKcos(j1);
IkReal x807=((1.0)*gconst87);
IkReal x808=(gconst86*x806);
IkReal x809=(gconst86*x805);
IkReal x810=((1.0)*x805);
IkReal x811=(x805*x807);
evalcond[0]=(gconst86+((new_r11*x805))+((new_r01*x806)));
evalcond[1]=(((gconst87*x806))+new_r11+x809);
evalcond[2]=(gconst86+(((-1.0)*new_r00*x810))+((new_r10*x806)));
evalcond[3]=(gconst87+(((-1.0)*new_r01*x810))+((new_r11*x806)));
evalcond[4]=((((-1.0)*x811))+new_r01+x808);
evalcond[5]=((((-1.0)*x811))+new_r10+x808);
evalcond[6]=(((new_r00*x806))+((new_r10*x805))+(((-1.0)*x807)));
evalcond[7]=((((-1.0)*x809))+(((-1.0)*x806*x807))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((new_r01*new_r01)+(new_r11*new_r11));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
new_r01=0;
new_r11=0;
j1eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x813 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x813.valid){
continue;
}
IkReal x812=x813.value;
j1array[0]=((-1.0)*x812);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x812)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r00*(IKsin(j1))))+((new_r10*(IKcos(j1)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x814=IKcos(j1);
IkReal x815=IKsin(j1);
IkReal x816=((1.0)*x815);
evalcond[0]=(new_r11+x814);
evalcond[1]=((((-1.0)*x816))+new_r01);
evalcond[2]=((((-1.0)*x816))+new_r10);
evalcond[3]=((((-1.0)*x814))+new_r00);
evalcond[4]=(((new_r11*x815))+((new_r01*x814)));
evalcond[5]=((-1.0)+((new_r00*x814))+((new_r10*x815)));
evalcond[6]=(((new_r10*x814))+(((-1.0)*new_r00*x816)));
evalcond[7]=((1.0)+((new_r11*x814))+(((-1.0)*new_r01*x816)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((-1.0)*new_r01), ((-1.0)*new_r00));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x817=IKsin(j1);
IkReal x818=IKcos(j1);
IkReal x819=((1.0)*x817);
evalcond[0]=(new_r01+x817);
evalcond[1]=(new_r10+x817);
evalcond[2]=(new_r00+x818);
evalcond[3]=((((-1.0)*x818))+new_r11);
evalcond[4]=(((new_r11*x817))+((new_r01*x818)));
evalcond[5]=((1.0)+((new_r00*x818))+((new_r10*x817)));
evalcond[6]=(((new_r10*x818))+(((-1.0)*new_r00*x819)));
evalcond[7]=((-1.0)+((new_r11*x818))+(((-1.0)*new_r01*x819)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
new_r11=0;
new_r00=0;
j1eval[0]=new_r01;
j1eval[1]=((IKabs(cj3))+(IKabs(sj3)));
j1eval[2]=IKsign(new_r01);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
new_r11=0;
new_r00=0;
j1eval[0]=new_r01;
j1eval[1]=new_r10;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x820=IKPowWithIntegerCheck(new_r01,-1);
if(!x820.valid){
continue;
}
CheckValue<IkReal> x821=IKPowWithIntegerCheck(new_r10,-1);
if(!x821.valid){
continue;
}
if( IKabs((cj3*(x820.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*sj3*(x821.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((cj3*(x820.value)))+IKsqr(((-1.0)*sj3*(x821.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((cj3*(x820.value)), ((-1.0)*sj3*(x821.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[7];
IkReal x822=IKcos(j1);
IkReal x823=IKsin(j1);
IkReal x824=(sj3*x822);
IkReal x825=((1.0)*x823);
IkReal x826=(cj3*x825);
evalcond[0]=(sj3+((new_r01*x822)));
evalcond[1]=(sj3+((new_r10*x822)));
evalcond[2]=(cj3+(((-1.0)*new_r01*x825)));
evalcond[3]=(((new_r10*x823))+(((-1.0)*cj3)));
evalcond[4]=(((sj3*x823))+((cj3*x822)));
evalcond[5]=((((-1.0)*x826))+new_r01+x824);
evalcond[6]=((((-1.0)*x826))+new_r10+x824);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x827=IKPowWithIntegerCheck(IKsign(new_r01),-1);
if(!x827.valid){
continue;
}
CheckValue<IkReal> x828 = IKatan2WithCheck(IkReal(cj3),IkReal(((-1.0)*sj3)),IKFAST_ATAN2_MAGTHRESH);
if(!x828.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x827.value)))+(x828.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[7];
IkReal x829=IKcos(j1);
IkReal x830=IKsin(j1);
IkReal x831=(sj3*x829);
IkReal x832=((1.0)*x830);
IkReal x833=(cj3*x832);
evalcond[0]=(sj3+((new_r01*x829)));
evalcond[1]=(sj3+((new_r10*x829)));
evalcond[2]=(cj3+(((-1.0)*new_r01*x832)));
evalcond[3]=((((-1.0)*cj3))+((new_r10*x830)));
evalcond[4]=(((sj3*x830))+((cj3*x829)));
evalcond[5]=((((-1.0)*x833))+new_r01+x831);
evalcond[6]=((((-1.0)*x833))+new_r10+x831);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
new_r11=0;
new_r01=0;
new_r22=0;
new_r20=0;
j1eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x835 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x835.valid){
continue;
}
IkReal x834=x835.value;
j1array[0]=((-1.0)*x834);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x834)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r00*(IKsin(j1))))+((new_r10*(IKcos(j1)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
j1eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x837 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x837.valid){
continue;
}
IkReal x836=x837.value;
j1array[0]=((-1.0)*x836);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x836)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
evalcond[0]=(((new_r11*(IKcos(j1))))+(((-1.0)*new_r01*(IKsin(j1)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
new_r01=0;
new_r10=0;
j1eval[0]=new_r11;
j1eval[1]=IKsign(new_r11);
j1eval[2]=((IKabs(cj3))+(IKabs(sj3)));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
new_r01=0;
new_r10=0;
j1eval[0]=new_r00;
j1eval[1]=new_r11;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
new_r01=0;
new_r10=0;
j1eval[0]=new_r11;
j1eval[1]=cj3;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
sj1array[0]=new_r00;
if( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x838=IKcos(j1);
IkReal x839=IKsin(j1);
evalcond[0]=x838;
evalcond[1]=(new_r00*x838);
evalcond[2]=(new_r11+x839);
evalcond[3]=(new_r11*x838);
evalcond[4]=((1.0)+((new_r11*x839)));
evalcond[5]=((1.0)+(((-1.0)*new_r00*x839)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
sj1array[0]=new_r11;
if( sj1array[0] >= -1-IKFAST_SINCOS_THRESH && sj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x840=IKcos(j1);
IkReal x841=IKsin(j1);
evalcond[0]=(new_r00*x840);
evalcond[1]=(new_r11*x840);
evalcond[2]=((-1.0)*x840);
evalcond[3]=(new_r00+x841);
evalcond[4]=((-1.0)+((new_r11*x841)));
evalcond[5]=((-1.0)+(((-1.0)*new_r00*x841)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x843=IKPowWithIntegerCheck(new_r11,-1);
if(!x843.valid){
continue;
}
IkReal x842=x843.value;
CheckValue<IkReal> x844=IKPowWithIntegerCheck(cj3,-1);
if(!x844.valid){
continue;
}
CheckValue<IkReal> x845=IKPowWithIntegerCheck(x842,-2);
if(!x845.valid){
continue;
}
if( IKabs(((-1.0)*sj3*x842)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x842*(x844.value)*(((1.0)+(((-1.0)*(x845.value)))+(((-1.0)*(cj3*cj3))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*sj3*x842))+IKsqr((x842*(x844.value)*(((1.0)+(((-1.0)*(x845.value)))+(((-1.0)*(cj3*cj3)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((-1.0)*sj3*x842), (x842*(x844.value)*(((1.0)+(((-1.0)*(x845.value)))+(((-1.0)*(cj3*cj3)))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[7];
IkReal x846=IKsin(j1);
IkReal x847=IKcos(j1);
IkReal x848=((1.0)*cj3);
IkReal x849=(sj3*x846);
IkReal x850=(cj3*x847);
evalcond[0]=(sj3+((new_r11*x846)));
evalcond[1]=(cj3+((new_r11*x847)));
evalcond[2]=(sj3+(((-1.0)*new_r00*x846)));
evalcond[3]=(((new_r00*x847))+(((-1.0)*x848)));
evalcond[4]=(new_r11+x850+x849);
evalcond[5]=((((-1.0)*x846*x848))+((sj3*x847)));
evalcond[6]=((((-1.0)*x847*x848))+(((-1.0)*x849))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x851=IKPowWithIntegerCheck(new_r00,-1);
if(!x851.valid){
continue;
}
CheckValue<IkReal> x852=IKPowWithIntegerCheck(new_r11,-1);
if(!x852.valid){
continue;
}
if( IKabs((sj3*(x851.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*cj3*(x852.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((sj3*(x851.value)))+IKsqr(((-1.0)*cj3*(x852.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((sj3*(x851.value)), ((-1.0)*cj3*(x852.value)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[7];
IkReal x853=IKsin(j1);
IkReal x854=IKcos(j1);
IkReal x855=((1.0)*cj3);
IkReal x856=(sj3*x853);
IkReal x857=(cj3*x854);
evalcond[0]=(sj3+((new_r11*x853)));
evalcond[1]=(cj3+((new_r11*x854)));
evalcond[2]=(sj3+(((-1.0)*new_r00*x853)));
evalcond[3]=((((-1.0)*x855))+((new_r00*x854)));
evalcond[4]=(new_r11+x856+x857);
evalcond[5]=((((-1.0)*x853*x855))+((sj3*x854)));
evalcond[6]=((((-1.0)*x856))+new_r00+(((-1.0)*x854*x855)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x858 = IKatan2WithCheck(IkReal(((-1.0)*sj3)),IkReal(((-1.0)*cj3)),IKFAST_ATAN2_MAGTHRESH);
if(!x858.valid){
continue;
}
CheckValue<IkReal> x859=IKPowWithIntegerCheck(IKsign(new_r11),-1);
if(!x859.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x858.value)+(((1.5707963267949)*(x859.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[7];
IkReal x860=IKsin(j1);
IkReal x861=IKcos(j1);
IkReal x862=((1.0)*cj3);
IkReal x863=(sj3*x860);
IkReal x864=(cj3*x861);
evalcond[0]=(sj3+((new_r11*x860)));
evalcond[1]=(cj3+((new_r11*x861)));
evalcond[2]=(sj3+(((-1.0)*new_r00*x860)));
evalcond[3]=((((-1.0)*x862))+((new_r00*x861)));
evalcond[4]=(new_r11+x864+x863);
evalcond[5]=(((sj3*x861))+(((-1.0)*x860*x862)));
evalcond[6]=((((-1.0)*x863))+(((-1.0)*x861*x862))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x865 = IKatan2WithCheck(IkReal(((-1.0)+(cj3*cj3)+(new_r01*new_r01))),IkReal(((((-1.0)*cj3*sj3))+(((-1.0)*new_r01*new_r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x865.valid){
continue;
}
CheckValue<IkReal> x866=IKPowWithIntegerCheck(IKsign((((new_r11*sj3))+((cj3*new_r01)))),-1);
if(!x866.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x865.value)+(((1.5707963267949)*(x866.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x867=IKcos(j1);
IkReal x868=IKsin(j1);
IkReal x869=(sj3*x867);
IkReal x870=((1.0)*x868);
IkReal x871=(cj3*x867);
IkReal x872=(cj3*x870);
evalcond[0]=(((new_r01*x867))+sj3+((new_r11*x868)));
evalcond[1]=(((sj3*x868))+new_r11+x871);
evalcond[2]=(sj3+(((-1.0)*new_r00*x870))+((new_r10*x867)));
evalcond[3]=(cj3+(((-1.0)*new_r01*x870))+((new_r11*x867)));
evalcond[4]=(new_r01+x869+(((-1.0)*x872)));
evalcond[5]=(new_r10+x869+(((-1.0)*x872)));
evalcond[6]=(((new_r00*x867))+((new_r10*x868))+(((-1.0)*cj3)));
evalcond[7]=((((-1.0)*x871))+(((-1.0)*sj3*x870))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x873=((1.0)*sj3);
CheckValue<IkReal> x874=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x874.valid){
continue;
}
CheckValue<IkReal> x875 = IKatan2WithCheck(IkReal(((((-1.0)*new_r11*x873))+((cj3*new_r01)))),IkReal(((((-1.0)*new_r01*x873))+(((-1.0)*cj3*new_r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x875.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x874.value)))+(x875.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x876=IKcos(j1);
IkReal x877=IKsin(j1);
IkReal x878=(sj3*x876);
IkReal x879=((1.0)*x877);
IkReal x880=(cj3*x876);
IkReal x881=(cj3*x879);
evalcond[0]=(((new_r01*x876))+sj3+((new_r11*x877)));
evalcond[1]=(((sj3*x877))+new_r11+x880);
evalcond[2]=(sj3+(((-1.0)*new_r00*x879))+((new_r10*x876)));
evalcond[3]=(cj3+(((-1.0)*new_r01*x879))+((new_r11*x876)));
evalcond[4]=((((-1.0)*x881))+new_r01+x878);
evalcond[5]=((((-1.0)*x881))+new_r10+x878);
evalcond[6]=(((new_r00*x876))+((new_r10*x877))+(((-1.0)*cj3)));
evalcond[7]=((((-1.0)*x880))+(((-1.0)*sj3*x879))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x882=((1.0)*sj3);
CheckValue<IkReal> x883 = IKatan2WithCheck(IkReal(((((-1.0)*new_r10*x882))+((new_r01*sj3)))),IkReal(((((-1.0)*new_r11*x882))+(((-1.0)*new_r00*x882)))),IKFAST_ATAN2_MAGTHRESH);
if(!x883.valid){
continue;
}
CheckValue<IkReal> x884=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x884.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x883.value)+(((1.5707963267949)*(x884.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x885=IKcos(j1);
IkReal x886=IKsin(j1);
IkReal x887=(sj3*x885);
IkReal x888=((1.0)*x886);
IkReal x889=(cj3*x885);
IkReal x890=(cj3*x888);
evalcond[0]=(sj3+((new_r01*x885))+((new_r11*x886)));
evalcond[1]=(((sj3*x886))+new_r11+x889);
evalcond[2]=(sj3+((new_r10*x885))+(((-1.0)*new_r00*x888)));
evalcond[3]=(cj3+((new_r11*x885))+(((-1.0)*new_r01*x888)));
evalcond[4]=((((-1.0)*x890))+new_r01+x887);
evalcond[5]=((((-1.0)*x890))+new_r10+x887);
evalcond[6]=(((new_r10*x886))+((new_r00*x885))+(((-1.0)*cj3)));
evalcond[7]=((((-1.0)*x889))+new_r00+(((-1.0)*sj3*x888)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=new_r12;
evalcond[2]=new_r02;
evalcond[3]=new_r20;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x891=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj3*x891))+(((-1.0)*new_r11*sj3)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj3*new_r11))+(((-1.0)*sj3*x891)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj3*x891))+(((-1.0)*new_r11*sj3))))+IKsqr((((cj3*new_r11))+(((-1.0)*sj3*x891))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((((-1.0)*cj3*x891))+(((-1.0)*new_r11*sj3))), (((cj3*new_r11))+(((-1.0)*sj3*x891))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[8];
IkReal x892=IKsin(j1);
IkReal x893=IKcos(j1);
IkReal x894=((1.0)*cj3);
IkReal x895=((1.0)*sj3);
IkReal x896=(sj3*x892);
IkReal x897=((1.0)*x892);
IkReal x898=(x893*x894);
evalcond[0]=(sj3+((new_r11*x892))+((new_r01*x893)));
evalcond[1]=(((cj3*x892))+((sj3*x893))+new_r01);
evalcond[2]=((((-1.0)*x898))+new_r11+x896);
evalcond[3]=((((-1.0)*x898))+new_r00+x896);
evalcond[4]=(((new_r00*x893))+((new_r10*x892))+(((-1.0)*x894)));
evalcond[5]=((((-1.0)*x892*x894))+(((-1.0)*x893*x895))+new_r10);
evalcond[6]=(((new_r10*x893))+(((-1.0)*x895))+(((-1.0)*new_r00*x897)));
evalcond[7]=(((new_r11*x893))+(((-1.0)*x894))+(((-1.0)*new_r01*x897)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j1eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j1eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j1eval[0]=((IKabs((new_r10*new_r22)))+(IKabs((new_r00*new_r22))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x900 = IKatan2WithCheck(IkReal((new_r10*new_r22)),IkReal(((-1.0)*new_r00*new_r22)),IKFAST_ATAN2_MAGTHRESH);
if(!x900.valid){
continue;
}
IkReal x899=x900.value;
j1array[0]=((-1.0)*x899);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x899)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x901=IKcos(j1);
IkReal x902=IKsin(j1);
IkReal x903=(new_r11*x901);
IkReal x904=((1.0)*new_r01*x902);
evalcond[0]=(((new_r11*x902))+((new_r01*x901)));
evalcond[1]=(((new_r10*x902))+((new_r00*x901)));
evalcond[2]=(((new_r10*x901))+(((-1.0)*new_r00*x902)));
evalcond[3]=((((-1.0)*x904))+x903);
evalcond[4]=(((new_r22*x903))+(((-1.0)*new_r22*x904)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x906 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x906.valid){
continue;
}
IkReal x905=x906.value;
j1array[0]=((-1.0)*x905);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x905)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x907=IKcos(j1);
IkReal x908=IKsin(j1);
IkReal x909=(new_r22*x907);
IkReal x910=((1.0)*new_r01*x908);
IkReal x911=((1.0)*new_r00*x908);
evalcond[0]=(((new_r11*x908))+((new_r01*x907)));
evalcond[1]=((((-1.0)*x911))+((new_r10*x907)));
evalcond[2]=((((-1.0)*x910))+((new_r11*x907)));
evalcond[3]=((((-1.0)*new_r22*x911))+((new_r10*x909)));
evalcond[4]=((((-1.0)*new_r22*x910))+((new_r11*x909)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x913 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x913.valid){
continue;
}
IkReal x912=x913.value;
j1array[0]=((-1.0)*x912);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x912)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x914=IKcos(j1);
IkReal x915=IKsin(j1);
IkReal x916=(new_r10*x914);
IkReal x917=(new_r11*x914);
IkReal x918=((1.0)*new_r01*x915);
IkReal x919=((1.0)*new_r00*x915);
evalcond[0]=(((new_r10*x915))+((new_r00*x914)));
evalcond[1]=((((-1.0)*x919))+x916);
evalcond[2]=((((-1.0)*x918))+x917);
evalcond[3]=((((-1.0)*new_r22*x919))+((new_r22*x916)));
evalcond[4]=((((-1.0)*new_r22*x918))+((new_r22*x917)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x921=IKPowWithIntegerCheck(cj2,-1);
if(!x921.valid){
continue;
}
IkReal x920=x921.value;
CheckValue<IkReal> x922=IKPowWithIntegerCheck(new_r11,-1);
if(!x922.valid){
continue;
}
if( IKabs((x920*(x922.value)*(((((-1.0)*cj2*sj3))+((new_r01*new_r12)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r12*x920)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x920*(x922.value)*(((((-1.0)*cj2*sj3))+((new_r01*new_r12))))))+IKsqr(((-1.0)*new_r12*x920))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((x920*(x922.value)*(((((-1.0)*cj2*sj3))+((new_r01*new_r12))))), ((-1.0)*new_r12*x920));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[18];
IkReal x923=IKsin(j1);
IkReal x924=IKcos(j1);
IkReal x925=((1.0)*cj3);
IkReal x926=((1.0)*sj2);
IkReal x927=(sj2*sj3);
IkReal x928=(cj3*sj2);
IkReal x929=((1.0)*x923);
IkReal x930=(new_r10*x924);
IkReal x931=(new_r12*x924);
IkReal x932=(sj2*x923);
IkReal x933=(new_r11*x924);
evalcond[0]=(((cj2*x924))+new_r12);
evalcond[1]=((((-1.0)*cj2*x929))+new_r02);
evalcond[2]=(((new_r02*x924))+((new_r12*x923)));
evalcond[3]=(sj3+((new_r01*x924))+((new_r11*x923)));
evalcond[4]=(cj2+(((-1.0)*new_r02*x929))+x931);
evalcond[5]=(((x924*x928))+new_r11+((sj3*x923)));
evalcond[6]=((((-1.0)*x925))+((new_r00*x924))+((new_r10*x923)));
evalcond[7]=((((-1.0)*x925*x932))+new_r01+((sj3*x924)));
evalcond[8]=(((x924*x927))+new_r10+(((-1.0)*x923*x925)));
evalcond[9]=((((-1.0)*new_r00*x929))+x930+x927);
evalcond[10]=((((-1.0)*new_r01*x929))+x933+x928);
evalcond[11]=((((-1.0)*sj3*x923*x926))+(((-1.0)*x924*x925))+new_r00);
evalcond[12]=(((new_r20*sj2))+((cj2*x930))+(((-1.0)*cj2*new_r00*x929)));
evalcond[13]=((((-1.0)*cj2*new_r01*x929))+((cj2*x933))+((new_r21*sj2)));
evalcond[14]=(((new_r02*x932))+(((-1.0)*x926*x931))+((cj2*new_r22)));
evalcond[15]=((1.0)+(((-1.0)*cj2*new_r02*x929))+((new_r22*sj2))+((cj2*x931)));
evalcond[16]=((((-1.0)*sj3))+((new_r00*x932))+(((-1.0)*x926*x930))+((cj2*new_r20)));
evalcond[17]=((((-1.0)*x925))+((new_r01*x932))+(((-1.0)*x926*x933))+((cj2*new_r21)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x934=IKPowWithIntegerCheck(IKsign(cj2),-1);
if(!x934.valid){
continue;
}
CheckValue<IkReal> x935 = IKatan2WithCheck(IkReal(new_r02),IkReal(((-1.0)*new_r12)),IKFAST_ATAN2_MAGTHRESH);
if(!x935.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x934.value)))+(x935.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[18];
IkReal x936=IKsin(j1);
IkReal x937=IKcos(j1);
IkReal x938=((1.0)*cj3);
IkReal x939=((1.0)*sj2);
IkReal x940=(sj2*sj3);
IkReal x941=(cj3*sj2);
IkReal x942=((1.0)*x936);
IkReal x943=(new_r10*x937);
IkReal x944=(new_r12*x937);
IkReal x945=(sj2*x936);
IkReal x946=(new_r11*x937);
evalcond[0]=(((cj2*x937))+new_r12);
evalcond[1]=((((-1.0)*cj2*x942))+new_r02);
evalcond[2]=(((new_r02*x937))+((new_r12*x936)));
evalcond[3]=(sj3+((new_r01*x937))+((new_r11*x936)));
evalcond[4]=(cj2+(((-1.0)*new_r02*x942))+x944);
evalcond[5]=(((x937*x941))+new_r11+((sj3*x936)));
evalcond[6]=(((new_r00*x937))+((new_r10*x936))+(((-1.0)*x938)));
evalcond[7]=((((-1.0)*x938*x945))+new_r01+((sj3*x937)));
evalcond[8]=(((x937*x940))+(((-1.0)*x936*x938))+new_r10);
evalcond[9]=((((-1.0)*new_r00*x942))+x940+x943);
evalcond[10]=((((-1.0)*new_r01*x942))+x941+x946);
evalcond[11]=((((-1.0)*sj3*x936*x939))+(((-1.0)*x937*x938))+new_r00);
evalcond[12]=(((new_r20*sj2))+((cj2*x943))+(((-1.0)*cj2*new_r00*x942)));
evalcond[13]=(((cj2*x946))+((new_r21*sj2))+(((-1.0)*cj2*new_r01*x942)));
evalcond[14]=(((new_r02*x945))+(((-1.0)*x939*x944))+((cj2*new_r22)));
evalcond[15]=((1.0)+((cj2*x944))+((new_r22*sj2))+(((-1.0)*cj2*new_r02*x942)));
evalcond[16]=((((-1.0)*sj3))+((new_r00*x945))+(((-1.0)*x939*x943))+((cj2*new_r20)));
evalcond[17]=(((new_r01*x945))+(((-1.0)*x939*x946))+((cj2*new_r21))+(((-1.0)*x938)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - pluto (15f4e249cd3e055b01609e273fc43c67)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x1000004a"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
